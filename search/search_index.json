{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Docma User Guide Version 0.0.0 Docma is a PDF document generator that can assemble and compose PDF and HTML documents from document templates with dynamic content. Docma was developed at Origin Energy as part of the Jindabyne initiative. While not part of our core IP, it proved valuable internally, and we're sharing it in the hope it's useful to others. Kudos to Origin for fostering a culture that empowers its people to build complex technology solutions in-house.","title":"Docma User Guide"},{"location":"index.html#docma-user-guide","text":"","title":"Docma User Guide"},{"location":"index.html#version-000","text":"Docma is a PDF document generator that can assemble and compose PDF and HTML documents from document templates with dynamic content. Docma was developed at Origin Energy as part of the Jindabyne initiative. While not part of our core IP, it proved valuable internally, and we're sharing it in the hope it's useful to others. Kudos to Origin for fostering a culture that empowers its people to build complex technology solutions in-house.","title":"Version 0.0.0"},{"location":"01-overview.html","text":"Overview Docma was developed at Origin Energy as part of the Jindabyne initiative. While not part of our core IP, it proved valuable internally, and we're sharing it in the hope it's useful to others. Kudos to Origin for fostering a culture that empowers its people to build complex technology solutions in-house. Docma is a PDF document generator that can assemble and compose PDF and self-contained HTML documents from document templates with dynamic content. Features include: PDF document generation with source content defined in any combination of HTML and PDF. HTML document generation from source content in HTML. Compilation of Markdown source content into HTML Dynamic content preparation (conditionals, loops, transformation etc.) based on structured data parameters fed to the rendering process at run-time. Dynamic content injection from multiple data sources, including live database connections. Composition of multiple source documents into a single PDF or HTML output. Conditional inclusion of component documents based on parameter based conditions evaluated at run-time. Deep schema validation of structured data parameters at run-time. Watermarking / stamping of PDF output. Dynamic generation of charts via the Vega-Lite specification with multiple data sources, including live database connections. Extensible interfaces for content assembly, dynamic content generation and data access. Locale support for content such as numbers, currencies, phone numbers etc.","title":"Overview"},{"location":"01-overview.html#overview","text":"Docma was developed at Origin Energy as part of the Jindabyne initiative. While not part of our core IP, it proved valuable internally, and we're sharing it in the hope it's useful to others. Kudos to Origin for fostering a culture that empowers its people to build complex technology solutions in-house. Docma is a PDF document generator that can assemble and compose PDF and self-contained HTML documents from document templates with dynamic content. Features include: PDF document generation with source content defined in any combination of HTML and PDF. HTML document generation from source content in HTML. Compilation of Markdown source content into HTML Dynamic content preparation (conditionals, loops, transformation etc.) based on structured data parameters fed to the rendering process at run-time. Dynamic content injection from multiple data sources, including live database connections. Composition of multiple source documents into a single PDF or HTML output. Conditional inclusion of component documents based on parameter based conditions evaluated at run-time. Deep schema validation of structured data parameters at run-time. Watermarking / stamping of PDF output. Dynamic generation of charts via the Vega-Lite specification with multiple data sources, including live database connections. Extensible interfaces for content assembly, dynamic content generation and data access. Locale support for content such as numbers, currencies, phone numbers etc.","title":"Overview"},{"location":"02-document-creation.html","text":"Document Creation The docma document creation process consists of these steps: Document template creation : The template content is contained in a directory dedicated to a single template. It contains the static content (e.g. HTML, PDF, Markdown and image files) as well as YAML formatted metadata files that control the rendering process, database access etc. Template compilation : The compilation process validates the template content, converts supported non-HTML content (e.g. Markdown files) into HTML and generates a compiled template package in either a directory or ZIP file. Template rendering : The rendering process uses Jinja to inject run-time parameters into the HTML template content, converts the component documents to PDF, if required, and composes all of the components into a single output PDF or standalone HTML document.","title":"Document Creation"},{"location":"02-document-creation.html#document-creation","text":"The docma document creation process consists of these steps: Document template creation : The template content is contained in a directory dedicated to a single template. It contains the static content (e.g. HTML, PDF, Markdown and image files) as well as YAML formatted metadata files that control the rendering process, database access etc. Template compilation : The compilation process validates the template content, converts supported non-HTML content (e.g. Markdown files) into HTML and generates a compiled template package in either a directory or ZIP file. Template rendering : The rendering process uses Jinja to inject run-time parameters into the HTML template content, converts the component documents to PDF, if required, and composes all of the components into a single output PDF or standalone HTML document.","title":"Document Creation"},{"location":"03-document-templates.html","text":"Document Templates The source directory for a document template should be created using the docma CLI: docma new <DIRECTORY> The resulting directory is structured thus: <DIRECTORY>/ \u251c\u2500\u2500 config.yaml ... Mandatory \u251c\u2500\u2500 charts/ ... Specification files for charts \u251c\u2500\u2500 content/ ... Document content (HTML, PDF, Markdown etc.) \u251c\u2500\u2500 data/ ... Data files (e.g CSV / JSONL files) \u251c\u2500\u2500 fonts/ ... Font files (e.g. .ttf files) \u251c\u2500\u2500 overlays/ ... Overlay content files (Typically HTML or PDF) \u251c\u2500\u2500 queries/ ... Query specifications used for charts \u2514\u2500\u2500 resources/ ... HTML resources (image files etc.) Only the config.yaml file is mandated. While the other components can be present, or not, as required, and directory structure is arbitrary, it is strongly recommended to adhere to the layout shown above. Files and directories in the template source directory matching .* are not copied into the compiled template. Template Configuration File The document template configuration file, config.yaml , is critical to the setup and operation of a docma template. The structure of the configuration file is validated during template compilation. It contains the following elements. Key Type Required Description id string Yes Template identifier. This must be at least 3 chars long, start with an alpha, end with an alphanumeric and contain only alpha-numerics and +-_= characters. description string Yes Template description. owner string Yes Template owner. version string Yes Template version. Must be in the form major.minor.patch (e.g. 1.0.0 ). documents list Yes A list of document references to be included in the specified order in the output document. overlays object No Document overlay specifications to enable watermarking / stamping of the output document (PDF only). See Watermarking below. imports list No A list of specifications for external files to include during compilation. See Document Imports below. parameters object No Contains optional keys defaults and schema . -> defaults object No Default values for rendering parameters. -> schema object No A JSON Schema for the rendering parameters. See Docma Parameter Validation . options object No Options passed to the WeasyPrint PDF generator. See WeasyPrint Options . -> stylesheets list No A list of CSS style sheet files that will be fed to the PDF generator. See CSS Style Sheets below. metadata object No Values to be added to the output document metadata. See Document Metadata below. -> author string No Document author. -> title string No Document title. -> subject string No Document subject. -> keywords string | list No A string of semi-colon separated keywords or a list of keywords for the PDF. Prior to docma v2.0, metadata fields were specified in the PDF convention of /Author instead of author . This is still supported for backward compatibility but the naming shown above should now be used. Docma will use the appropriate conventions for PDF and HTML when producing output. Document References The documents key in the configuration file is a list of component documents that will be rendered and assembled into the final output document. Each element in the document list can be either a string containing the name of a content file or an object containing the following keys: Key Type Required Description src string Yes Name of a content file. if string No A string that will be Jinja rendered with the run-time parameters and evaluated as a truthy value. If the value is true (the default), the document is included. Truthy true values are true / t / y / yes and non-zero integers. Truthy false values are false / f / no / n and zero and empty strings. Content files must be of one of the following types: HTML ( *.html / *.htm ) PDF ( *.pdf ) (for PDF output documents only) Content files can (and generally should) be contained within the template source directory hierarchy. The file is referenced by its path relative to the template source base directory. Content files can also be remote and will be loaded dynamically during the rendering process. This differs from document imports which incorporate the document into the template during template compilation. For remote content files, any of the forms supported by the importer subsystem can be used. e.g. http(s)://host/some/path/... s3://bucket/some/path/... Unlike imports, dynamically referenced content documents must be in HTML or PDF format. There is no compilation of other formats to HTML. It is strongly recommended to include all content files in the template itself (e.g using document imports for remote files). This will be faster and more predictable at run-time as well as improving traceability of documents. For example: documents: - content/cover.html # Our main contract document template - content/contract.html # Boilerplate PDF to include - content/standard-terms.pdf # Reference to a file in S3 - s3://my-content-bucket/extra-terms.pdf # Now a conditional document using evaluated parameters. # The \"if\" condition will evaluate to the string \"True\" or \"False\". - src: content/even-more-terms.pdf if: '{{ contract.term_in_years >= 3 }}' Some of the HTML files may have been compiled from other formats (e.g. Markdown) during the compilation phase. All references to the file during rendering must use the HTML file name. So, for example, a file content/text.md in the template source, will be present as content/text.html in the compiled template. The original, uncompiled files are also replicated into the template to allow later recompilation and for traceability. The uncompiled files are not used in the rendering process. See Document Template Content for more information. Overlay Documents PDF outputs only. The overlays key in the configuration file is a list of documents that are prepared in the same way as the primary documents. These are used when the final document requires an overlaid stamp or underlaid watermark. See Watermarking for more information. Document Imports The configuration file may contain an imports key to specify a list of external files that will be included within the compiled template package. The imported file is processed just like a local file, including compilation of supported non-HTML formats (e.g. Markdown) into HTML. Imports are specified as a URL, with the URL scheme determining the means of access. Imports are currently supported for: AWS S3: s3://.... Web content: http(s)://... The content importers interface is extensible. New sources can be added easily. Each import specification is either a string or an object, like so: imports: # Simple string format. This S3 file will be placed in the template based on # the last component of the filename (i.e `myfile.pdf`). - s3://my-bucket/some/path/myfile.pdf # Object format to allow a file to be imported and renamed in the process. # This will copy the file into the template as `content/afile.pdf`. - src: s3://my-bucket/some/path/myfile.pdf as: content/afile.pdf # This Markdown file will be compiled and can be referenced elsewhere in the # template as \"content/mydoc.html\" - src: s3://my-bucket/some/path/somedoc.md as: content/mydoc.md # Import an image - src: http://a.url.com/some/image.png as: resources/image.png # Import a font: - src: http://host/my-corporate-font.ttf as: fonts/my-corporate-font.ttf Imported docs are limited to 10MB in size. WeasyPrint Options PDF outputs only. WeasyPrint is used for converting HTML to PDF for PDF document production. It provides a number of options to control aspects of the PDF production process. These can be specified under the options key of the template configuration file . The following options are set by docma itself. They can be overridden in the template but it's best not to. Option Value set by docma Notes media print optimize_images True This is required to avoid an image loading bug in WeasyPrint. CSS Style Sheets PDF outputs only. The configuration file may contain an options --> styesheets key that lists files containing style sheets that will be applied to all HTML document files when converting them to PDF. Hence, these files should only contain styles that should be applied everywhere. In some cases, including for HTML outputs, it will be more appropriate to have styles defined within the HTML source document to which they relate, or included from CSS files using the Jinja include directive. Sample Configuration File A sample file might look like this: description: Contract of Sale owner: Cest Moi version: 1.0.0 # List the primary files containing document content. File names are relative to # the root of the template. documents: - content/cover.html # Our main contract document template - content/contract.html # Boilerplate PDF to include - content/standard-terms.pdf # Now a conditional document using evaluated parameters. # The \"if\" condition will evaluate to the string \"True\" or \"False\". - src: content/extra-terms.pdf if: '{{ contract.term_in_years >= 3 }}' # Bring these files into the package when building the template. imports: - src: s3://my-bucket/common-files/standard-terms.pdf as: content/standard-terms.pdf # Used in the HTML to PDF conversion options: stylesheets: - styles.css parameters: # These defaults are deep-merged into any parameters specified at run-time # during rendering. The latter will take precedence. defaults: locale: en_AU our_abn: 54321123456 contract: term_in_years: 3 # JSON Schema used to validate parameters supplied at run-time. schema: $schema: https://json-schema.org/draft/2020-12/schema title: Parameters validation schema type: object required: - locale - customer_name - customer_abn - contract - price properties: locale: type: string format: locale customer_name: type: string minLength: 1 customer_abn: type: string format: au.ABN contract: type: object price: type: number minimum: 1.00 # This gets Jinja rendered and added as metadata to the output documents. # PDF / HTML conventions for metadata are respected. metadata: title: Contract of Sale subject: '{{ customer_name }}' Document Template Content The documents and overlays keys in the document template configuration file list the files that will be processed and assembled to produce the final PDF document. Two types of file are permitted in these lists: HTML files ( *.html / *.htm ) PDF files ( *.pdf ) (PDF output only). The HTML files may be either files directly constructed by the template author, files that have been imported via the imports key, or HTML that has been compiled from other formats (e.g. Markdown) during the template compilation phase. For compiled files, the original file suffix indicates the content type and hence the process used to compile it to HTML format. The content compiler interface is extensible. New file types can be added easily. HTML Files (*.html, *.htm) When producing standalone HTML outputs, normal HTML conventions should be followed, keeping in mind the limitations of the target rendering environment (e.g. a variety of email clients). When producing PDF outputs, the source HTML used in a docma template should be written explicitly for print, rather than web layout. There are a set of special HTML constructs available when the target media is print. Effective use of these is essential to producing nice output. For an excellent short tutorial on the subject, see Designing For Print With CSS HTML source files are copied unchanged to the compiled docma template during the compilation phase. HTML files can reference other resources in the compiled template (e.g. images, style sheets etc.) using URLs in the format file:filename . For example <IMG src=\"file:resources/logo.png\" alt=\"logo\"> The file: scheme indicator is essential. The filename is relative to the template base directory. Do not use file:// as that implies a network location will follow, which makes no sense for local files. HTML files may contain Jinja markup to manipulate content during the rendering phase . Take care when re-purposing HTML content from other systems that may leave Jinja detritus behind. This may need to be manually deleted first. HTML files can also reference dynamic content generators that will be invoked during the rendering phase . This can be used to include content for charts, QR codes etc. Dynamic content generators are accessed by referencing a URL with the docma scheme. For example, the following will generate and insert a QR code: <IMG src=\"docma:qrcode?{{ { 'text': 'Hello world!', 'fg': 'white', 'bg': '#338888' } | urlencode }}\" > This is the same thing, more cryptically: <IMG src=\"docma:qrcode?text=Hello+world%21&fg=white&bg=%23338888\"> See Dynamic Content Generation for more information. Important points to note: The WeasyPrint package is designed to convert HTML for print to PDF. It does an excellent job, but some constructs take a bit of fiddling to get right. It seems to be more aligned to Safari behaviour than, say, Chrome, if that helps when previewing template components. HTML produced by some WYSIWYG editors can be a tortured, gnarly mess. WeasyPrint may struggle with it. In many cases, it's better to hand-write lean, clean HTML using an IDE or an AI crutch of some kind. PDF Files (*.pdf) PDF output only. PDF files in the template are copied to the compiled template unchanged. They are simply added into the final document composition process as-is. This is useful for boilerplate content, such as contract terms and conditions. PDF files are not Jinja rendered during compilation. Once again, they are used as-is. Markdown Files (*.md) All Markdown files are converted to HTML during the compilation phase. i.e. myfile.md in the template source becomes myfile.html in the compiled template. The HTML variant of the name must be used everywhere in the template when referencing the file. Markdown files may contain Jinja markup to manipulate content during the rendering phase . Conversion from Markdown to HTML is done using the Python markdown package with the following extensions enabled: extras admonition. Important points to note: The conversion from Markdown to HTML will not add <HTML>...<BODY></BODY></HTML> framing around the result. This is an advantage, as it means the content can be included in other documents using Jinja {% include 'myfile.html' %} directives. If a Markdown originated source file is to be used stand-alone, a small HTML wrapper that references the content file may be needed to provide the HTML framing, style sheet etc. The Markdown format is particularly suited to longer, textual content. It is a lot easier to edit and maintain than HTML, but complex styling is more difficult. The Python markdown package has some non-standard extensions that do help with this. Locale in Docma Templates Prior to version 2.2.0, docma had no particular notion of the region or locale with which a particular template, or the documents it produces, is associated. If special formatting was required, it was up to the template designer to handle that manually. This applied for elements such as: phone numbers currencies numbers and percentages dates and times. Version 2.2.0 introduces the concept of locale . A new suite of docma provided Jinja filters use locale information to handle the elements listed above in accordance with locale specific conventions instead of requiring the template designer to handle everything manually. For example: {{ 123456 | decimal }} -- Format using locale specific separators etc. {{ 123456 | AUD }} -- Format however Australian dollars are shown in the current locale See Docma Jinja Rendering for more information. The locale for a template manifests as an additional Jinja rendering parameter, locale , which is expressed in the normal way as a combination of a language indicator and a 2 character ISO country code. e.g. en_AU , en_CA , fr_CA . It can be set in the same way as any other rendering parameter, including any, or all, of the following (from lowest precedence to highest): Including it in the parameters -> defaults in the template configuration file . Specifying it on the command line when rendering a template to PDF or HTML output. Setting it within a template using {% set locale=\"....\" %} . In some jinja filters , specifying locale as an explicit argument to override the current effective value. From version 2.2.0, new templates created using docma new will include a default value in the template configuration file . It's a good idea to add it to earlier templates, thus: # config.yaml parameters: defaults: locale: \"en_AU\" If locale is not specified using one of the mechanisms described above, it will default to whatever random value the underlying platform assumes. Good luck with that.","title":"Document Templates"},{"location":"03-document-templates.html#document-templates","text":"The source directory for a document template should be created using the docma CLI: docma new <DIRECTORY> The resulting directory is structured thus: <DIRECTORY>/ \u251c\u2500\u2500 config.yaml ... Mandatory \u251c\u2500\u2500 charts/ ... Specification files for charts \u251c\u2500\u2500 content/ ... Document content (HTML, PDF, Markdown etc.) \u251c\u2500\u2500 data/ ... Data files (e.g CSV / JSONL files) \u251c\u2500\u2500 fonts/ ... Font files (e.g. .ttf files) \u251c\u2500\u2500 overlays/ ... Overlay content files (Typically HTML or PDF) \u251c\u2500\u2500 queries/ ... Query specifications used for charts \u2514\u2500\u2500 resources/ ... HTML resources (image files etc.) Only the config.yaml file is mandated. While the other components can be present, or not, as required, and directory structure is arbitrary, it is strongly recommended to adhere to the layout shown above. Files and directories in the template source directory matching .* are not copied into the compiled template.","title":"Document Templates"},{"location":"03-document-templates.html#template-configuration-file","text":"The document template configuration file, config.yaml , is critical to the setup and operation of a docma template. The structure of the configuration file is validated during template compilation. It contains the following elements. Key Type Required Description id string Yes Template identifier. This must be at least 3 chars long, start with an alpha, end with an alphanumeric and contain only alpha-numerics and +-_= characters. description string Yes Template description. owner string Yes Template owner. version string Yes Template version. Must be in the form major.minor.patch (e.g. 1.0.0 ). documents list Yes A list of document references to be included in the specified order in the output document. overlays object No Document overlay specifications to enable watermarking / stamping of the output document (PDF only). See Watermarking below. imports list No A list of specifications for external files to include during compilation. See Document Imports below. parameters object No Contains optional keys defaults and schema . -> defaults object No Default values for rendering parameters. -> schema object No A JSON Schema for the rendering parameters. See Docma Parameter Validation . options object No Options passed to the WeasyPrint PDF generator. See WeasyPrint Options . -> stylesheets list No A list of CSS style sheet files that will be fed to the PDF generator. See CSS Style Sheets below. metadata object No Values to be added to the output document metadata. See Document Metadata below. -> author string No Document author. -> title string No Document title. -> subject string No Document subject. -> keywords string | list No A string of semi-colon separated keywords or a list of keywords for the PDF. Prior to docma v2.0, metadata fields were specified in the PDF convention of /Author instead of author . This is still supported for backward compatibility but the naming shown above should now be used. Docma will use the appropriate conventions for PDF and HTML when producing output.","title":"Template Configuration File"},{"location":"03-document-templates.html#document-references","text":"The documents key in the configuration file is a list of component documents that will be rendered and assembled into the final output document. Each element in the document list can be either a string containing the name of a content file or an object containing the following keys: Key Type Required Description src string Yes Name of a content file. if string No A string that will be Jinja rendered with the run-time parameters and evaluated as a truthy value. If the value is true (the default), the document is included. Truthy true values are true / t / y / yes and non-zero integers. Truthy false values are false / f / no / n and zero and empty strings. Content files must be of one of the following types: HTML ( *.html / *.htm ) PDF ( *.pdf ) (for PDF output documents only) Content files can (and generally should) be contained within the template source directory hierarchy. The file is referenced by its path relative to the template source base directory. Content files can also be remote and will be loaded dynamically during the rendering process. This differs from document imports which incorporate the document into the template during template compilation. For remote content files, any of the forms supported by the importer subsystem can be used. e.g. http(s)://host/some/path/... s3://bucket/some/path/... Unlike imports, dynamically referenced content documents must be in HTML or PDF format. There is no compilation of other formats to HTML. It is strongly recommended to include all content files in the template itself (e.g using document imports for remote files). This will be faster and more predictable at run-time as well as improving traceability of documents. For example: documents: - content/cover.html # Our main contract document template - content/contract.html # Boilerplate PDF to include - content/standard-terms.pdf # Reference to a file in S3 - s3://my-content-bucket/extra-terms.pdf # Now a conditional document using evaluated parameters. # The \"if\" condition will evaluate to the string \"True\" or \"False\". - src: content/even-more-terms.pdf if: '{{ contract.term_in_years >= 3 }}' Some of the HTML files may have been compiled from other formats (e.g. Markdown) during the compilation phase. All references to the file during rendering must use the HTML file name. So, for example, a file content/text.md in the template source, will be present as content/text.html in the compiled template. The original, uncompiled files are also replicated into the template to allow later recompilation and for traceability. The uncompiled files are not used in the rendering process. See Document Template Content for more information.","title":"Document References"},{"location":"03-document-templates.html#overlay-documents","text":"PDF outputs only. The overlays key in the configuration file is a list of documents that are prepared in the same way as the primary documents. These are used when the final document requires an overlaid stamp or underlaid watermark. See Watermarking for more information.","title":"Overlay Documents"},{"location":"03-document-templates.html#document-imports","text":"The configuration file may contain an imports key to specify a list of external files that will be included within the compiled template package. The imported file is processed just like a local file, including compilation of supported non-HTML formats (e.g. Markdown) into HTML. Imports are specified as a URL, with the URL scheme determining the means of access. Imports are currently supported for: AWS S3: s3://.... Web content: http(s)://... The content importers interface is extensible. New sources can be added easily. Each import specification is either a string or an object, like so: imports: # Simple string format. This S3 file will be placed in the template based on # the last component of the filename (i.e `myfile.pdf`). - s3://my-bucket/some/path/myfile.pdf # Object format to allow a file to be imported and renamed in the process. # This will copy the file into the template as `content/afile.pdf`. - src: s3://my-bucket/some/path/myfile.pdf as: content/afile.pdf # This Markdown file will be compiled and can be referenced elsewhere in the # template as \"content/mydoc.html\" - src: s3://my-bucket/some/path/somedoc.md as: content/mydoc.md # Import an image - src: http://a.url.com/some/image.png as: resources/image.png # Import a font: - src: http://host/my-corporate-font.ttf as: fonts/my-corporate-font.ttf Imported docs are limited to 10MB in size.","title":"Document Imports"},{"location":"03-document-templates.html#weasyprint-options","text":"PDF outputs only. WeasyPrint is used for converting HTML to PDF for PDF document production. It provides a number of options to control aspects of the PDF production process. These can be specified under the options key of the template configuration file . The following options are set by docma itself. They can be overridden in the template but it's best not to. Option Value set by docma Notes media print optimize_images True This is required to avoid an image loading bug in WeasyPrint.","title":"WeasyPrint Options"},{"location":"03-document-templates.html#css-style-sheets","text":"PDF outputs only. The configuration file may contain an options --> styesheets key that lists files containing style sheets that will be applied to all HTML document files when converting them to PDF. Hence, these files should only contain styles that should be applied everywhere. In some cases, including for HTML outputs, it will be more appropriate to have styles defined within the HTML source document to which they relate, or included from CSS files using the Jinja include directive.","title":"CSS Style Sheets"},{"location":"03-document-templates.html#sample-configuration-file","text":"A sample file might look like this: description: Contract of Sale owner: Cest Moi version: 1.0.0 # List the primary files containing document content. File names are relative to # the root of the template. documents: - content/cover.html # Our main contract document template - content/contract.html # Boilerplate PDF to include - content/standard-terms.pdf # Now a conditional document using evaluated parameters. # The \"if\" condition will evaluate to the string \"True\" or \"False\". - src: content/extra-terms.pdf if: '{{ contract.term_in_years >= 3 }}' # Bring these files into the package when building the template. imports: - src: s3://my-bucket/common-files/standard-terms.pdf as: content/standard-terms.pdf # Used in the HTML to PDF conversion options: stylesheets: - styles.css parameters: # These defaults are deep-merged into any parameters specified at run-time # during rendering. The latter will take precedence. defaults: locale: en_AU our_abn: 54321123456 contract: term_in_years: 3 # JSON Schema used to validate parameters supplied at run-time. schema: $schema: https://json-schema.org/draft/2020-12/schema title: Parameters validation schema type: object required: - locale - customer_name - customer_abn - contract - price properties: locale: type: string format: locale customer_name: type: string minLength: 1 customer_abn: type: string format: au.ABN contract: type: object price: type: number minimum: 1.00 # This gets Jinja rendered and added as metadata to the output documents. # PDF / HTML conventions for metadata are respected. metadata: title: Contract of Sale subject: '{{ customer_name }}'","title":"Sample Configuration File"},{"location":"03-document-templates.html#document-template-content","text":"The documents and overlays keys in the document template configuration file list the files that will be processed and assembled to produce the final PDF document. Two types of file are permitted in these lists: HTML files ( *.html / *.htm ) PDF files ( *.pdf ) (PDF output only). The HTML files may be either files directly constructed by the template author, files that have been imported via the imports key, or HTML that has been compiled from other formats (e.g. Markdown) during the template compilation phase. For compiled files, the original file suffix indicates the content type and hence the process used to compile it to HTML format. The content compiler interface is extensible. New file types can be added easily.","title":"Document Template Content"},{"location":"03-document-templates.html#html-files-html-htm","text":"When producing standalone HTML outputs, normal HTML conventions should be followed, keeping in mind the limitations of the target rendering environment (e.g. a variety of email clients). When producing PDF outputs, the source HTML used in a docma template should be written explicitly for print, rather than web layout. There are a set of special HTML constructs available when the target media is print. Effective use of these is essential to producing nice output. For an excellent short tutorial on the subject, see Designing For Print With CSS HTML source files are copied unchanged to the compiled docma template during the compilation phase. HTML files can reference other resources in the compiled template (e.g. images, style sheets etc.) using URLs in the format file:filename . For example <IMG src=\"file:resources/logo.png\" alt=\"logo\"> The file: scheme indicator is essential. The filename is relative to the template base directory. Do not use file:// as that implies a network location will follow, which makes no sense for local files. HTML files may contain Jinja markup to manipulate content during the rendering phase . Take care when re-purposing HTML content from other systems that may leave Jinja detritus behind. This may need to be manually deleted first. HTML files can also reference dynamic content generators that will be invoked during the rendering phase . This can be used to include content for charts, QR codes etc. Dynamic content generators are accessed by referencing a URL with the docma scheme. For example, the following will generate and insert a QR code: <IMG src=\"docma:qrcode?{{ { 'text': 'Hello world!', 'fg': 'white', 'bg': '#338888' } | urlencode }}\" > This is the same thing, more cryptically: <IMG src=\"docma:qrcode?text=Hello+world%21&fg=white&bg=%23338888\"> See Dynamic Content Generation for more information. Important points to note: The WeasyPrint package is designed to convert HTML for print to PDF. It does an excellent job, but some constructs take a bit of fiddling to get right. It seems to be more aligned to Safari behaviour than, say, Chrome, if that helps when previewing template components. HTML produced by some WYSIWYG editors can be a tortured, gnarly mess. WeasyPrint may struggle with it. In many cases, it's better to hand-write lean, clean HTML using an IDE or an AI crutch of some kind.","title":"HTML Files (*.html, *.htm)"},{"location":"03-document-templates.html#pdf-files-pdf","text":"PDF output only. PDF files in the template are copied to the compiled template unchanged. They are simply added into the final document composition process as-is. This is useful for boilerplate content, such as contract terms and conditions. PDF files are not Jinja rendered during compilation. Once again, they are used as-is.","title":"PDF Files (*.pdf)"},{"location":"03-document-templates.html#markdown-files-md","text":"All Markdown files are converted to HTML during the compilation phase. i.e. myfile.md in the template source becomes myfile.html in the compiled template. The HTML variant of the name must be used everywhere in the template when referencing the file. Markdown files may contain Jinja markup to manipulate content during the rendering phase . Conversion from Markdown to HTML is done using the Python markdown package with the following extensions enabled: extras admonition. Important points to note: The conversion from Markdown to HTML will not add <HTML>...<BODY></BODY></HTML> framing around the result. This is an advantage, as it means the content can be included in other documents using Jinja {% include 'myfile.html' %} directives. If a Markdown originated source file is to be used stand-alone, a small HTML wrapper that references the content file may be needed to provide the HTML framing, style sheet etc. The Markdown format is particularly suited to longer, textual content. It is a lot easier to edit and maintain than HTML, but complex styling is more difficult. The Python markdown package has some non-standard extensions that do help with this.","title":"Markdown Files (*.md)"},{"location":"03-document-templates.html#locale-in-docma-templates","text":"Prior to version 2.2.0, docma had no particular notion of the region or locale with which a particular template, or the documents it produces, is associated. If special formatting was required, it was up to the template designer to handle that manually. This applied for elements such as: phone numbers currencies numbers and percentages dates and times. Version 2.2.0 introduces the concept of locale . A new suite of docma provided Jinja filters use locale information to handle the elements listed above in accordance with locale specific conventions instead of requiring the template designer to handle everything manually. For example: {{ 123456 | decimal }} -- Format using locale specific separators etc. {{ 123456 | AUD }} -- Format however Australian dollars are shown in the current locale See Docma Jinja Rendering for more information. The locale for a template manifests as an additional Jinja rendering parameter, locale , which is expressed in the normal way as a combination of a language indicator and a 2 character ISO country code. e.g. en_AU , en_CA , fr_CA . It can be set in the same way as any other rendering parameter, including any, or all, of the following (from lowest precedence to highest): Including it in the parameters -> defaults in the template configuration file . Specifying it on the command line when rendering a template to PDF or HTML output. Setting it within a template using {% set locale=\"....\" %} . In some jinja filters , specifying locale as an explicit argument to override the current effective value. From version 2.2.0, new templates created using docma new will include a default value in the template configuration file . It's a good idea to add it to earlier templates, thus: # config.yaml parameters: defaults: locale: \"en_AU\" If locale is not specified using one of the mechanisms described above, it will default to whatever random value the underlying platform assumes. Good luck with that.","title":"Locale in Docma Templates"},{"location":"04-docma-template-compilation.html","text":"Docma Template Compilation The compilation process is a build-time activity consisting of the following steps: Validate the template configuration file . Copy files from the template source to the template staging area, compiling any compilable files (e.g Markdown) to HTML in the process. Import any files specified in the imports key of the configuration file , compile as required and copy them to the template staging area. Zip up the contents of the template staging area to produce the compiled document template. The docma CLI also supports the option of saving the compiled template, uncompressed, into a local directory. This is primarily for development and testing. There is (approximately) a one-to-one correspondence between files in the source directory and the compiled template. Directory structure is preserved.","title":"Docma Template Compilation"},{"location":"04-docma-template-compilation.html#docma-template-compilation","text":"The compilation process is a build-time activity consisting of the following steps: Validate the template configuration file . Copy files from the template source to the template staging area, compiling any compilable files (e.g Markdown) to HTML in the process. Import any files specified in the imports key of the configuration file , compile as required and copy them to the template staging area. Zip up the contents of the template staging area to produce the compiled document template. The docma CLI also supports the option of saving the compiled template, uncompressed, into a local directory. This is primarily for development and testing. There is (approximately) a one-to-one correspondence between files in the source directory and the compiled template. Directory structure is preserved.","title":"Docma Template Compilation"},{"location":"05-docma-template-rendering.html","text":"Docma Template Rendering The document rendering phase combines a compiled docma template with run-time specified parameters and dynamically generated content to produce a final output document. The rendering process is slightly different for PDF and HTML outputs. Rendering for PDF Outputs The main steps in the process for PDF production are: Marshal the rendering parameters . Validate the rendering parameters . Collect the list of documents to be incorporated into the final output PDF. Render HTML documents in the component list using Jinja to inject the rendering parameters . Convert the HTML documents to PDF using WeasyPrint . This process will also generate any dynamic content from specifications embedded in the source HTML. Assemble all of the components (generated PDFs and any listed static PDFs) into a single PDF document. Add any requested watermarking or stamping to the document. Jinja render any required metadata specified in the template configuration file and add it to the PDF. Optionally, compress the PDF using lossless compression. Depending on the PDF contents, compression may, or may not, help. Rendering for HTML Outputs The main steps in the process for HTML production are: Marshal the rendering parameters . Validate the rendering parameters . Collect the list of documents to be incorporated into the final output HTML. Render HTML documents in the component list using Jinja to inject the rendering parameters . Process <IMG> tags in the HTML to generate and embed any dynamic content from specifications embedded in the source HTML. Static images may also be embedded. Assemble all of the component HTML documents into a single HTML document. Jinja render any required metadata specified in the template configuration file and add it to the HTML. Docma Parameter Validation Docma supports the use of JSON Schema to validate rendering parameters at run-time. Parameters are validated against a schema provided in the parameters->schema key in the template configuration file prior to generating the output document. Failing validation will halt the production process. Provision, and hence use, of a parameter validation schema is optional, but highly recommended to reduce the risk of generating an important document incorrectly or with nonsensical values. All of the normal facilities of JSON Schema are available, except for external schema referencing with $ref directives. Like the JSON Schema built-in string formats , docma provided format checkers can be used in a schema specification with the format attribute of string objects The following sample schema fragment shows how these are used: type: object properties: customer_email: type: string format: email # This is a JSON schema built-in format checker customer_abn: type: string format: au.ABN # This is a docma provided format checker target_consumption: type: number minimum: 0 consumption_unit: type: string format: energy_unit # This is a docma provided format checker start_date: type: string format: date.dmy # This is a docma provided format checker See also Format Checkers Provided by Docma . Docma Jinja Rendering The rendering phase uses Jinja to render HTML content with the parameters provided at run-time. Other components (e.g. query specifications ) also use Jinja rendering on some of their content. The docma Jinja subsystem has been refactored somewhat in v2.2.0. All of the facilities provided by Jinja are available, including parameter injection, loops, conditional content and use of the include directive to incorporate other content from the document template. Include directives should use the name of the file relative to the template root. e.g. {% include 'my-file.html' %} See also Jinja Rendering Parameters Provided by Docma . In addition to standard Jinja facilities, docma also provides a number of extra filters and extensions . Rendering Parameters The parameters used by docma during the template rendering process is the union of the following (from highest to lowest precedence): Parameters provided by docma . Parameters supplied by the user at run-time. Parameters specified under parameters->defaults in the template configuration file Parameters are any object that can be represented in JSON / standard YAML, which can include arbitrary combinations of objects, lists and scalar values. The marshalling process deep-merges the parameter trees from each source. Lists are not merged. One list will replace another if they occur at the same location. Jinja Rendering Parameters Provided by Docma In addition to user supplied parameters, docma includes the following items under the docma key. Key Notes Description calendar The Python calendar module. data Function to invoke a docma data provider and return the data as a list of dictionaries. See Data Source Specifications for HTML Rendering . datetime The Python datetime module. format The format of the output document to be produced, PDF or HTML . This can be used, among other things, for format specific content or formatting (e.g. CSS variations). paramstyle (1) Corresponds to the DBAPI 2.0 paramstyle attribute of the underlying database driver when processing a query specification . template An object containing information about the document template. --> description The description field from the template configuration file . --> doc_no (2) The document number in the list being included in the final document, starting at 1. --> document (2) The path for the source document being processed. This is a pathlib Path() instance. --> id The id field from the template configuration file . --> overlay_id (3) The ID of the current overlay set being rendered. --> overlay_path (3) The path for the current overlay file being rendered. This is a pathlib Path() instance. --> page (2) The starting page number for the current document with respect to the final output document. This may be useful for manipulating page numbering in multipart documents. Or not. --> version The version field from the template configuration file . version The docma version. Notes: The paramstyle parameter is only available for use in query specifications . The template.doc_no , template.document and template.page parameters are only available when a document file is being rendered (i.e. not when an overlay is being rendered). The template.page parameter is only available for PDF outputs. The template.overlay_id and template.overlay_path parameters are only available when an overlay file is being rendered. For example, to insert today's date: {{ docma.datetime.date.today() | date }} -- The \"date\" filter will format for the locale To check whether we are producing HTML or PDF: We are producing {{ docma.format }} output using docma version {{ docma.version }}. Custom Jinja Filters Provided by Docma Jinja filter management has changed significantly in docma 2.2. Some filters have been renamed (with backward compatible aliases) and a new, more extensible filter plugin system has been implemented. In addition to the standard filters provided by Jinja, docma provides a number of additions. These are divided into: Generic filters Region / country specific filters . Note that custom filter names are case insensitive. Generic Filters Filters marked with * are locale aware. Filter Name Description compact_decimal * Format a number in a compact format. css_id Sanitise a string to be a valid CSS identifier. currency * Format currency. date * Format a date. datetime * Format a datetime. decimal * Format a number. dollars Legacy. Format currency a value as dollars. parse_date * Parse a date string into a datetime.date instance. parse_time * Parse a date string into a datetime.time instance. percent * Format a percentage. phone * Format a phone number. require Abort with an error message an expression does not have a truthy value. sql_safe Ensure that a string value is safe to use in SQL and generate an error if not. time * Format a time value. timedelta * Format a timedelta value. Region Specific Filters Filter Name Description abn Deprecated. Use au.abn . acn Deprecated. Use au.abn . au.abn Format an Australian Business Number (ABN). au.acn Format an Australian Company Number (ACN). Jinja Filter: au.abn Format an Australian Business Number (ABN). This supersedes the, now deprecated, abn filter. {{ '51824753556' | au.abn }} --> 51 824 753 556 Jinja Filter: au.acn Format an Australian Company Number (ACN). This supersedes the, now deprecated, acn filter. {{ '123456789' | au.acn }} --> 123 456 789 Jinja Filter: compact_decimal Format numeric values. This is a locale-aware filter that provides an interface to the Babel format_compact_decimal() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: compact_decimal( value: str | int | float, *args, rounding: str = 'half-up', default: int | float | str | None = None, **kwargs ) Parameter Description value Filter input value. Numbers and strings containing numbers are accepted. *args Passed to Babel's format_compact_decimal() . rounding How to round the value. This must be one of the rounding modes in Babel's decimal.ROUND_* , with the ROUND_ prefix removed. Case is ignored and hyphens become underscores. Defaults to half-up (Excel style rounding), instead of half-even (Bankers rounding) which is Python's normal default. default The default value to use for the filter if the input value is empty (i.e. None or an empty string). If the input value is empty and default is a string, it is used as-is as the return value of the filter. If the input value is empty, and default is not specified, an error is raised. Otherwise, the default is assumed to be numeric and is used as the input to the filter. Note: The default parameter does something different to the Jinja standard default filter. They are both useful but not interchangeable. **kwargs Passed to Babel's format_compact_decimal() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {{ 1234.5678 | compact_decimal }} --> 1K {{ '1234.5678' | compact_decimal }} --> 1K Locale can be specified explicitly, if required: {{ 1234.5678 | compact decimal(locale='fr_FR') }} --> 1 k Jinja Filter: css_id Sanitise a string to be a valid CSS identifier. {{ 'a/()=*&bcd'' | css_id }} --> abcd Jinja Filter: currency Format a currency value. This is a locale-aware filter that provides an interface to the Babel format_currency() API. It is important to understand that there are two orthogonal aspects to formatting currency values: The currency involved, such as Australian dollars (AUD), Euros (EUR) etc. The locale in which the currency is to be presented. For example: One Australian dollar would appear in Australia as $1.00 . One Australian dollar would appear in the US as A$1.00 One Australian dollar would appear in France as 1,00 AU$ For the docma filter, the currency (AUD in the example above) can be specified in one of two ways: By providing an argument to the currency filter {{ 1 | currency('AUD') }} ; or Using the currency name itself as an alias for the filter name {{ 1 | AUD }} . Docma dynamically generates a filter alias for known currencies. Case is not significant. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: currency( value: str | int | float, currency: str, *args, rounding: str = 'half-up', default: int | float | str | None = None, **kwargs ) # ... or .... <CURRENCY_CODE>( value: str | int | float, *args, rounding: str = 'half-up', default: int | float | str | None = None, **kwargs ) Parameter Description value Filter input value. Numbers and strings containing numbers are accepted. Jinja will inject this automatically. currency The currency code (e.g AUD , EUR etc.) *args Passed to Babel's format_currency() . rounding How to round the value. This must be one of the rounding modes in Babel's decimal.ROUND_* , with the ROUND_ prefix removed. Case is ignored and hyphens become underscores. Defaults to half-up (Excel style rounding), instead of half-even (Bankers rounding) which is Python's normal default. default The default value to use for the filter if the input value is empty (i.e. None or an empty string but not zero). If the input value is empty and default is a string, it is used as-is as the return value of the filter. If the input value is empty, and default is not specified, an error is raised. Otherwise, the default is assumed to be numeric and is used as the input to the filter. Note: The default parameter does something different to the Jinja standard default filter. They are both useful but not interchangeable. **kwargs Passed to Babel's format_decimal() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {{ 123 | AUD }} --> $123.00 {{ 123 | currency('AUD') }} --> $123.00 {{ '123' | NZD }} --> NZD123.00 (numeric strings are fine as input) {{ None | AUD }} --> ERROR! {{ None | AUD(default=0) }} --> $0.00 {{ None | AUD(default='FREE!')}} --> FREE! {{ -123 | AUD(format=\"\u00a4#,###;(\u00a4#)\", currency_digits=False)}} --> ($123) Locale can be specified explicitly, if required: {{ 123 | EUR(locale='en_GB') }} --> \u20ac123.00 {{ 123 | EUR(locale='fr_FR' }} --> 123,00 \u20ac The legacy dollars filter can be replicated like so (use whatever dollar currency is appropriate): {{ 1234.5 | dollars }} --> {{ 1234.5 | AUD }} --> $1,234.50 {{ 1234.5 | dollars(0) }} --> {{ AUD(format=\"\u00a4#,###\", currency_digits=False) }} --> $1,235 Jinja Filter: date Format date values. This is a locale-aware filter that provides an interface to the Babel format_date() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: date(value: datetime.date | datetime.datetime, *args, **kwargs) Parameter Description value Filter input value. This must be a datetime.date or datetime.datetime instance. *args Passed to Babel's format_date() . **kwargs Passed to Babel's format_date() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {% set value = docma.datetime.date(2025, 9, 17) %} {{ value | date }} --> 17 Sept 2025 (medium format is the default) {{ value | date(format='short') }} --> 17/9/25 {{ value | date(format='long') }} --> 17 September 2025 {{ value | date(format='full') }} --> Wednesday, 17 September 2025 {{ value | date(format='dd/MM/yyyy')}} --> 17/09/2025 Locale can be specified explicitly, if required: {{ value | datetime(locale='en_US') }} --> Sep 17, 2025 If date strings need to be handled, they will need to be converted to a Python datetime.date instance first. For date strings guaranteed to be in ISO 8601 format, Python's standard datetime.date.fromisoformat() is fine. Otherwise, the safest way to do this for dates containing only numbers (no month names) is to use the parse_date filter as this is (docma) locale aware, unlike the Python standard datetime.datetime.strptime(). {{ docma.datetime.date.fromisoformat('2025-09-1') | date }} --> 1 Sept 2025 {{ '1/9/2025' | parse_date | date }} --> 1 Sept 2025 {{ '1/9/2025' | parse_date(locale='en_US') | date }} --> 9 Jan 2025 Here be dragons: There is no fully reliable way to parse dates containing month names in a generic, locale-aware away. Don't be tempted to attempt this in a docma template. If you think you need to, you are either solving the problem the wrong way or solving the wrong problem. Jinja Filter: datetime Format datetime values. This is a locale-aware filter that provides an interface to the Babel format_datetime() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: datetime(value: datetime.date | datetime.datetime | datetime.time, *args, **kwargs) Parameter Description value Filter input value. Typically, this would be a datetime.datetime instance. While datetime.date and datetime.time instances are also accepted, they are unlikely to be particularly useful. *args Passed to Babel's format_datetime() . **kwargs Passed to Babel's format_datetime() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {% set value = docma.datetime.datetime(2025, 9, 17, 14, 15, 16) %} {{ value | datetime }} --> 17 Sept 2025, 2:15:16 pm Locale can be specified explicitly, if required: {{ value | datetime(locale='en_US') }} --> Sep 17, 2025, 2:15:16 PM If datetime strings need to be handled, they will need to be converted to a Python datetime.datetime instance first. For datetime strings guaranteed to be in ISO 8601 format, Python's standard datetime.datetime.fromisoformat() is fine. {{ docma.datetime.datetime.fromisoformat('2025-09-17T14:15:16') | datetime }} Avoid using the Python standard datetime.datetime strptime() if at all possible. This will use the platform locale and cannot handle the docma locale. The results can be very unpredictable. Jinja Filter: decimal Format numeric values. This is a locale-aware filter that provides an interface to the Babel format_decimal() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be explicitly specified by adding a locale argument to the filter. The filter signature is: decimal( value: str | int | float, *args, rounding: str = 'half-up', default: int | float | str | None = None, **kwargs ) Parameter Description value Filter input value. Numbers and strings containing numbers are accepted. *args Passed to Babel's format_decimal() . rounding How to round the value. This must be one of the rounding modes in Babel's decimal.ROUND_* , with the ROUND_ prefix removed. Case is ignored and hyphens become underscores. Defaults to half-up (Excel style rounding), instead of half-even (Bankers rounding) which is Python's normal default. default The default value to use for the filter if the input value is empty (i.e. None or an empty string, but not zero). If the input value is empty and default is a string, it is used as-is as the return value of the filter. If the input value is empty, and default is not specified, an error is raised. Otherwise, the default is assumed to be numeric and is used as the input to the filter. Note: The default parameter does something different to the Jinja standard default filter. They are both useful but not interchangeable. **kwargs Passed to Babel's format_decimal() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {{ 1234.5678 | decimal }} --> 1,234.568 (Default is to round to 3 decimal places) {{ '1234.5678' | decimal }} --> 1,234.568 (numeric strings are fine as input) {{ None | decimal }} --> ERROR! {{ None | decimal(default=0) }} --> 0 {{ None | decimal(default='nix')}} \u2192 nix Locale can be specified explicitly, if required: {{ 1234.5678 | decimal(locale='fr_FR') }} --> 1 234,568 Jinja Filter: dollars Round and format a currency value as dollars. Banker's half-up, rounding is used (like Excel) instead of the half-even rounding that is Python's normal default. This filter is a legacy that is not actually deprecated (yet), but its use is discouraged. Use the currency filter in preference. The filter signature is: dollars(value: str | int | float, precision: int = 2, symbol: str = '$') Parameter Description value A number or numeric string. precision Number of decimal places to show. Defaults to 2. symbol The currency symbol to show. Defaults to $ . Examples: {{ 1234.50 | dollars }} --> $1,234.50 {{ 1234.50 | dollars(0) }} --> $1,235 Jinja Filter: parse_date Parse a date string into a datetime.date instance. This is a locale-aware filter that provides an interface to the Babel parse_date() API. The filter signature is: parse_date(value: str, *args, **kwargs) -> datetime.date Parameter Description value Filter input value. The parser understands component ordering variations by locale but cannot handle month names. Numbers only. *args Passed to Babel's parse_date() . **kwargs Passed to Babel's parse_date() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {{ '1/9/2025' | parse_date) }} --> datetime.date(2025, 9, 1) Locale can be specified explicitly, if required: {{ '1/9/2025' | parse_date(locale='en_US') }} --> datetime.date(2025, 1, 9) Jinja Filter: parse_time Parse a date string into a datetime.time instance. This is a locale-aware filter that provides an interface to the Babel parse_time() API. The filter signature is: parse_time(value: str, *args, **kwargs) -> datetime.time Parameter Description value Filter input value. *args Passed to Babel's parse_time() . **kwargs Passed to Babel's parse_time() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {{ '2:15 pm' | parse_time) }} --> datetime.time(14, 15) Locale can be specified explicitly, if required: {{ '1/9/2025' | parse_date(locale='en_US') }} --> datetime.date(2025, 1, 9) Jinja Filter: percent Format percentage values. This is a locale-aware filter that provides an interface to the Babel format_percent() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: percent( value: str | int | float, *args, rounding: str = 'half-up', default: int | float | str | None = None, **kwargs ) Parameter Description value Filter input value. Numbers and strings containing numbers are accepted. *args Passed to Babel's format_percent() . rounding How to round the value. This must be one of the rounding modes in Babel's decimal.ROUND_* , with the ROUND_ prefix removed. Case is ignored and hyphens become underscores. Defaults to half-up (Excel style rounding), instead of half-even (Bankers rounding) which is Python's normal default. default The default value to use for the filter if the input value is empty (i.e. None or an empty string). If the input value is empty and default is a string, it is used as-is as the return value of the filter. If the input value is empty, and default is not specified, an error is raised. Otherwise, the default is assumed to be numeric and is used as the input to the filter. Note: The default parameter does something different to the Jinja standard default filter. They are both useful but not interchangeable. **kwargs Passed to Babel's format_percent() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {{ 0.1234 | percent }} --> 12% {{ '0.1234' | percent }} --> 12% {{ None | percent }} --> ERROR! {{ None | percent(default=0) }} --> 0% {{ None | percent(default='--')}} --> -- Locale can be specified explicitly, if required: {{ '0.123' | percent(locale='fr_FR') }} --> 12 % Jinja Filter: phone Format phone numbers. If a number cannot be formatted, the unmodified input is returned. This is a locale-aware filter. The underlying process is implemented using the excellent Python phonenumbers package, which is itself a port of Google's libphonenumber library . Phone number formatting varies substantially internationally. Hence, the filter needs to determine the relevant region for each phone number. It can do that in one of 3 ways (highest precedence to lowest) An international code in the source phone number. An explicit region code argument to the phone filter (expressed as a two-character ISO country code). By assuming the phone number is associated with the effective locale setting For example, a locale setting of en_AU would imply the number is part of the Australian phone numbering plan. The filter signature is: phone(number: str, region: str = None, *, format: str = None) Parameter Description number The phone number input to the filter. Phone numbers are always strings, never integers. Ever. region The region to which the phone number belongs as a 2 character ISO country code. Ignored if the phone number includes an international code. If not specified, the country code from the current effective locale is used. format See below. Phone numbers can be formatted in different ways. The following values of the format parameter are supported: Format Description E164 E.164 is the standard International Telecommunication Union (ITU) format for worldwide telephone numbers. e.g. +61491570006 INTERNATIONAL The full international phone number, formatted as per national conventions. e.g. +61 491 570 006 NATIONAL The national number component of the phone number without the international code component, formatted as per national conventions. e.g. 0491 570 006 RFC3966 The URI format for phone numbers. This will typically generate one-touch call links in on-line content. e.g. tel:+61-491-570-006 If not specified, NATIONAL is used if the region for the phone number matches that for the current locale and INTERNATIONAL otherwise. Examples (assuming locale is set to en_AU ): {{ '0491 570 006' | phone }} --> 0491 570 006 (Locale will provide \"AU\" as region) {{ '+61 491 570 006' | phone }} --> 0491 570 006 (Region comes from the number) {{ '4155550132' | phone('US') }} --> +1 415-555-0132 {{ '4155550132'| phone('US', format='NATIONAL') }} --> (415) 555-0132 {{ '4155550132'| phone('US', format='RFC3966') }} --> tel:+1-415-555-0132 {{ 'bad-to-the-phone' }} --> bad-to-the-phone (If all else fails, return the input) Jinja Filter: require Abort with an error message if the value is not a truthy value (i.e. a non-empty string, non-zero integer etc), otherwise return the value. This is useful for situations where it is better to abort if an expression is expected to have a value, but doesn't, rather than make assumptions. Dear Bob, Your flight details have changed and your flight will now depart at {{ flight_time | require('flight_time must be a non-empty string') }}. Don't be late. Jinja Filter: sql_safe Ensure that a string value is safe to use in SQL and generate an error if not. This is primarily for use in query specifications to avoid SQL injection. It has a puritanical view on safety but will cover most normal requirements. Examples: SELECT * from {{ table | sql_safe }} ... Jinja Filter: time Format time values. This is a locale-aware filter that provides an interface to the Babel format_time() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: time(value: datetime.time | datetime.datetime, *args, **kwargs) Parameter Description value Filter input value. This must be a datetime.time or datetime.datetime instance. *args Passed to Babel's format_time() . **kwargs Passed to Babel's format_time() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {% set value = docma.datetime.time(14, 15) %} {{ value | time }} --> 2:15:00 pm Locale can be specified explicitly, if required: {{ value | datetime(locale='de_DE') }} --> 14:15:00 If time strings need to be handled, they will need to be converted to a Python datetime.time instance first. The safest way to do this is to use the parse_time filter as this is (docma) locale aware. {{ '14:15' | parse_time | time }} --> 2:15:00 pm {{ '2:15 pm' | parse_time | time }} --> 2:15:00 pm Jinja Filter: timedelta Format timedelta values. This is a locale-aware filter that provides an interface to the Babel format_timedelta() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: timedelta(value: datetime.timedelta | datetime.datetime | datetime.time, *args, **kwargs) Parameter Description value Filter input value. This must be a datetime.timedelta instance. *args Passed to Babel's format_timedelta() . **kwargs Passed to Babel's format_timedelta() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {% set d1 = docma.datetime.datetime(2025, 9, 17, 14, 15, 16) %} {% set d2 = docma.datetime.datetime(2025, 9, 19, 14, 15, 16) %} {{ (d2 - d1) | timedelta }} --> 2 days (default format is 'long') {{ (d2 - d1) | timedelta(format='narrow') }} --> 2d {{ (d2 - d1) | timedelta(add_direction=True) }} --> in 2 days Locale can be specified explicitly, if required: {{ (d2 - d1) | timedelta(locale='uk_UA') }} --> '2 \u0434\u043d\u0456' The Babel format_timedelta() rounding process is not particularly intuitive on first appearance but makes sense once you get the hang of it. You may need to experiment with threshold and granularity arguments to get the desired effect. Custom Jinja Extensions Provided by Docma Docma provides some custom Jinja extensions. In Jinja, extensions are invoked using the following syntax: {% tag [parameters] %} In addition to the custom extensions described below, docma also provides the following standard Jinja extensions: debug loopcontrols . Jinja Extension: abort The abort extension forces the rendering process to abort with an exception message. It would typically be used in response to some failed correctness check where it's preferable to fail document production rather than to proceed in error. For example: {% if bad_data %} {% abort 'Fatal error - bad data' %} {% endif %} Jinja Extension: dump_params The dump_params extension simply dumps the rendering parameters for debugging purposes. The standard Jinja debug extension does something similar (and a bit more) but much less readably. Typical usage would be: <PRE>{% dump_params %}</PRE> Jinja Extension: global The global extension allows values defined within the Jinja content of a HTML document to be made available when rendering other components in a document template. For example, the following declares the globals a and b . {% global a=1, b='Plugh' %} These can then be accessed, either in the file in which they were declared or in a different HTML document, or a query specification like so: You are at Y{{ globals.a + 1 }}. A hollow voice says \"{{ globals.b }}.\" The result will be: Your are at Y2. A hollow voice says \"Plugh\". Compare this with the standard Jinja set operation: {% set a=1 %} The variable a can only be accessed in the file in which it is defined, or a file that includes that file. It cannot be accessed in a different HTML document, or a query specification Warning : It is important to understand that within the docma rendering phase, the Jinja rendering of the component HTML documents is completed before the generation and injection of dynamic content . This means that only the final value of any global parameter is available during the dynamic content generation phase. i.e. It is not possible to use globals to pass a loop variable from the Jinja rendering of the HTML into the dynamic content generation phase. Format Checkers Provided by Docma Docma includes an extensible set of format checkers. These can be used in two ways: In JSON schema specifications as format specifiers for string data elements; and As Jinja tests in content that will be Jinja rendered. The docma provided format checkers are divided into: Generic checkers Region / country specific checkers . All docma provided format checker names are case insensitive. It is easy to add new format checkers , as required. Generic Format Checkers Test Name Description date.dmy Date formatted as day/month/year. The separators can be any of /-_. or missing (e.g. 31/12/2024 , 31.12.2024 , 31-12-2024 , 31_12_2024 , 31122024 ). date.mdy Date formatted as month/day/year. The separators can be any of /-_. or missing (e.g. 12/31/2024 , ...). date.ymd Date formatted as year/month/day. The separators can be any of /-_. or missing (e.g. 2024/12/31 , ...). DD/MM/YYYY JSON Schema use only . Deprecated. Use date.dmy instead. energy_unit An energy unit (e.g. kWh, MVArh). locale A locale specifier (e.g. en_AU , fr_FR ) power_unit A power unit (e.g. kW, MVA). semantic_version A version in the form major.minor.patch (e.g. 1.3.0 ). Region Specific Format Checkers Checker Name Description ACN Deprecated. Use au.abn instead. ABN Deprecated. Use au.abn instead. au.ABN Australian Business Number. au.ACN Australian Company Number. au.MIRN Australian energy industry Gas Meter Installation Registration Number. au.NMI Australian energy industry National Metering Identifier. MIRN Deprecated. Use au.MIRN instead. NMI Deprecated. Use au.NMI instead. Using Format Checkers in JSON Schema Specifications JSON Schema specifications are supported, and strongly recommended, in a number of docma components, such as as the template configuration file , and query specifications . They provide run-time type checking of important data elements and are an important safety mechanism. Like the JSON Schema built-in string formats , docma provided format checkers can be used in a schema specification with the format attribute of string objects, like so: type: object properies: prop1: type: string format: ... # Use a built in format like \"email\" or one of docma's format checkers Examples are given in YAML rather than JSON for readability, and because they are specified in YAML in docma. For example, consider a document template for a contract that requires parameters for customer email, contract start date, and customer Australian Business Number (ABN) to be specified: The relevant portion of the template configuration file might look like this: parameters: schema: $schema: https://json-schema.org/draft/2020-12/schema # Schema for the schema! title: Parameters validation schema type: object required: - locale - customer_email - customer_abn - contract_start_date properties: locale: type: string format: locale # This is a docma provided format checker customer_email: type: string format: email # This is a standard JSON schema format checker customer_abn: type: string format: au.ABN # This is a docma provided format checker. contract_start_date: type: string format: date.dmy # This is a docma provided format checker Docma will validate values provided at run-time against this schema. Using Format Checkers in Jinja In addition to the standard tests provided by Jinja , the docma format checkers can also be used as Jinja tests, like so: {% if contract_date is not date.dmy %} {% abort 'Bad date' %} {% endif %} When used as Jinja tests, none of the docma format checkers accept an arguments additional to the value being checked. Docma can also be extended with Jinja tests that can accept additional arguments, but these would not also be used in JSON Schema specifications and hence would not be considered to be format checkers. Dynamic Content Generation When docma converts HTML into PDF or stand-alone HTML, it needs to resolve all URLs in the source HTML in things such as <img src=\"...\"> tags. It does this via a custom URL fetcher that allows content requests to be intercepted and the resulting content generated dynamically. In this way, docma can generate dynamic content, such as charts, for inclusion in the final output document. There are some differences in this process depending on whether the final output is PDF of HTML. See Dynamic Content Generation Differences Between PDF and HTML Output . All URLs are constituted thus: scheme://netloc/path;parameters?query#fragment Docma determines which custom URL fetcher to apply based on the URL scheme (i.e. the first part before the colon). The URL fetchers handle a range of non-standard, docma specific schemes, as well as the standard http and https schemes. Docma currently handles the following non-standard schemes: Scheme Description docma Interface to docma dynamic content generators of various types. file Interface to access files contained within the compiled document template. s3 Interface to access files from AWS S3. The docma URL fetcher interface is easily expandable to handle other schemes. See URL Fetchers . Dynamic Content Generation Differences Between PDF and HTML Output PDF generation from HTML is performed by WeasyPrint, which will invoke a custom URL fetcher for any URL it needs to access during the conversion process. This includes, but is not limited to , <IMG> tags. For standalone HTML output, the process of invoking a custom URL fetcher is done by docma itself. It is only applied to the src attribute of <IMG> tags under specific circumstances. When it is done, the src attribute is replaced in the <IMG> tag with the actual content returned by the URL fetcher. i.e. the data is embedded within the standalone HTML output. In practice, these differences work naturally, relative to the final viewing environment for the produced document, static PDF or dynamic HTML. By default, in HTML outputs, <IMG> tags have the content embedded in place of the src attribute in the following circumstances: The src URL is not http(s):// (i.e. any of the docma custom schemes described below); or The src URL is http(s):// , has no query component ?... , and the content size is between 100 bytes and 1MB in size. For the http(s):// URLs, it is possible to override the default behaviour by adding the data-docma-embed attribute to the <IMG> tag. For images that are not embedded, it is assumed that the client (e.g. an email client or web browser) will fetch the images as required at display time. <!-- Force the image to be embedded --> <IMG src=\"http://host/img.png\" data-docma-embed=\"true\"> <!-- Prevent the image from being embedded --> <IMG src=\"http://host/img.png\" data-docma-embed=\"false\"> <!-- This will not be embedded due to size unless we force it --> <IMG src=\"http://host/multi-mega-byte-img.png\"> <!-- This will not be embedded due to size unless we force it --> <IMG src=\"http://host/one-pixel-img.png\"> <!-- This will not be embedded due to query component unless we force it --> <IMG src=\"http://host/do/something?x=20\"> <!-- This will always be embedded and cannot be prevented --> <IMG src=\"s3://my-bucket/corporate-logo.png\"> Scheme: docma URLs of the following form are intercepted by docma and used to invoke a dynamic content generator. docma:<generator-name>?<generator-params> Note that for these docma URLs, there is no netloc component and hence no // in the URL. For example, this will generate a QR code: <IMG style=\"height: 40px\" src=\"docma:qrcode?text=Hello%s20world&fg=white&bg=red\"> The URL should be properly URL encoded. This can be fiddly, but Jinja can help here. The example above could also have been written in dictionary format thus: <IMG style=\"height: 40px\" src=docma:qrcode?{{ { 'text': 'Hello world', 'fg': 'white', 'bg': 'red' } | urlencode }}\"> It could also have been written as a sequence of tuples: <IMG style=\"height: 40px\" src=docma:qrcode?{{ ( ('text', 'Hello world'), ('fg', 'white'), ('bg', 'red') ) | urlencode }}\"> The sequence format is required if any of the parameters needs to be used more than once. Available content generators are: Name Description qrcode Generate a QR code. swatch Generate a colour swatch as graphic placeholder. vega Generate a chart based on the Vega-Lite declarative syntax for specifying charts / graphs. The dynamic content generator interface is readily extensible to add new types of content. See Content Generators . Generating QR Codes The QR code dynamic generator accepts the following parameters: Parameter Type Required Description bg String No Background colour of the QR code (e.g. blue or #0000ff ). Default is white. border Integer No Number of boxes thick for the border. Default is the minimum allowed value of 4. box Integer No Number of pixels for each box in the QR code. Default is 10. fg String No Foreground colour of the QR code. Default is black. text String Yes Content to be encoded in the QR code. Examples: <IMG style=\"height: 40px\" src=\"docma:qrcode?text=Hello%s20world&fg=white&bg=red\"> <IMG style=\"height: 40px\" src=docma:qrcode?{{ { 'text': 'Hello world', 'fg': 'white', 'bg': 'red' } | urlencode }}\"> Generating Charts and Graphs Docma supports the Vega-Lite declarative syntax for specifying charts / graphs. Vega-Lite specifies a mapping between source data and visual representations of the data. Docma provides mechanisms for specifying and accessing various data sources and feeding this data through a Vega-Lite specification to generate charts and graphs. This is a large topic and more information is provided in Charts and Graphs in Docma . To whet your appetite, check out the Vega-Lite sample gallery . This section just summarises the parameters for the vega content generator for reference: Parameter Type Required Description data String No A docma data source specification . This argument can be repeated if multiple data sources are required. If not specified, the file referenced by the spec parameter must contain all of the required data. format String No Either svg (the default) or png . Stick to svg if at all possible. spec String Yes The name of the file in the compiled document template that contains the Vega-Lite specification for the chart. The contents can be either YAML or JSON. ppi Integer No ( png format only) Pixels-per-inch resolution of the generated image. Default 72. scale Float No ( png format only) Scale the chart by the specified factor. Default is 1.0. Generally, it's better to control display size in the HTML but increasing the scale here can improve resolution. params JSON string No A string containing a JSON encoded object containing additional rendering parameters used when rendering the chart specification and any associated query specifications . Examples: <IMG style=\"width: 5cm;\" src=\"docma:vega?spec=charts/my-chart.yaml&data=...\"> <IMG style=\"width: 10cm;\" src=docma:vega?{{ ( ( 'spec', 'charts/my-chart.yaml' ), ( 'data', 'file;data/my-data.csv' ), ( 'params', { 'extra_rendering_param': 1234 } | tojson) ) | urlencode }}\"> Generating Graphic Placeholders (Swatches) The swatch generator produces a simple coloured rectangle with an optional text message. It's not intended to be useful in final documents, Mondrian notwithstanding. It has two purposes: As a simple code sample for dynamic content generators that can be copied and modified for new requirements. As a temporary placeholder when developing the structure of a docma template that will be replaced subsequently by a real piece of content (e.g. a chart). Parameter Type Required Description color String No Fill colour of the swatch. Default is a light grey. font String No Font file name for the text. Default is Arial . If the specified font is not available, a platform specific default is used. font_size Integer No Font size. Default is 18. height Integer Yes Swatch height in pixels. text String No Text to centre in the swatch. No effort is made to manipulate it to fit. text_color String No Colour for text. Default is black. width Integer Yes Swatch width in pixels. Colour or color ? The code and docma templates stick with color , because, well, that battle is lost. The user guide uses colour in descriptive text. Blame Webster for messing it up, not me. Examples: <IMG src=\"docma:swatch?width=150&height=150&color=seagreen\"> <IMG src=\"docma:swatch?{{ { 'width': 150, 'height': 150, 'color': '#0080ff', 'text': 'Hello world', 'text_color': 'yellow', 'font_size': 24 } | urlencode }}\" > Scheme: file URLs in HTML files of the form file:... are intercepted by docma and the content is extracted from a file within the compiled document template. As the file is local to the template, there is no network location so the URL will be like so: <IMG src=\"file:resources/logo.png\" alt=\"logo\"> Do not include // after file: . It will not work. Scheme: s3 URLs in HTML files of the form s3://... are intercepted by docma and the content is extracted from AWS S3. A typical usage would be something like: <IMG src=\"s3://my-bucket/some/path/logo.png\" alt=\"logo\"> Files are limited to 10MB in size. Watermarking Docma supports the ability to watermark and stamp PDF documents using the concept of document overlays . Overlays are not supported for HTML output documents. An overlay is a PDF document, generated by docma that can be used as either a watermark or a stamp. A watermark is content merged into every page of the final PDF under the main document content. A stamp is content merged into every page of the final PDF over the main document content. Overlays are defined in the template configuration file using the following structure: overlays: my-overlay-1: # We can have HTML files that will be rendered like other docs - a4-portrait.html # ... or static PDFs - a4-landscape.pdf # or ... my-overlay-2: a4-portrait.html Each overlay is a named list of documents (or a single document). When docma is requested to add a watermark (or stamp), it is provided with the name of one or more of the overlays (e.g. my-overlay-1 ). It will then render each of the files in each overlay list in the same way as the main document, including rendering with dynamic run-time parameters. Each page in the main document is then merged with the first page of the first overlay document in each list that has (approximately) the same page dimensions. The process will abort if a matching overlay page cannot be found for a main document page. The presence of the overlays section in the configuration file does not itself enable watermarking / stamping. This has to be explicitly requested. Watermarking / stamping can be requested using the --watermark / --stamp CLI options. If using the Python API, the watermark / stamp parameters to the render_template() function are used. It is possible to have both watermarking and stamping used on a single document, as well as having multiple overlays applied to a single document. A simple grid overlay is provided as part of the basic template created by the docma new command. This can be handy when adjusting page layout. To add the grid, the docma CLI rendering command would be docma pdf --stamp grid ... . Grid size and colour are adjustable in the parameter defaults in the template config file. Document Metadata Docma allows the template to control some of the metadata added to the final PDF or HTML and enforces some values of its own. PDF and HTML documents have slightly different conventions regarding metadata naming and formatting. Docma handles these variations. In HTML, the metadata fields are added into the <HEAD> of the final document in this form: <meta content=\"Fred Nurk\" name=\"author\"/> <meta content=\"A document about stuff\" name=\"title\"/> <meta content=\"DRAFT, Top-Secret\" name=\"keywords\"/> <meta content=\"2024-11-21T00:04:38.699978+00:00\" name=\"creation_date\"/> In PDF, the meta data fields are used to populate the standard metadata elements recognised by common PDF readers. HTML Naming PDF Naming Controlled by Comments author /Author Template From the metadata->author key in config.yaml creation_date /CreationDate Docma Document production datetime creator /Creator Docma Based on template id , version and docma version keywords /Keywords Template From the metadata->keywords key in config.yaml subject /Subject Template From the metadata->subject key in config.yaml title /Title Template From the metadata->title key in config.yaml Batch Rendering Docma supports the ability to generate a batch of output documents from a single document template using the pdf-batch (PDF) and html-batch (HTML) sub-commands of the docma CLI . The document template needs to anticipate the need for batch rendering by including some Jinja controlled content that will be varied for each document produced via document specific parameters. The source for the document specific batch parameters is a docma data loader . Data returned by the data loader is merged in with the fixed rendering parameters, a row at a time, and docma produces an output document using that combination. The source data for the batch parameters is specified using a docma data source specification . The following describes the process for PDF document batches. The process is similar for HTML batches. This is how a batch rendering is invoked: # Long form arguments docma pdf-batch --template my-template.zip \\ --file static-params.yaml \\ --data-source-spec 'postgres;pglocal;queries/batch.yaml' \\ --output 'whatever-{{id}}-{{familyname|lower}}.pdf' # Short form arguments docma pdf-batch -t my-template.zip \\ -f static-params.yaml \\ -d 'postgres;pglocal;queries/batch.yaml' \\ -o 'whatever-{{id}}-{{familyname|lower}}.pdf' Let's examine this bit by bit. The docma pdf-batch sub-command is invoked specifying the compiled document template: docma pdf-batch --template my-template.zip Rendering parameters are specified exactly as for the single document rendering process. These parameters are the same for every document in the rendering batch: --file static-params.yaml \\ The docma data source specification tells docma how to obtain rows of data to control the batch rendering. Each row is a set of key/value pairs that will be merged into the static rendering parameters and used to render one PDF document: --data-source-spec 'postgres;pglocal;queries/batch.yaml' \\ The docma data source specification is interpreted within the context of the document template. As docma will be producing a series of PDF documents, it needs a mechanism to provide each document with a unique name that corresponds to the batch data entry that was used to produce it. This is done using the --output option with an argument that is Jinja rendered to construct the filename. In this example, it is assumed that the batch data contains id and familyname elements and that these are a unique combination to avoid filename clashes: --output 'whatever-{{id}}-{{familyname|lower}}.pdf' There are some strict constraints on the filename rendering process for safety reasons.","title":"Docma Template Rendering"},{"location":"05-docma-template-rendering.html#docma-template-rendering","text":"The document rendering phase combines a compiled docma template with run-time specified parameters and dynamically generated content to produce a final output document. The rendering process is slightly different for PDF and HTML outputs.","title":"Docma Template Rendering"},{"location":"05-docma-template-rendering.html#rendering-for-pdf-outputs","text":"The main steps in the process for PDF production are: Marshal the rendering parameters . Validate the rendering parameters . Collect the list of documents to be incorporated into the final output PDF. Render HTML documents in the component list using Jinja to inject the rendering parameters . Convert the HTML documents to PDF using WeasyPrint . This process will also generate any dynamic content from specifications embedded in the source HTML. Assemble all of the components (generated PDFs and any listed static PDFs) into a single PDF document. Add any requested watermarking or stamping to the document. Jinja render any required metadata specified in the template configuration file and add it to the PDF. Optionally, compress the PDF using lossless compression. Depending on the PDF contents, compression may, or may not, help.","title":"Rendering for PDF Outputs"},{"location":"05-docma-template-rendering.html#rendering-for-html-outputs","text":"The main steps in the process for HTML production are: Marshal the rendering parameters . Validate the rendering parameters . Collect the list of documents to be incorporated into the final output HTML. Render HTML documents in the component list using Jinja to inject the rendering parameters . Process <IMG> tags in the HTML to generate and embed any dynamic content from specifications embedded in the source HTML. Static images may also be embedded. Assemble all of the component HTML documents into a single HTML document. Jinja render any required metadata specified in the template configuration file and add it to the HTML.","title":"Rendering for HTML Outputs"},{"location":"05-docma-template-rendering.html#docma-parameter-validation","text":"Docma supports the use of JSON Schema to validate rendering parameters at run-time. Parameters are validated against a schema provided in the parameters->schema key in the template configuration file prior to generating the output document. Failing validation will halt the production process. Provision, and hence use, of a parameter validation schema is optional, but highly recommended to reduce the risk of generating an important document incorrectly or with nonsensical values. All of the normal facilities of JSON Schema are available, except for external schema referencing with $ref directives. Like the JSON Schema built-in string formats , docma provided format checkers can be used in a schema specification with the format attribute of string objects The following sample schema fragment shows how these are used: type: object properties: customer_email: type: string format: email # This is a JSON schema built-in format checker customer_abn: type: string format: au.ABN # This is a docma provided format checker target_consumption: type: number minimum: 0 consumption_unit: type: string format: energy_unit # This is a docma provided format checker start_date: type: string format: date.dmy # This is a docma provided format checker See also Format Checkers Provided by Docma .","title":"Docma Parameter Validation"},{"location":"05-docma-template-rendering.html#docma-jinja-rendering","text":"The rendering phase uses Jinja to render HTML content with the parameters provided at run-time. Other components (e.g. query specifications ) also use Jinja rendering on some of their content. The docma Jinja subsystem has been refactored somewhat in v2.2.0. All of the facilities provided by Jinja are available, including parameter injection, loops, conditional content and use of the include directive to incorporate other content from the document template. Include directives should use the name of the file relative to the template root. e.g. {% include 'my-file.html' %} See also Jinja Rendering Parameters Provided by Docma . In addition to standard Jinja facilities, docma also provides a number of extra filters and extensions .","title":"Docma Jinja Rendering"},{"location":"05-docma-template-rendering.html#rendering-parameters","text":"The parameters used by docma during the template rendering process is the union of the following (from highest to lowest precedence): Parameters provided by docma . Parameters supplied by the user at run-time. Parameters specified under parameters->defaults in the template configuration file Parameters are any object that can be represented in JSON / standard YAML, which can include arbitrary combinations of objects, lists and scalar values. The marshalling process deep-merges the parameter trees from each source. Lists are not merged. One list will replace another if they occur at the same location.","title":"Rendering Parameters"},{"location":"05-docma-template-rendering.html#jinja-rendering-parameters-provided-by-docma","text":"In addition to user supplied parameters, docma includes the following items under the docma key. Key Notes Description calendar The Python calendar module. data Function to invoke a docma data provider and return the data as a list of dictionaries. See Data Source Specifications for HTML Rendering . datetime The Python datetime module. format The format of the output document to be produced, PDF or HTML . This can be used, among other things, for format specific content or formatting (e.g. CSS variations). paramstyle (1) Corresponds to the DBAPI 2.0 paramstyle attribute of the underlying database driver when processing a query specification . template An object containing information about the document template. --> description The description field from the template configuration file . --> doc_no (2) The document number in the list being included in the final document, starting at 1. --> document (2) The path for the source document being processed. This is a pathlib Path() instance. --> id The id field from the template configuration file . --> overlay_id (3) The ID of the current overlay set being rendered. --> overlay_path (3) The path for the current overlay file being rendered. This is a pathlib Path() instance. --> page (2) The starting page number for the current document with respect to the final output document. This may be useful for manipulating page numbering in multipart documents. Or not. --> version The version field from the template configuration file . version The docma version. Notes: The paramstyle parameter is only available for use in query specifications . The template.doc_no , template.document and template.page parameters are only available when a document file is being rendered (i.e. not when an overlay is being rendered). The template.page parameter is only available for PDF outputs. The template.overlay_id and template.overlay_path parameters are only available when an overlay file is being rendered. For example, to insert today's date: {{ docma.datetime.date.today() | date }} -- The \"date\" filter will format for the locale To check whether we are producing HTML or PDF: We are producing {{ docma.format }} output using docma version {{ docma.version }}.","title":"Jinja Rendering Parameters Provided by Docma"},{"location":"05-docma-template-rendering.html#custom-jinja-filters-provided-by-docma","text":"Jinja filter management has changed significantly in docma 2.2. Some filters have been renamed (with backward compatible aliases) and a new, more extensible filter plugin system has been implemented. In addition to the standard filters provided by Jinja, docma provides a number of additions. These are divided into: Generic filters Region / country specific filters . Note that custom filter names are case insensitive.","title":"Custom Jinja Filters Provided by Docma"},{"location":"05-docma-template-rendering.html#generic-filters","text":"Filters marked with * are locale aware. Filter Name Description compact_decimal * Format a number in a compact format. css_id Sanitise a string to be a valid CSS identifier. currency * Format currency. date * Format a date. datetime * Format a datetime. decimal * Format a number. dollars Legacy. Format currency a value as dollars. parse_date * Parse a date string into a datetime.date instance. parse_time * Parse a date string into a datetime.time instance. percent * Format a percentage. phone * Format a phone number. require Abort with an error message an expression does not have a truthy value. sql_safe Ensure that a string value is safe to use in SQL and generate an error if not. time * Format a time value. timedelta * Format a timedelta value.","title":"Generic Filters"},{"location":"05-docma-template-rendering.html#region-specific-filters","text":"Filter Name Description abn Deprecated. Use au.abn . acn Deprecated. Use au.abn . au.abn Format an Australian Business Number (ABN). au.acn Format an Australian Company Number (ACN).","title":"Region Specific Filters"},{"location":"05-docma-template-rendering.html#jinja-filter-auabn","text":"Format an Australian Business Number (ABN). This supersedes the, now deprecated, abn filter. {{ '51824753556' | au.abn }} --> 51 824 753 556","title":"Jinja Filter: au.abn"},{"location":"05-docma-template-rendering.html#jinja-filter-auacn","text":"Format an Australian Company Number (ACN). This supersedes the, now deprecated, acn filter. {{ '123456789' | au.acn }} --> 123 456 789","title":"Jinja Filter: au.acn"},{"location":"05-docma-template-rendering.html#jinja-filter-compact_decimal","text":"Format numeric values. This is a locale-aware filter that provides an interface to the Babel format_compact_decimal() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: compact_decimal( value: str | int | float, *args, rounding: str = 'half-up', default: int | float | str | None = None, **kwargs ) Parameter Description value Filter input value. Numbers and strings containing numbers are accepted. *args Passed to Babel's format_compact_decimal() . rounding How to round the value. This must be one of the rounding modes in Babel's decimal.ROUND_* , with the ROUND_ prefix removed. Case is ignored and hyphens become underscores. Defaults to half-up (Excel style rounding), instead of half-even (Bankers rounding) which is Python's normal default. default The default value to use for the filter if the input value is empty (i.e. None or an empty string). If the input value is empty and default is a string, it is used as-is as the return value of the filter. If the input value is empty, and default is not specified, an error is raised. Otherwise, the default is assumed to be numeric and is used as the input to the filter. Note: The default parameter does something different to the Jinja standard default filter. They are both useful but not interchangeable. **kwargs Passed to Babel's format_compact_decimal() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {{ 1234.5678 | compact_decimal }} --> 1K {{ '1234.5678' | compact_decimal }} --> 1K Locale can be specified explicitly, if required: {{ 1234.5678 | compact decimal(locale='fr_FR') }} --> 1 k","title":"Jinja Filter: compact_decimal"},{"location":"05-docma-template-rendering.html#jinja-filter-css_id","text":"Sanitise a string to be a valid CSS identifier. {{ 'a/()=*&bcd'' | css_id }} --> abcd","title":"Jinja Filter: css_id"},{"location":"05-docma-template-rendering.html#jinja-filter-currency","text":"Format a currency value. This is a locale-aware filter that provides an interface to the Babel format_currency() API. It is important to understand that there are two orthogonal aspects to formatting currency values: The currency involved, such as Australian dollars (AUD), Euros (EUR) etc. The locale in which the currency is to be presented. For example: One Australian dollar would appear in Australia as $1.00 . One Australian dollar would appear in the US as A$1.00 One Australian dollar would appear in France as 1,00 AU$ For the docma filter, the currency (AUD in the example above) can be specified in one of two ways: By providing an argument to the currency filter {{ 1 | currency('AUD') }} ; or Using the currency name itself as an alias for the filter name {{ 1 | AUD }} . Docma dynamically generates a filter alias for known currencies. Case is not significant. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: currency( value: str | int | float, currency: str, *args, rounding: str = 'half-up', default: int | float | str | None = None, **kwargs ) # ... or .... <CURRENCY_CODE>( value: str | int | float, *args, rounding: str = 'half-up', default: int | float | str | None = None, **kwargs ) Parameter Description value Filter input value. Numbers and strings containing numbers are accepted. Jinja will inject this automatically. currency The currency code (e.g AUD , EUR etc.) *args Passed to Babel's format_currency() . rounding How to round the value. This must be one of the rounding modes in Babel's decimal.ROUND_* , with the ROUND_ prefix removed. Case is ignored and hyphens become underscores. Defaults to half-up (Excel style rounding), instead of half-even (Bankers rounding) which is Python's normal default. default The default value to use for the filter if the input value is empty (i.e. None or an empty string but not zero). If the input value is empty and default is a string, it is used as-is as the return value of the filter. If the input value is empty, and default is not specified, an error is raised. Otherwise, the default is assumed to be numeric and is used as the input to the filter. Note: The default parameter does something different to the Jinja standard default filter. They are both useful but not interchangeable. **kwargs Passed to Babel's format_decimal() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {{ 123 | AUD }} --> $123.00 {{ 123 | currency('AUD') }} --> $123.00 {{ '123' | NZD }} --> NZD123.00 (numeric strings are fine as input) {{ None | AUD }} --> ERROR! {{ None | AUD(default=0) }} --> $0.00 {{ None | AUD(default='FREE!')}} --> FREE! {{ -123 | AUD(format=\"\u00a4#,###;(\u00a4#)\", currency_digits=False)}} --> ($123) Locale can be specified explicitly, if required: {{ 123 | EUR(locale='en_GB') }} --> \u20ac123.00 {{ 123 | EUR(locale='fr_FR' }} --> 123,00 \u20ac The legacy dollars filter can be replicated like so (use whatever dollar currency is appropriate): {{ 1234.5 | dollars }} --> {{ 1234.5 | AUD }} --> $1,234.50 {{ 1234.5 | dollars(0) }} --> {{ AUD(format=\"\u00a4#,###\", currency_digits=False) }} --> $1,235","title":"Jinja Filter: currency"},{"location":"05-docma-template-rendering.html#jinja-filter-date","text":"Format date values. This is a locale-aware filter that provides an interface to the Babel format_date() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: date(value: datetime.date | datetime.datetime, *args, **kwargs) Parameter Description value Filter input value. This must be a datetime.date or datetime.datetime instance. *args Passed to Babel's format_date() . **kwargs Passed to Babel's format_date() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {% set value = docma.datetime.date(2025, 9, 17) %} {{ value | date }} --> 17 Sept 2025 (medium format is the default) {{ value | date(format='short') }} --> 17/9/25 {{ value | date(format='long') }} --> 17 September 2025 {{ value | date(format='full') }} --> Wednesday, 17 September 2025 {{ value | date(format='dd/MM/yyyy')}} --> 17/09/2025 Locale can be specified explicitly, if required: {{ value | datetime(locale='en_US') }} --> Sep 17, 2025 If date strings need to be handled, they will need to be converted to a Python datetime.date instance first. For date strings guaranteed to be in ISO 8601 format, Python's standard datetime.date.fromisoformat() is fine. Otherwise, the safest way to do this for dates containing only numbers (no month names) is to use the parse_date filter as this is (docma) locale aware, unlike the Python standard datetime.datetime.strptime(). {{ docma.datetime.date.fromisoformat('2025-09-1') | date }} --> 1 Sept 2025 {{ '1/9/2025' | parse_date | date }} --> 1 Sept 2025 {{ '1/9/2025' | parse_date(locale='en_US') | date }} --> 9 Jan 2025 Here be dragons: There is no fully reliable way to parse dates containing month names in a generic, locale-aware away. Don't be tempted to attempt this in a docma template. If you think you need to, you are either solving the problem the wrong way or solving the wrong problem.","title":"Jinja Filter: date"},{"location":"05-docma-template-rendering.html#jinja-filter-datetime","text":"Format datetime values. This is a locale-aware filter that provides an interface to the Babel format_datetime() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: datetime(value: datetime.date | datetime.datetime | datetime.time, *args, **kwargs) Parameter Description value Filter input value. Typically, this would be a datetime.datetime instance. While datetime.date and datetime.time instances are also accepted, they are unlikely to be particularly useful. *args Passed to Babel's format_datetime() . **kwargs Passed to Babel's format_datetime() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {% set value = docma.datetime.datetime(2025, 9, 17, 14, 15, 16) %} {{ value | datetime }} --> 17 Sept 2025, 2:15:16 pm Locale can be specified explicitly, if required: {{ value | datetime(locale='en_US') }} --> Sep 17, 2025, 2:15:16 PM If datetime strings need to be handled, they will need to be converted to a Python datetime.datetime instance first. For datetime strings guaranteed to be in ISO 8601 format, Python's standard datetime.datetime.fromisoformat() is fine. {{ docma.datetime.datetime.fromisoformat('2025-09-17T14:15:16') | datetime }} Avoid using the Python standard datetime.datetime strptime() if at all possible. This will use the platform locale and cannot handle the docma locale. The results can be very unpredictable.","title":"Jinja Filter: datetime"},{"location":"05-docma-template-rendering.html#jinja-filter-decimal","text":"Format numeric values. This is a locale-aware filter that provides an interface to the Babel format_decimal() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be explicitly specified by adding a locale argument to the filter. The filter signature is: decimal( value: str | int | float, *args, rounding: str = 'half-up', default: int | float | str | None = None, **kwargs ) Parameter Description value Filter input value. Numbers and strings containing numbers are accepted. *args Passed to Babel's format_decimal() . rounding How to round the value. This must be one of the rounding modes in Babel's decimal.ROUND_* , with the ROUND_ prefix removed. Case is ignored and hyphens become underscores. Defaults to half-up (Excel style rounding), instead of half-even (Bankers rounding) which is Python's normal default. default The default value to use for the filter if the input value is empty (i.e. None or an empty string, but not zero). If the input value is empty and default is a string, it is used as-is as the return value of the filter. If the input value is empty, and default is not specified, an error is raised. Otherwise, the default is assumed to be numeric and is used as the input to the filter. Note: The default parameter does something different to the Jinja standard default filter. They are both useful but not interchangeable. **kwargs Passed to Babel's format_decimal() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {{ 1234.5678 | decimal }} --> 1,234.568 (Default is to round to 3 decimal places) {{ '1234.5678' | decimal }} --> 1,234.568 (numeric strings are fine as input) {{ None | decimal }} --> ERROR! {{ None | decimal(default=0) }} --> 0 {{ None | decimal(default='nix')}} \u2192 nix Locale can be specified explicitly, if required: {{ 1234.5678 | decimal(locale='fr_FR') }} --> 1 234,568","title":"Jinja Filter: decimal"},{"location":"05-docma-template-rendering.html#jinja-filter-dollars","text":"Round and format a currency value as dollars. Banker's half-up, rounding is used (like Excel) instead of the half-even rounding that is Python's normal default. This filter is a legacy that is not actually deprecated (yet), but its use is discouraged. Use the currency filter in preference. The filter signature is: dollars(value: str | int | float, precision: int = 2, symbol: str = '$') Parameter Description value A number or numeric string. precision Number of decimal places to show. Defaults to 2. symbol The currency symbol to show. Defaults to $ . Examples: {{ 1234.50 | dollars }} --> $1,234.50 {{ 1234.50 | dollars(0) }} --> $1,235","title":"Jinja Filter: dollars"},{"location":"05-docma-template-rendering.html#jinja-filter-parse_date","text":"Parse a date string into a datetime.date instance. This is a locale-aware filter that provides an interface to the Babel parse_date() API. The filter signature is: parse_date(value: str, *args, **kwargs) -> datetime.date Parameter Description value Filter input value. The parser understands component ordering variations by locale but cannot handle month names. Numbers only. *args Passed to Babel's parse_date() . **kwargs Passed to Babel's parse_date() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {{ '1/9/2025' | parse_date) }} --> datetime.date(2025, 9, 1) Locale can be specified explicitly, if required: {{ '1/9/2025' | parse_date(locale='en_US') }} --> datetime.date(2025, 1, 9)","title":"Jinja Filter: parse_date"},{"location":"05-docma-template-rendering.html#jinja-filter-parse_time","text":"Parse a date string into a datetime.time instance. This is a locale-aware filter that provides an interface to the Babel parse_time() API. The filter signature is: parse_time(value: str, *args, **kwargs) -> datetime.time Parameter Description value Filter input value. *args Passed to Babel's parse_time() . **kwargs Passed to Babel's parse_time() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {{ '2:15 pm' | parse_time) }} --> datetime.time(14, 15) Locale can be specified explicitly, if required: {{ '1/9/2025' | parse_date(locale='en_US') }} --> datetime.date(2025, 1, 9)","title":"Jinja Filter: parse_time"},{"location":"05-docma-template-rendering.html#jinja-filter-percent","text":"Format percentage values. This is a locale-aware filter that provides an interface to the Babel format_percent() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: percent( value: str | int | float, *args, rounding: str = 'half-up', default: int | float | str | None = None, **kwargs ) Parameter Description value Filter input value. Numbers and strings containing numbers are accepted. *args Passed to Babel's format_percent() . rounding How to round the value. This must be one of the rounding modes in Babel's decimal.ROUND_* , with the ROUND_ prefix removed. Case is ignored and hyphens become underscores. Defaults to half-up (Excel style rounding), instead of half-even (Bankers rounding) which is Python's normal default. default The default value to use for the filter if the input value is empty (i.e. None or an empty string). If the input value is empty and default is a string, it is used as-is as the return value of the filter. If the input value is empty, and default is not specified, an error is raised. Otherwise, the default is assumed to be numeric and is used as the input to the filter. Note: The default parameter does something different to the Jinja standard default filter. They are both useful but not interchangeable. **kwargs Passed to Babel's format_percent() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {{ 0.1234 | percent }} --> 12% {{ '0.1234' | percent }} --> 12% {{ None | percent }} --> ERROR! {{ None | percent(default=0) }} --> 0% {{ None | percent(default='--')}} --> -- Locale can be specified explicitly, if required: {{ '0.123' | percent(locale='fr_FR') }} --> 12 %","title":"Jinja Filter: percent"},{"location":"05-docma-template-rendering.html#jinja-filter-phone","text":"Format phone numbers. If a number cannot be formatted, the unmodified input is returned. This is a locale-aware filter. The underlying process is implemented using the excellent Python phonenumbers package, which is itself a port of Google's libphonenumber library . Phone number formatting varies substantially internationally. Hence, the filter needs to determine the relevant region for each phone number. It can do that in one of 3 ways (highest precedence to lowest) An international code in the source phone number. An explicit region code argument to the phone filter (expressed as a two-character ISO country code). By assuming the phone number is associated with the effective locale setting For example, a locale setting of en_AU would imply the number is part of the Australian phone numbering plan. The filter signature is: phone(number: str, region: str = None, *, format: str = None) Parameter Description number The phone number input to the filter. Phone numbers are always strings, never integers. Ever. region The region to which the phone number belongs as a 2 character ISO country code. Ignored if the phone number includes an international code. If not specified, the country code from the current effective locale is used. format See below. Phone numbers can be formatted in different ways. The following values of the format parameter are supported: Format Description E164 E.164 is the standard International Telecommunication Union (ITU) format for worldwide telephone numbers. e.g. +61491570006 INTERNATIONAL The full international phone number, formatted as per national conventions. e.g. +61 491 570 006 NATIONAL The national number component of the phone number without the international code component, formatted as per national conventions. e.g. 0491 570 006 RFC3966 The URI format for phone numbers. This will typically generate one-touch call links in on-line content. e.g. tel:+61-491-570-006 If not specified, NATIONAL is used if the region for the phone number matches that for the current locale and INTERNATIONAL otherwise. Examples (assuming locale is set to en_AU ): {{ '0491 570 006' | phone }} --> 0491 570 006 (Locale will provide \"AU\" as region) {{ '+61 491 570 006' | phone }} --> 0491 570 006 (Region comes from the number) {{ '4155550132' | phone('US') }} --> +1 415-555-0132 {{ '4155550132'| phone('US', format='NATIONAL') }} --> (415) 555-0132 {{ '4155550132'| phone('US', format='RFC3966') }} --> tel:+1-415-555-0132 {{ 'bad-to-the-phone' }} --> bad-to-the-phone (If all else fails, return the input)","title":"Jinja Filter: phone"},{"location":"05-docma-template-rendering.html#jinja-filter-require","text":"Abort with an error message if the value is not a truthy value (i.e. a non-empty string, non-zero integer etc), otherwise return the value. This is useful for situations where it is better to abort if an expression is expected to have a value, but doesn't, rather than make assumptions. Dear Bob, Your flight details have changed and your flight will now depart at {{ flight_time | require('flight_time must be a non-empty string') }}. Don't be late.","title":"Jinja Filter: require"},{"location":"05-docma-template-rendering.html#jinja-filter-sql_safe","text":"Ensure that a string value is safe to use in SQL and generate an error if not. This is primarily for use in query specifications to avoid SQL injection. It has a puritanical view on safety but will cover most normal requirements. Examples: SELECT * from {{ table | sql_safe }} ...","title":"Jinja Filter: sql_safe"},{"location":"05-docma-template-rendering.html#jinja-filter-time","text":"Format time values. This is a locale-aware filter that provides an interface to the Babel format_time() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: time(value: datetime.time | datetime.datetime, *args, **kwargs) Parameter Description value Filter input value. This must be a datetime.time or datetime.datetime instance. *args Passed to Babel's format_time() . **kwargs Passed to Babel's format_time() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {% set value = docma.datetime.time(14, 15) %} {{ value | time }} --> 2:15:00 pm Locale can be specified explicitly, if required: {{ value | datetime(locale='de_DE') }} --> 14:15:00 If time strings need to be handled, they will need to be converted to a Python datetime.time instance first. The safest way to do this is to use the parse_time filter as this is (docma) locale aware. {{ '14:15' | parse_time | time }} --> 2:15:00 pm {{ '2:15 pm' | parse_time | time }} --> 2:15:00 pm","title":"Jinja Filter: time"},{"location":"05-docma-template-rendering.html#jinja-filter-timedelta","text":"Format timedelta values. This is a locale-aware filter that provides an interface to the Babel format_timedelta() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting. The locale is determined as described in Locale in Docma Templates . It can also be specified explicitly by adding a locale argument to the filter. The filter signature is: timedelta(value: datetime.timedelta | datetime.datetime | datetime.time, *args, **kwargs) Parameter Description value Filter input value. This must be a datetime.timedelta instance. *args Passed to Babel's format_timedelta() . **kwargs Passed to Babel's format_timedelta() . This includes the option of using the locale parameter to specify locale. Examples (assuming locale is set to en_AU ): {% set d1 = docma.datetime.datetime(2025, 9, 17, 14, 15, 16) %} {% set d2 = docma.datetime.datetime(2025, 9, 19, 14, 15, 16) %} {{ (d2 - d1) | timedelta }} --> 2 days (default format is 'long') {{ (d2 - d1) | timedelta(format='narrow') }} --> 2d {{ (d2 - d1) | timedelta(add_direction=True) }} --> in 2 days Locale can be specified explicitly, if required: {{ (d2 - d1) | timedelta(locale='uk_UA') }} --> '2 \u0434\u043d\u0456' The Babel format_timedelta() rounding process is not particularly intuitive on first appearance but makes sense once you get the hang of it. You may need to experiment with threshold and granularity arguments to get the desired effect.","title":"Jinja Filter: timedelta"},{"location":"05-docma-template-rendering.html#custom-jinja-extensions-provided-by-docma","text":"Docma provides some custom Jinja extensions. In Jinja, extensions are invoked using the following syntax: {% tag [parameters] %} In addition to the custom extensions described below, docma also provides the following standard Jinja extensions: debug loopcontrols .","title":"Custom Jinja Extensions Provided by Docma"},{"location":"05-docma-template-rendering.html#jinja-extension-abort","text":"The abort extension forces the rendering process to abort with an exception message. It would typically be used in response to some failed correctness check where it's preferable to fail document production rather than to proceed in error. For example: {% if bad_data %} {% abort 'Fatal error - bad data' %} {% endif %}","title":"Jinja Extension: abort"},{"location":"05-docma-template-rendering.html#jinja-extension-dump_params","text":"The dump_params extension simply dumps the rendering parameters for debugging purposes. The standard Jinja debug extension does something similar (and a bit more) but much less readably. Typical usage would be: <PRE>{% dump_params %}</PRE>","title":"Jinja Extension: dump_params"},{"location":"05-docma-template-rendering.html#jinja-extension-global","text":"The global extension allows values defined within the Jinja content of a HTML document to be made available when rendering other components in a document template. For example, the following declares the globals a and b . {% global a=1, b='Plugh' %} These can then be accessed, either in the file in which they were declared or in a different HTML document, or a query specification like so: You are at Y{{ globals.a + 1 }}. A hollow voice says \"{{ globals.b }}.\" The result will be: Your are at Y2. A hollow voice says \"Plugh\". Compare this with the standard Jinja set operation: {% set a=1 %} The variable a can only be accessed in the file in which it is defined, or a file that includes that file. It cannot be accessed in a different HTML document, or a query specification Warning : It is important to understand that within the docma rendering phase, the Jinja rendering of the component HTML documents is completed before the generation and injection of dynamic content . This means that only the final value of any global parameter is available during the dynamic content generation phase. i.e. It is not possible to use globals to pass a loop variable from the Jinja rendering of the HTML into the dynamic content generation phase.","title":"Jinja Extension: global"},{"location":"05-docma-template-rendering.html#format-checkers-provided-by-docma","text":"Docma includes an extensible set of format checkers. These can be used in two ways: In JSON schema specifications as format specifiers for string data elements; and As Jinja tests in content that will be Jinja rendered. The docma provided format checkers are divided into: Generic checkers Region / country specific checkers . All docma provided format checker names are case insensitive. It is easy to add new format checkers , as required.","title":"Format Checkers Provided by Docma"},{"location":"05-docma-template-rendering.html#generic-format-checkers","text":"Test Name Description date.dmy Date formatted as day/month/year. The separators can be any of /-_. or missing (e.g. 31/12/2024 , 31.12.2024 , 31-12-2024 , 31_12_2024 , 31122024 ). date.mdy Date formatted as month/day/year. The separators can be any of /-_. or missing (e.g. 12/31/2024 , ...). date.ymd Date formatted as year/month/day. The separators can be any of /-_. or missing (e.g. 2024/12/31 , ...). DD/MM/YYYY JSON Schema use only . Deprecated. Use date.dmy instead. energy_unit An energy unit (e.g. kWh, MVArh). locale A locale specifier (e.g. en_AU , fr_FR ) power_unit A power unit (e.g. kW, MVA). semantic_version A version in the form major.minor.patch (e.g. 1.3.0 ).","title":"Generic Format Checkers"},{"location":"05-docma-template-rendering.html#region-specific-format-checkers","text":"Checker Name Description ACN Deprecated. Use au.abn instead. ABN Deprecated. Use au.abn instead. au.ABN Australian Business Number. au.ACN Australian Company Number. au.MIRN Australian energy industry Gas Meter Installation Registration Number. au.NMI Australian energy industry National Metering Identifier. MIRN Deprecated. Use au.MIRN instead. NMI Deprecated. Use au.NMI instead.","title":"Region Specific Format Checkers"},{"location":"05-docma-template-rendering.html#using-format-checkers-in-json-schema-specifications","text":"JSON Schema specifications are supported, and strongly recommended, in a number of docma components, such as as the template configuration file , and query specifications . They provide run-time type checking of important data elements and are an important safety mechanism. Like the JSON Schema built-in string formats , docma provided format checkers can be used in a schema specification with the format attribute of string objects, like so: type: object properies: prop1: type: string format: ... # Use a built in format like \"email\" or one of docma's format checkers Examples are given in YAML rather than JSON for readability, and because they are specified in YAML in docma. For example, consider a document template for a contract that requires parameters for customer email, contract start date, and customer Australian Business Number (ABN) to be specified: The relevant portion of the template configuration file might look like this: parameters: schema: $schema: https://json-schema.org/draft/2020-12/schema # Schema for the schema! title: Parameters validation schema type: object required: - locale - customer_email - customer_abn - contract_start_date properties: locale: type: string format: locale # This is a docma provided format checker customer_email: type: string format: email # This is a standard JSON schema format checker customer_abn: type: string format: au.ABN # This is a docma provided format checker. contract_start_date: type: string format: date.dmy # This is a docma provided format checker Docma will validate values provided at run-time against this schema.","title":"Using Format Checkers in JSON Schema Specifications"},{"location":"05-docma-template-rendering.html#using-format-checkers-in-jinja","text":"In addition to the standard tests provided by Jinja , the docma format checkers can also be used as Jinja tests, like so: {% if contract_date is not date.dmy %} {% abort 'Bad date' %} {% endif %} When used as Jinja tests, none of the docma format checkers accept an arguments additional to the value being checked. Docma can also be extended with Jinja tests that can accept additional arguments, but these would not also be used in JSON Schema specifications and hence would not be considered to be format checkers.","title":"Using Format Checkers in Jinja"},{"location":"05-docma-template-rendering.html#dynamic-content-generation","text":"When docma converts HTML into PDF or stand-alone HTML, it needs to resolve all URLs in the source HTML in things such as <img src=\"...\"> tags. It does this via a custom URL fetcher that allows content requests to be intercepted and the resulting content generated dynamically. In this way, docma can generate dynamic content, such as charts, for inclusion in the final output document. There are some differences in this process depending on whether the final output is PDF of HTML. See Dynamic Content Generation Differences Between PDF and HTML Output . All URLs are constituted thus: scheme://netloc/path;parameters?query#fragment Docma determines which custom URL fetcher to apply based on the URL scheme (i.e. the first part before the colon). The URL fetchers handle a range of non-standard, docma specific schemes, as well as the standard http and https schemes. Docma currently handles the following non-standard schemes: Scheme Description docma Interface to docma dynamic content generators of various types. file Interface to access files contained within the compiled document template. s3 Interface to access files from AWS S3. The docma URL fetcher interface is easily expandable to handle other schemes. See URL Fetchers .","title":"Dynamic Content Generation"},{"location":"05-docma-template-rendering.html#dynamic-content-generation-differences-between-pdf-and-html-output","text":"PDF generation from HTML is performed by WeasyPrint, which will invoke a custom URL fetcher for any URL it needs to access during the conversion process. This includes, but is not limited to , <IMG> tags. For standalone HTML output, the process of invoking a custom URL fetcher is done by docma itself. It is only applied to the src attribute of <IMG> tags under specific circumstances. When it is done, the src attribute is replaced in the <IMG> tag with the actual content returned by the URL fetcher. i.e. the data is embedded within the standalone HTML output. In practice, these differences work naturally, relative to the final viewing environment for the produced document, static PDF or dynamic HTML. By default, in HTML outputs, <IMG> tags have the content embedded in place of the src attribute in the following circumstances: The src URL is not http(s):// (i.e. any of the docma custom schemes described below); or The src URL is http(s):// , has no query component ?... , and the content size is between 100 bytes and 1MB in size. For the http(s):// URLs, it is possible to override the default behaviour by adding the data-docma-embed attribute to the <IMG> tag. For images that are not embedded, it is assumed that the client (e.g. an email client or web browser) will fetch the images as required at display time. <!-- Force the image to be embedded --> <IMG src=\"http://host/img.png\" data-docma-embed=\"true\"> <!-- Prevent the image from being embedded --> <IMG src=\"http://host/img.png\" data-docma-embed=\"false\"> <!-- This will not be embedded due to size unless we force it --> <IMG src=\"http://host/multi-mega-byte-img.png\"> <!-- This will not be embedded due to size unless we force it --> <IMG src=\"http://host/one-pixel-img.png\"> <!-- This will not be embedded due to query component unless we force it --> <IMG src=\"http://host/do/something?x=20\"> <!-- This will always be embedded and cannot be prevented --> <IMG src=\"s3://my-bucket/corporate-logo.png\">","title":"Dynamic Content Generation Differences Between PDF and HTML Output"},{"location":"05-docma-template-rendering.html#scheme-docma","text":"URLs of the following form are intercepted by docma and used to invoke a dynamic content generator. docma:<generator-name>?<generator-params> Note that for these docma URLs, there is no netloc component and hence no // in the URL. For example, this will generate a QR code: <IMG style=\"height: 40px\" src=\"docma:qrcode?text=Hello%s20world&fg=white&bg=red\"> The URL should be properly URL encoded. This can be fiddly, but Jinja can help here. The example above could also have been written in dictionary format thus: <IMG style=\"height: 40px\" src=docma:qrcode?{{ { 'text': 'Hello world', 'fg': 'white', 'bg': 'red' } | urlencode }}\"> It could also have been written as a sequence of tuples: <IMG style=\"height: 40px\" src=docma:qrcode?{{ ( ('text', 'Hello world'), ('fg', 'white'), ('bg', 'red') ) | urlencode }}\"> The sequence format is required if any of the parameters needs to be used more than once. Available content generators are: Name Description qrcode Generate a QR code. swatch Generate a colour swatch as graphic placeholder. vega Generate a chart based on the Vega-Lite declarative syntax for specifying charts / graphs. The dynamic content generator interface is readily extensible to add new types of content. See Content Generators .","title":"Scheme: docma"},{"location":"05-docma-template-rendering.html#generating-qr-codes","text":"The QR code dynamic generator accepts the following parameters: Parameter Type Required Description bg String No Background colour of the QR code (e.g. blue or #0000ff ). Default is white. border Integer No Number of boxes thick for the border. Default is the minimum allowed value of 4. box Integer No Number of pixels for each box in the QR code. Default is 10. fg String No Foreground colour of the QR code. Default is black. text String Yes Content to be encoded in the QR code. Examples: <IMG style=\"height: 40px\" src=\"docma:qrcode?text=Hello%s20world&fg=white&bg=red\"> <IMG style=\"height: 40px\" src=docma:qrcode?{{ { 'text': 'Hello world', 'fg': 'white', 'bg': 'red' } | urlencode }}\">","title":"Generating QR Codes"},{"location":"05-docma-template-rendering.html#generating-charts-and-graphs","text":"Docma supports the Vega-Lite declarative syntax for specifying charts / graphs. Vega-Lite specifies a mapping between source data and visual representations of the data. Docma provides mechanisms for specifying and accessing various data sources and feeding this data through a Vega-Lite specification to generate charts and graphs. This is a large topic and more information is provided in Charts and Graphs in Docma . To whet your appetite, check out the Vega-Lite sample gallery . This section just summarises the parameters for the vega content generator for reference: Parameter Type Required Description data String No A docma data source specification . This argument can be repeated if multiple data sources are required. If not specified, the file referenced by the spec parameter must contain all of the required data. format String No Either svg (the default) or png . Stick to svg if at all possible. spec String Yes The name of the file in the compiled document template that contains the Vega-Lite specification for the chart. The contents can be either YAML or JSON. ppi Integer No ( png format only) Pixels-per-inch resolution of the generated image. Default 72. scale Float No ( png format only) Scale the chart by the specified factor. Default is 1.0. Generally, it's better to control display size in the HTML but increasing the scale here can improve resolution. params JSON string No A string containing a JSON encoded object containing additional rendering parameters used when rendering the chart specification and any associated query specifications . Examples: <IMG style=\"width: 5cm;\" src=\"docma:vega?spec=charts/my-chart.yaml&data=...\"> <IMG style=\"width: 10cm;\" src=docma:vega?{{ ( ( 'spec', 'charts/my-chart.yaml' ), ( 'data', 'file;data/my-data.csv' ), ( 'params', { 'extra_rendering_param': 1234 } | tojson) ) | urlencode }}\">","title":"Generating Charts and Graphs"},{"location":"05-docma-template-rendering.html#generating-graphic-placeholders-swatches","text":"The swatch generator produces a simple coloured rectangle with an optional text message. It's not intended to be useful in final documents, Mondrian notwithstanding. It has two purposes: As a simple code sample for dynamic content generators that can be copied and modified for new requirements. As a temporary placeholder when developing the structure of a docma template that will be replaced subsequently by a real piece of content (e.g. a chart). Parameter Type Required Description color String No Fill colour of the swatch. Default is a light grey. font String No Font file name for the text. Default is Arial . If the specified font is not available, a platform specific default is used. font_size Integer No Font size. Default is 18. height Integer Yes Swatch height in pixels. text String No Text to centre in the swatch. No effort is made to manipulate it to fit. text_color String No Colour for text. Default is black. width Integer Yes Swatch width in pixels. Colour or color ? The code and docma templates stick with color , because, well, that battle is lost. The user guide uses colour in descriptive text. Blame Webster for messing it up, not me. Examples: <IMG src=\"docma:swatch?width=150&height=150&color=seagreen\"> <IMG src=\"docma:swatch?{{ { 'width': 150, 'height': 150, 'color': '#0080ff', 'text': 'Hello world', 'text_color': 'yellow', 'font_size': 24 } | urlencode }}\" >","title":"Generating Graphic Placeholders (Swatches)"},{"location":"05-docma-template-rendering.html#scheme-file","text":"URLs in HTML files of the form file:... are intercepted by docma and the content is extracted from a file within the compiled document template. As the file is local to the template, there is no network location so the URL will be like so: <IMG src=\"file:resources/logo.png\" alt=\"logo\"> Do not include // after file: . It will not work.","title":"Scheme: file"},{"location":"05-docma-template-rendering.html#scheme-s3","text":"URLs in HTML files of the form s3://... are intercepted by docma and the content is extracted from AWS S3. A typical usage would be something like: <IMG src=\"s3://my-bucket/some/path/logo.png\" alt=\"logo\"> Files are limited to 10MB in size.","title":"Scheme: s3"},{"location":"05-docma-template-rendering.html#watermarking","text":"Docma supports the ability to watermark and stamp PDF documents using the concept of document overlays . Overlays are not supported for HTML output documents. An overlay is a PDF document, generated by docma that can be used as either a watermark or a stamp. A watermark is content merged into every page of the final PDF under the main document content. A stamp is content merged into every page of the final PDF over the main document content. Overlays are defined in the template configuration file using the following structure: overlays: my-overlay-1: # We can have HTML files that will be rendered like other docs - a4-portrait.html # ... or static PDFs - a4-landscape.pdf # or ... my-overlay-2: a4-portrait.html Each overlay is a named list of documents (or a single document). When docma is requested to add a watermark (or stamp), it is provided with the name of one or more of the overlays (e.g. my-overlay-1 ). It will then render each of the files in each overlay list in the same way as the main document, including rendering with dynamic run-time parameters. Each page in the main document is then merged with the first page of the first overlay document in each list that has (approximately) the same page dimensions. The process will abort if a matching overlay page cannot be found for a main document page. The presence of the overlays section in the configuration file does not itself enable watermarking / stamping. This has to be explicitly requested. Watermarking / stamping can be requested using the --watermark / --stamp CLI options. If using the Python API, the watermark / stamp parameters to the render_template() function are used. It is possible to have both watermarking and stamping used on a single document, as well as having multiple overlays applied to a single document. A simple grid overlay is provided as part of the basic template created by the docma new command. This can be handy when adjusting page layout. To add the grid, the docma CLI rendering command would be docma pdf --stamp grid ... . Grid size and colour are adjustable in the parameter defaults in the template config file.","title":"Watermarking"},{"location":"05-docma-template-rendering.html#document-metadata","text":"Docma allows the template to control some of the metadata added to the final PDF or HTML and enforces some values of its own. PDF and HTML documents have slightly different conventions regarding metadata naming and formatting. Docma handles these variations. In HTML, the metadata fields are added into the <HEAD> of the final document in this form: <meta content=\"Fred Nurk\" name=\"author\"/> <meta content=\"A document about stuff\" name=\"title\"/> <meta content=\"DRAFT, Top-Secret\" name=\"keywords\"/> <meta content=\"2024-11-21T00:04:38.699978+00:00\" name=\"creation_date\"/> In PDF, the meta data fields are used to populate the standard metadata elements recognised by common PDF readers. HTML Naming PDF Naming Controlled by Comments author /Author Template From the metadata->author key in config.yaml creation_date /CreationDate Docma Document production datetime creator /Creator Docma Based on template id , version and docma version keywords /Keywords Template From the metadata->keywords key in config.yaml subject /Subject Template From the metadata->subject key in config.yaml title /Title Template From the metadata->title key in config.yaml","title":"Document Metadata"},{"location":"05-docma-template-rendering.html#batch-rendering","text":"Docma supports the ability to generate a batch of output documents from a single document template using the pdf-batch (PDF) and html-batch (HTML) sub-commands of the docma CLI . The document template needs to anticipate the need for batch rendering by including some Jinja controlled content that will be varied for each document produced via document specific parameters. The source for the document specific batch parameters is a docma data loader . Data returned by the data loader is merged in with the fixed rendering parameters, a row at a time, and docma produces an output document using that combination. The source data for the batch parameters is specified using a docma data source specification . The following describes the process for PDF document batches. The process is similar for HTML batches. This is how a batch rendering is invoked: # Long form arguments docma pdf-batch --template my-template.zip \\ --file static-params.yaml \\ --data-source-spec 'postgres;pglocal;queries/batch.yaml' \\ --output 'whatever-{{id}}-{{familyname|lower}}.pdf' # Short form arguments docma pdf-batch -t my-template.zip \\ -f static-params.yaml \\ -d 'postgres;pglocal;queries/batch.yaml' \\ -o 'whatever-{{id}}-{{familyname|lower}}.pdf' Let's examine this bit by bit. The docma pdf-batch sub-command is invoked specifying the compiled document template: docma pdf-batch --template my-template.zip Rendering parameters are specified exactly as for the single document rendering process. These parameters are the same for every document in the rendering batch: --file static-params.yaml \\ The docma data source specification tells docma how to obtain rows of data to control the batch rendering. Each row is a set of key/value pairs that will be merged into the static rendering parameters and used to render one PDF document: --data-source-spec 'postgres;pglocal;queries/batch.yaml' \\ The docma data source specification is interpreted within the context of the document template. As docma will be producing a series of PDF documents, it needs a mechanism to provide each document with a unique name that corresponds to the batch data entry that was used to produce it. This is done using the --output option with an argument that is Jinja rendered to construct the filename. In this example, it is assumed that the batch data contains id and familyname elements and that these are a unique combination to avoid filename clashes: --output 'whatever-{{id}}-{{familyname|lower}}.pdf' There are some strict constraints on the filename rendering process for safety reasons.","title":"Batch Rendering"},{"location":"06-charts-and-graphs-in-docma.html","text":"Charts and Graphs in Docma Docma supports the Vega-Lite declarative syntax for specifying charts / graphs. Vega-Lite specifies a mapping between source data and visual representations of the data. To make all this work in docma requires three things: A means to tell docma that a chart needs to be generated. This is done using a special URL format within <IMG> tags in the source HTML. See Invoking Charts in HTML Source Documents . A means to specify the design of the chart. This is done with a chart specification file within the document template. A means to feed data to the chart creation process. See Source Data for Charts . Invoking Charts in HTML Source Documents Docma provides a URL based mechanism to trigger creation of charts during the process of converting HTML to a PDF or HTML output document. See Dynamic Content Generation for more details. It looks like this: <IMG src=\"docma:vega?spec=charts/my-chart.yaml&data=...\"> In a nutshell, when docma sees a URL in this form, it knows to get data from the source specified by the data parameter and feed it into the chart generator with the Vega-Lite specification indicated by the spec parameter: Normal CSS styling can also be applied: <IMG style=\"width: 5cm;\" src=\"docma:vega?spec=charts/my-chart.yaml&data=...\"> Here is a more complete example, showing how Jinja can help build the src URL structure safely: <IMG style=\"width: 10cm;\" src=docma:vega?{{ ( ( 'spec', 'charts/my-chart.yaml' ), ( 'data', 'file;data/my-data.csv' ), ( 'params', { 'extra_rendering_param': 1234 } | tojson) ) | urlencode }}\"> See also docma scheme parameters for vega charts . Chart Specification Files The chart specification is a file in the document template containing a Vega-Lite chart definition. The chart specification will be Jinja rendered prior to use. The chart specification can be in either JSON or YAML format. Docma doesn't care which. There are pros and cons with each format. YAML is easier to write and to read but JSON is the native format of the examples in the Vega-Lite sample gallery or the Vega-Lite on-line editor . You're going to want to use both of these resources. The chart specification file should still have a .yaml suffix, even if the contents are JSON. This all works because valid JSON is also valid YAML. Note that docma uses the Vega-Altair Python package to process Vega-Lite specifications. Source Data for Charts The value of the data parameter in a docma:vega?... URL is a docma data source specification that indicates where to obtain the data and where to attach it to the chart specification. The data parameter can be used multiple times if there are multiple data sources in the chart. If the data parameter is not specified, the source data is assumed to be contained within the chart specification itself. This can actually be useful when designing a chart to avoid the need to wrangle external data when experimenting. See Data Sources in Docma for more information. Tips and Suggestions for Designing Charts The Vega-Lite website has lots of resources to help with designing charts. This section just provides a few tips and suggestions. Some suggestions for simplifying the development: Where possible, start with a chart from the Vega-Lite sample gallery and play with it in the on-line editor to get close to what you are after. Include a small sample data set in the chart specification to allow experimentation. The sample data can be left in the specification when included into a docma document template. Docma will replace it at run-time. Charts reference a JSON schema: $schema: https://vega.github.io/schema/vega-lite/v5.json . PyCharm will interpret this and provide some auto completion and validation as you go. Believe it, or not, but ChatGPT is surprisingly helpful with Vega-Lite. It can often give meaningful answers to enquiries like these: Explain this Vega-Lite specification to me ... (paste the JSON in) I have this Vega-Lite specification. How do I remove the axes and change the colour on the bars? Design a Vega-Lite chart that shows a heat map of ... with ... on the x axis and ... on the y axis ChatGPT can get confused with obscure concepts (like interval meter data). You can often replace this with more generic data in the questions (temperature data is a good substitute for interval data). Layers are quite an important concept in Vega-Lite. Make an effort to understand them. Samples With a bit of effort, Vega-Lite does a surprisingly good job of generating good looking charts with a small amount of specification. Here are a few examples. Bar Chart This is a bar chart of dog woof-power. This is the specification file (with truncated data). $schema: 'https://vega.github.io/schema/vega-lite/v5.json' width: 300 config: font: Avenir background: '#eeeeee' padding: 10 view: stroke: transparent axisX: grid: false gridWidth: 0.5 domainDash: - 4 - 4 formatType: number axisY: grid: false data: values: - Dog: Bolliver Woof: 28 view: fill: '#eeeeee' encoding: 'y': field: Dog title: Dog type: ordinal axis: null layer: - mark: type: bar cornerRadius: 20 encoding: x: field: Woof title: null type: quantitative color: field: Woof type: quantitative title: '% Woof' scale: domain: [ 0, 100 ] range: [ '#fec72b', '#fa4617' ] - mark: type: text align: left x: 10 color: white fontWeight: bold encoding: text: field: Dog Interval Meter Data Heat Map This is a heat map of interval meter data by day and month. This is the specification file (with truncated data). $schema: 'https://vega.github.io/schema/vega-lite/v5.json' title: 'Daily Usage' config: font: Avenir view: continuousWidth: 300 continuousHeight: 300 step: 13 strokeWidth: 0 axis: domain: false data: name: usage_by_day mark: type: rect encoding: color: aggregate: max field: kwh legend: title: kWh type: quantitative scale: range: [ '#fec72b', '#fa4617' ] x: axis: format: '%e' labelAngle: 0 field: date timeUnit: date title: Day type: ordinal y: field: date timeUnit: month title: Month type: ordinal datasets: # Sample data -- this gets replaced usage_by_day: - date: 2023-07-01 kwh: 1234","title":"Charts and Graphs in Docma"},{"location":"06-charts-and-graphs-in-docma.html#charts-and-graphs-in-docma","text":"Docma supports the Vega-Lite declarative syntax for specifying charts / graphs. Vega-Lite specifies a mapping between source data and visual representations of the data. To make all this work in docma requires three things: A means to tell docma that a chart needs to be generated. This is done using a special URL format within <IMG> tags in the source HTML. See Invoking Charts in HTML Source Documents . A means to specify the design of the chart. This is done with a chart specification file within the document template. A means to feed data to the chart creation process. See Source Data for Charts .","title":"Charts and Graphs in Docma"},{"location":"06-charts-and-graphs-in-docma.html#invoking-charts-in-html-source-documents","text":"Docma provides a URL based mechanism to trigger creation of charts during the process of converting HTML to a PDF or HTML output document. See Dynamic Content Generation for more details. It looks like this: <IMG src=\"docma:vega?spec=charts/my-chart.yaml&data=...\"> In a nutshell, when docma sees a URL in this form, it knows to get data from the source specified by the data parameter and feed it into the chart generator with the Vega-Lite specification indicated by the spec parameter: Normal CSS styling can also be applied: <IMG style=\"width: 5cm;\" src=\"docma:vega?spec=charts/my-chart.yaml&data=...\"> Here is a more complete example, showing how Jinja can help build the src URL structure safely: <IMG style=\"width: 10cm;\" src=docma:vega?{{ ( ( 'spec', 'charts/my-chart.yaml' ), ( 'data', 'file;data/my-data.csv' ), ( 'params', { 'extra_rendering_param': 1234 } | tojson) ) | urlencode }}\"> See also docma scheme parameters for vega charts .","title":"Invoking Charts in HTML Source Documents"},{"location":"06-charts-and-graphs-in-docma.html#chart-specification-files","text":"The chart specification is a file in the document template containing a Vega-Lite chart definition. The chart specification will be Jinja rendered prior to use. The chart specification can be in either JSON or YAML format. Docma doesn't care which. There are pros and cons with each format. YAML is easier to write and to read but JSON is the native format of the examples in the Vega-Lite sample gallery or the Vega-Lite on-line editor . You're going to want to use both of these resources. The chart specification file should still have a .yaml suffix, even if the contents are JSON. This all works because valid JSON is also valid YAML. Note that docma uses the Vega-Altair Python package to process Vega-Lite specifications.","title":"Chart Specification Files"},{"location":"06-charts-and-graphs-in-docma.html#source-data-for-charts","text":"The value of the data parameter in a docma:vega?... URL is a docma data source specification that indicates where to obtain the data and where to attach it to the chart specification. The data parameter can be used multiple times if there are multiple data sources in the chart. If the data parameter is not specified, the source data is assumed to be contained within the chart specification itself. This can actually be useful when designing a chart to avoid the need to wrangle external data when experimenting. See Data Sources in Docma for more information.","title":"Source Data for Charts"},{"location":"06-charts-and-graphs-in-docma.html#tips-and-suggestions-for-designing-charts","text":"The Vega-Lite website has lots of resources to help with designing charts. This section just provides a few tips and suggestions. Some suggestions for simplifying the development: Where possible, start with a chart from the Vega-Lite sample gallery and play with it in the on-line editor to get close to what you are after. Include a small sample data set in the chart specification to allow experimentation. The sample data can be left in the specification when included into a docma document template. Docma will replace it at run-time. Charts reference a JSON schema: $schema: https://vega.github.io/schema/vega-lite/v5.json . PyCharm will interpret this and provide some auto completion and validation as you go. Believe it, or not, but ChatGPT is surprisingly helpful with Vega-Lite. It can often give meaningful answers to enquiries like these: Explain this Vega-Lite specification to me ... (paste the JSON in) I have this Vega-Lite specification. How do I remove the axes and change the colour on the bars? Design a Vega-Lite chart that shows a heat map of ... with ... on the x axis and ... on the y axis ChatGPT can get confused with obscure concepts (like interval meter data). You can often replace this with more generic data in the questions (temperature data is a good substitute for interval data). Layers are quite an important concept in Vega-Lite. Make an effort to understand them.","title":"Tips and Suggestions for Designing Charts"},{"location":"06-charts-and-graphs-in-docma.html#samples","text":"With a bit of effort, Vega-Lite does a surprisingly good job of generating good looking charts with a small amount of specification. Here are a few examples.","title":"Samples"},{"location":"06-charts-and-graphs-in-docma.html#bar-chart","text":"This is a bar chart of dog woof-power. This is the specification file (with truncated data). $schema: 'https://vega.github.io/schema/vega-lite/v5.json' width: 300 config: font: Avenir background: '#eeeeee' padding: 10 view: stroke: transparent axisX: grid: false gridWidth: 0.5 domainDash: - 4 - 4 formatType: number axisY: grid: false data: values: - Dog: Bolliver Woof: 28 view: fill: '#eeeeee' encoding: 'y': field: Dog title: Dog type: ordinal axis: null layer: - mark: type: bar cornerRadius: 20 encoding: x: field: Woof title: null type: quantitative color: field: Woof type: quantitative title: '% Woof' scale: domain: [ 0, 100 ] range: [ '#fec72b', '#fa4617' ] - mark: type: text align: left x: 10 color: white fontWeight: bold encoding: text: field: Dog","title":"Bar Chart"},{"location":"06-charts-and-graphs-in-docma.html#interval-meter-data-heat-map","text":"This is a heat map of interval meter data by day and month. This is the specification file (with truncated data). $schema: 'https://vega.github.io/schema/vega-lite/v5.json' title: 'Daily Usage' config: font: Avenir view: continuousWidth: 300 continuousHeight: 300 step: 13 strokeWidth: 0 axis: domain: false data: name: usage_by_day mark: type: rect encoding: color: aggregate: max field: kwh legend: title: kWh type: quantitative scale: range: [ '#fec72b', '#fa4617' ] x: axis: format: '%e' labelAngle: 0 field: date timeUnit: date title: Day type: ordinal y: field: date timeUnit: month title: Month type: ordinal datasets: # Sample data -- this gets replaced usage_by_day: - date: 2023-07-01 kwh: 1234","title":"Interval Meter Data Heat Map"},{"location":"07-data-sources-in-docma.html","text":"Data Sources in Docma Docma can access data files and live data sources during the rendering phase. This is done by the data provider subsystem. The returned data can be used in the following ways: Source data for charts and graphs . Injection into the Jinja rendering process for HTML content (e.g. for tables or other variable content). Data providers return their data as a list of objects, one row of data per object. Be careful with dataset sizes. This interface is not designed for very large amounts of data. Do as much data preparation / reduction outside of docma as possible (e.g. via database queries to generate just the essential data). Data Source Specifications Docma uses the concept of data source specifications to control the process of obtaining the data and what to do with it. They contain the following components. Component Description type The data provider type (e.g. file if the data comes from a file). This controls the connection / access mechanism. location Where to find the data. For a file based source it would be the path to the file. For a database provider, it would point to the connection information for the database. query The file name in the document template containing a query specification that defines a query to execute on the data provider. This is required for database-like sources. It is not used for some data provider types. target For charts, the position in the Vega-Lite specification where the data will be attached. This is a dot separated dictionary key sequence pointing into the chart specification. If not provided, this defaults to data.values , which is the primary data location for a Vega-Lite specification. Data Source Specifications for Charts The HTML to include a chart is of the form: <IMG src=\"docma:vega?spec=charts/my-chart.yaml&data=...\"> The value of the data parameter is a docma data source specification expressed in string form, like so: data=type;location[;query[;target] Why jam all this together into a single URL parameter rather than have separate parameters for each component? The reason is because a Vega-Lite chart can have multiple data sources and hence multiple instances of the data parameter. It can be fiddly combining all these components in a URL in a readable way. The recommended approach is to use Jinja to assemble all the pieces and handle the gory details of URL encoding, like so: <IMG style=\"width: 10cm;\" src=docma:vega?{{ ( ( 'spec', 'charts/my-chart.yaml' ), ( 'data', 'file;data/my-data.csv' ), ( 'data', 'file;data/more-data.csv;;datasets.more_data' ), ( 'data', ( 'postgres', 'pgdb01', 'queries/usage-by-day.yaml', 'datasets.usage_by_day' ) | join(';'), ), ) | urlencode }}\"> In this example, three data sets are specified: The first one is extracted from a local CSV file and attached to the chart specification at the default location of data.values (i.e the values object under the data object is replaced with our CSV data). The second one is extracted from a local CSV file and attached to the chart specification as the datasets.more_data object in the specification. Note that the unused query component must be provided as an empty string to ensure the target component is correctly placed. The third one is extracted by running a query against a Postgres database and attached to the chart specification as the datasets.usage_by_day object in the specification. Data Source Specifications for HTML Rendering A data source specification can be invoked directly in Jinja content within a document that is to be rendered. This is done using the docma.data() function provided in the run-time rendering parameters . It accepts three arguments corresponding to the first three components of a data source specification : type location query (optional). The docma.data() function also accepts an optional params argument which is a dictionary of additional parameter values that will be merged into the Jinja rendering parameters when rendering the query specification . See also Jinja Rendering Parameters Provided by Docma . For example, the following document content invokes the postgres data provider to run a query on the Custard Appreciation Society membership records and present the data in a table. <TABLE> <THEAD> <TR> <TH>Custard Type</TH> <TH>Bid Price</TH> </TR> </THEAD> <TBODY> {% for row in docma.data('postgres', 'pgdb01', 'queries/custard-price.yaml') %} <TR> <TD>{{ row.favouritecustard }}</TD> <TD>{{ row.price | dollars(2) }}</TD> </TR> {% endfor %} </TBODY> </TABLE> </BODY> </HTML> If a query only returns a single row, that would be referenced like so: {{ docma.data(...)[0] }} ... or ... {{ docma.data(...) | first }} Query Specifications Some data providers require a query to be specified to extract the data. In docma, this is done using a query specification . A query specification is a YAML formatted file in the document template. It is referenced as the third element of a data source specification . These should be placed in the queries directory in the template. Docma thus externalises all database queries into a single, visible collection rather than embedding them in random places within the template document components. A query specification file contains the DML of the query to be executed as well as information on how to handle query parameters. It contains the following keys: Key Type Required Description description String Yes A description for human consumption. Not used by docma. options Object No Query control options. --> fold_headers Boolean No Convert all headers to lowercase (prior to row validation). This is sometimes necessary as different database drivers can handle the case treatment of headers in different ways. The default is false . --> row_limit Integer No Abort if the query returns more than the specified number of rows. This is a safety mechanism. The default is 0, meaning no limit is applied. parameters List No A list of query parameter specification objects. If empty, the query has no parameters (which would be unusual). The parameter values are Jinja rendered using the run-time rendering parameters. query String Yes The query text . This will be Jinja rendered using the run-time rendering parameters. schema Object No A JSON Schema specification for each row of data returned by the query. See Query Schemas below. Here's a sample: description: Extract Custard Appreciation Society membership records query: >- SELECT * FROM \"{{ db.schema | sql_safe }}\".custard WHERE favouritecustard=%s AND custardbidprice > %s AND custardjedi=%s; SORT BY surname; parameters: - name: favouritecustard value: '{{ db.favouritecustard }}' - name: custardbidprice value: '{{ db.custardbidprice }}' type: decimal - name: custardjedi value: '{{ db.custardjedi }}' type: boolean options: row_limit: 20 fold_headers: true Query Text The query itself is pretty vanilla (ha!) SQL with some notable exceptions. Firstly, the query text will be Jinja rendered with the docma run-time rendering parameters. This makes it easy to do things such as switching schemas without having to alter the document template. (This is close to impossible in some popular analytics platforms that shall remain nameless.) It is probably best not to embed data source specification references within a query specification (i.e. recursive calls to the data provider subsystem). Don't cross the streams. Care is required to avoid SQL injection risks. In the example above, the schema is quoted and also filtered using the docma specific sql_safe Jinja filter. This filter will abort if the value contains something unsafe. Secondly, the values for query parameters are replaced with placeholders. The actual values are determined at run-time from the parameter specifications. The placeholder is database driver specific unfortunately, based on the paramstyle it uses. The pg8000 driver used for Postgres uses %s style, whereas DuckDB uses ? . It's not my fault. DO NOT attempt to use Jinja to format query parameters into the SQL text itself. This is seriously unsafe. Use query parameter specifications . Thirdly, when the data is to be used in a Vega-Lite chart , all of the data returned by the query needs to be JSON serialisable. i.e. Python types such as datetime , Decimal etc will be a problem. The query should type cast everything to types that can be JSON serialised. For example: -- This will not work ... SELECT date_of_birth as dob, height_in_cm as height FROM people; -- This will work (Postgres syntax) ... SELECT date_of_birth::text as dob, height_in_cm::float as height FROM people; Query Parameters Query parameters are specified as a list of query parameter specification objects. These contain the following keys: Key Type Required Description name String Yes The parameter name. This is used for database drivers that support named and pyformat paramstyles . It is mandatory for all parameters for maintainability. value String Yes The parameter value. In many cases this will be a Jinja value injection construct. type String No A type indicator. Docma uses this to cast the value to the specified type. Only the following are supported: str / string , int / integer , float , decimal , bool / boolean . The default is string . Alternatively, cast string values within the DML. These are supplied to the query at run-time using the DBAPI 2.0 driver's query parameter mechanism to avoid SQL injection risks. Query Schemas In some situations, it may be important to validate that the data returned by a query meets certain conditions and to abort document production if it does not. This can be achieved by including a schema object in the query specification . The data preparation process should take proper care to ensure valid data. Query Schemas are the last line of defence against bad data appearing in documents. The schema object is a JSON Schema specification that is used to validate each row of data. Validation failures will abort the process. Note that all rows are returned as objects with keys based on the column names in the query. For example, consider the following query specification: description: Get company information. query: >- SELECT name, age_in_years, abn FROM companies; # This schema will validate each row. We don't have to # validate every attribute in a row. Just the ones we're # worried about. schema: type: object # It's always one object per row of data properties: age_in_years: type: number minimum: 0 maximum: 200 abn: type: string format: au.ABN # This is a docma provided format checker In addition to the standard format specifiers supported by JSON Schema, the format checkers provided by docma are available for string objects. Data Provider Types The data provider interface is readily extensible to add new data sources. See Data Providers . Data Provider Type: duckdb Docma can read data from a local file containing a DuckDB database. The DuckDB data provider is a useful mechanism for handling data extracts with docma. Docma, running on a DuckDB data extract can be quite fast, even with moderately large datasets. Why DuckDB rather than, for example, SQLite? DuckDB has a much more complete SQL implementation than SQLite, and one which is much closer to Postgres. It also has a very powerful and flexible mechanism for accessing data from other sources (files in various formats, AWS S3 etc.). And it goes like the clappers. The type component of the data source specification is duckdb . The location component is the name of a local file (not a template file) containing the database. The query component is the name of a query specification file. Examples This example shows a DuckDB database being used to supply data to a chart (using Jinja tuple notation): <IMG style=\"width: 10cm;\" src=\"docma:vega?{{ ( ( 'spec', 'charts/dog-woof-power-chart.yaml' ), ( 'data', 'duckdb;/tmp/demo/dogs.db;queries/woof-power.yaml' ), ) | urlencode }}\" > This example shows a DuckDB database being used to populate an HTML table: <TABLE> <THEAD> <TR> <TH>Dog</TH> <TH class=\"Woof\">Woof</TH> </TR> </THEAD> <TBODY> {% for row in docma.data('duckdb', '/tmp/demo/dogs.db', 'queries/woof-power.yaml') %} <TR> <TD class=\"Dog\">{{ row.Dog }}</TD> <TD class=\"Woof\">{{ row.Woof }}</TD> </TR> {% endfor %} </TBODY> </TABLE> Data Provider Type: file Docma can read data from static files contained within the compiled document template. The type component of the data source specification is file . The location component is the name of the file, relative to the root of the template. Handling is determined based on the file suffix. The following formats are supported: File Suffix Description csv A CSV file with a header line. The excel dialect is assumed. jsonl A file containing one JSON formatted object per line. The query component is not used. Examples This example shows a CSV file being used to supply data to a chart (using Jinja tuple notation): <IMG style=\"width: 10cm; justify-self: start;\" src=\"docma:vega?{{ ( ( 'spec', 'charts/woof.yaml'), ( 'data', 'file;data/dogs.csv'), ) | urlencode }}\" > This example shows a CSV file being used to populate an HTML table: <TABLE> <THEAD> <TR> <TH>Dog</TH> <TH class=\"Woof\">Woof</TH> </TR> </THEAD> <TBODY> {% for row in docma.data('file', 'data/dogs.csv', 'queries/woof-power.yaml') %} <TR> <TD class=\"Dog\">{{ row.Dog }}</TD> <TD class=\"Woof\">{{ row.Woof }}</TD> </TR> {% endfor %} </TBODY> </TABLE> In the example above, the csv file ( data/dogs.csv ) might look something like this: Dog,Woof Bolliver,28 Rin Tin Tin,55 Fido,43 Kipper,91 Zoltan,81 Pluto,53 Scooby,24 Cerberus,87 Snoopy,52 Data Provider Type: lava If the lava package is installed , docma can use the lava connection subsystem to read data from a database. Lava provides support for connecting to a range of database types, including Postgres, Redshift, SQL Server, MySQL and Oracle. It also manages all of the connection details, credentials etc. The type component of the data source specification is lava . The location component is a lava connection ID for a database. The query component is the name of a query specification file. The lava realm must be specified during rendering, either by setting the LAVA_REALM environment variable, or via the --realm argument to the CLI. The query text must use a paramstyle that matches the underlying driver being used by lava. Refer to the lava user guide for more information. Examples This example shows a lava database connector (ID= redshift/prod ) being used to supply data to a chart (using Jinja tuple notation): <IMG style=\"width: 10cm;\" src=\"docma:vega?{{ ( ( 'spec', 'charts/dog-woof-power-chart.yaml' ), ( 'data', 'lava;redshift/prod;queries/woof-power.yaml' ), ) | urlencode }}\" > This example shows a lava database connector (ID= redshift/prod ) being used to populate an HTML table: <TABLE> <THEAD> <TR> <TH>Dog</TH> <TH class=\"Woof\">Woof</TH> </TR> </THEAD> <TBODY> {% for row in docma.data('lava', 'redshift/prod', 'queries/woof-power.yaml') %} <TR> <TD class=\"Dog\">{{ row.Dog }}</TD> <TD class=\"Woof\">{{ row.Woof }}</TD> </TR> {% endfor %} </TBODY> </TABLE> Data Provider Type: params Docma can extract data from a list of objects in the rendering parameters. The type component of the data source specification is params . The location component is a dot separated key sequence to select a data list within the parameters. Each element of the list must be an object (not a string). The query component is not used. Examples Consider the following rendering parameters: param1: value1 param2: value2 data: custard: prices: - type: lumpy price: 1.53 - type: baked price: 2.84 - type: runny price: 3.50 A data source specification of params;data.custard.prices would return the following data rows: { \"type\": \"lumpy\", \"price\": 1.53 } { \"type\": \"baked\", \"price\": 2.84 } { \"type\": \"runny\", \"price\": 3.5 } This example shows rendering parameters being used to supply data to a chart (using Jinja tuple notation): <IMG style=\"width: 10cm;\" src=\"docma:vega?{{ ( ( 'spec', 'charts/custard-prices-chart.yaml' ), ( 'data', 'params;data.custard.prices' ), ) | urlencode }}\" > This example shows rendering parameters being used to populate an HTML table: <TABLE> <THEAD> <TR> <TH>Custard Type</TH> <TH class=\"price\">Price</TH> </TR> </THEAD> <TBODY> {% for row in docma.data('params', 'data.custard.prices') %} <TR> <TD class=\"type\">{{ row.type }}</TD> <TD class=\"price\">{{ row.price }}</TD> </TR> {% endfor %} </TBODY> </TABLE> Data Provider Type: postgres Docma can read data from a Postgres database. The type component of the data source specification is postgres . The location component is an alpha-numeric label for the database. This is used to determine connection details from environment variables or the contents of a .env file. If the location component is xyz , then docma will read the following values from a .env file to connect to the database. Name Description XYZ_USER Database user name XYZ_PASSWORD Password. Exactly one of XYZ_PASSWORD and XYZ_PASSWORD_PARAM must be specified. XYZ_PASSWORD_PARAM AWS SSM parameter containing the password. XYZ_HOST Host name XYZ_PORT Port number XYZ_DATABASE Database name XYZ_SSL A truthy value specifying if SSL should be enforced (default no ) Values can also be overridden by environment variables with the same names as above, prefixed with DOCMA_ . e.g. DOCMA_XYZ_USER . Take care to ensure the .env file is excluded from any GIT repo. A redacted sample is provided in the test directory. The query component is the name of a query specification file. Examples This example shows a Postgres database being used to supply data to a chart (using Jinja tuple notation): <IMG style=\"width: 10cm;\" src=\"docma:vega?{{ ( ( 'spec', 'charts/dog-woof-power-chart.yaml' ), ( 'data', 'postgres;prod01;queries/woof-power.yaml' ), ) | urlencode }}\" > This example shows a Postgres database being used to populate an HTML table: <TABLE> <THEAD> <TR> <TH>Dog</TH> <TH class=\"Woof\">Woof</TH> </TR> </THEAD> <TBODY> {% for row in docma.data('postgres', 'prod01', 'queries/woof-power.yaml') %} <TR> <TD class=\"Dog\">{{ row.Dog }}</TD> <TD class=\"Woof\">{{ row.Woof }}</TD> </TR> {% endfor %} </TBODY> </TABLE>","title":"Data Sources in Docma"},{"location":"07-data-sources-in-docma.html#data-sources-in-docma","text":"Docma can access data files and live data sources during the rendering phase. This is done by the data provider subsystem. The returned data can be used in the following ways: Source data for charts and graphs . Injection into the Jinja rendering process for HTML content (e.g. for tables or other variable content). Data providers return their data as a list of objects, one row of data per object. Be careful with dataset sizes. This interface is not designed for very large amounts of data. Do as much data preparation / reduction outside of docma as possible (e.g. via database queries to generate just the essential data).","title":"Data Sources in Docma"},{"location":"07-data-sources-in-docma.html#data-source-specifications","text":"Docma uses the concept of data source specifications to control the process of obtaining the data and what to do with it. They contain the following components. Component Description type The data provider type (e.g. file if the data comes from a file). This controls the connection / access mechanism. location Where to find the data. For a file based source it would be the path to the file. For a database provider, it would point to the connection information for the database. query The file name in the document template containing a query specification that defines a query to execute on the data provider. This is required for database-like sources. It is not used for some data provider types. target For charts, the position in the Vega-Lite specification where the data will be attached. This is a dot separated dictionary key sequence pointing into the chart specification. If not provided, this defaults to data.values , which is the primary data location for a Vega-Lite specification.","title":"Data Source Specifications"},{"location":"07-data-sources-in-docma.html#data-source-specifications-for-charts","text":"The HTML to include a chart is of the form: <IMG src=\"docma:vega?spec=charts/my-chart.yaml&data=...\"> The value of the data parameter is a docma data source specification expressed in string form, like so: data=type;location[;query[;target] Why jam all this together into a single URL parameter rather than have separate parameters for each component? The reason is because a Vega-Lite chart can have multiple data sources and hence multiple instances of the data parameter. It can be fiddly combining all these components in a URL in a readable way. The recommended approach is to use Jinja to assemble all the pieces and handle the gory details of URL encoding, like so: <IMG style=\"width: 10cm;\" src=docma:vega?{{ ( ( 'spec', 'charts/my-chart.yaml' ), ( 'data', 'file;data/my-data.csv' ), ( 'data', 'file;data/more-data.csv;;datasets.more_data' ), ( 'data', ( 'postgres', 'pgdb01', 'queries/usage-by-day.yaml', 'datasets.usage_by_day' ) | join(';'), ), ) | urlencode }}\"> In this example, three data sets are specified: The first one is extracted from a local CSV file and attached to the chart specification at the default location of data.values (i.e the values object under the data object is replaced with our CSV data). The second one is extracted from a local CSV file and attached to the chart specification as the datasets.more_data object in the specification. Note that the unused query component must be provided as an empty string to ensure the target component is correctly placed. The third one is extracted by running a query against a Postgres database and attached to the chart specification as the datasets.usage_by_day object in the specification.","title":"Data Source Specifications for Charts"},{"location":"07-data-sources-in-docma.html#data-source-specifications-for-html-rendering","text":"A data source specification can be invoked directly in Jinja content within a document that is to be rendered. This is done using the docma.data() function provided in the run-time rendering parameters . It accepts three arguments corresponding to the first three components of a data source specification : type location query (optional). The docma.data() function also accepts an optional params argument which is a dictionary of additional parameter values that will be merged into the Jinja rendering parameters when rendering the query specification . See also Jinja Rendering Parameters Provided by Docma . For example, the following document content invokes the postgres data provider to run a query on the Custard Appreciation Society membership records and present the data in a table. <TABLE> <THEAD> <TR> <TH>Custard Type</TH> <TH>Bid Price</TH> </TR> </THEAD> <TBODY> {% for row in docma.data('postgres', 'pgdb01', 'queries/custard-price.yaml') %} <TR> <TD>{{ row.favouritecustard }}</TD> <TD>{{ row.price | dollars(2) }}</TD> </TR> {% endfor %} </TBODY> </TABLE> </BODY> </HTML> If a query only returns a single row, that would be referenced like so: {{ docma.data(...)[0] }} ... or ... {{ docma.data(...) | first }}","title":"Data Source Specifications for HTML Rendering"},{"location":"07-data-sources-in-docma.html#query-specifications","text":"Some data providers require a query to be specified to extract the data. In docma, this is done using a query specification . A query specification is a YAML formatted file in the document template. It is referenced as the third element of a data source specification . These should be placed in the queries directory in the template. Docma thus externalises all database queries into a single, visible collection rather than embedding them in random places within the template document components. A query specification file contains the DML of the query to be executed as well as information on how to handle query parameters. It contains the following keys: Key Type Required Description description String Yes A description for human consumption. Not used by docma. options Object No Query control options. --> fold_headers Boolean No Convert all headers to lowercase (prior to row validation). This is sometimes necessary as different database drivers can handle the case treatment of headers in different ways. The default is false . --> row_limit Integer No Abort if the query returns more than the specified number of rows. This is a safety mechanism. The default is 0, meaning no limit is applied. parameters List No A list of query parameter specification objects. If empty, the query has no parameters (which would be unusual). The parameter values are Jinja rendered using the run-time rendering parameters. query String Yes The query text . This will be Jinja rendered using the run-time rendering parameters. schema Object No A JSON Schema specification for each row of data returned by the query. See Query Schemas below. Here's a sample: description: Extract Custard Appreciation Society membership records query: >- SELECT * FROM \"{{ db.schema | sql_safe }}\".custard WHERE favouritecustard=%s AND custardbidprice > %s AND custardjedi=%s; SORT BY surname; parameters: - name: favouritecustard value: '{{ db.favouritecustard }}' - name: custardbidprice value: '{{ db.custardbidprice }}' type: decimal - name: custardjedi value: '{{ db.custardjedi }}' type: boolean options: row_limit: 20 fold_headers: true","title":"Query Specifications"},{"location":"07-data-sources-in-docma.html#query-text","text":"The query itself is pretty vanilla (ha!) SQL with some notable exceptions. Firstly, the query text will be Jinja rendered with the docma run-time rendering parameters. This makes it easy to do things such as switching schemas without having to alter the document template. (This is close to impossible in some popular analytics platforms that shall remain nameless.) It is probably best not to embed data source specification references within a query specification (i.e. recursive calls to the data provider subsystem). Don't cross the streams. Care is required to avoid SQL injection risks. In the example above, the schema is quoted and also filtered using the docma specific sql_safe Jinja filter. This filter will abort if the value contains something unsafe. Secondly, the values for query parameters are replaced with placeholders. The actual values are determined at run-time from the parameter specifications. The placeholder is database driver specific unfortunately, based on the paramstyle it uses. The pg8000 driver used for Postgres uses %s style, whereas DuckDB uses ? . It's not my fault. DO NOT attempt to use Jinja to format query parameters into the SQL text itself. This is seriously unsafe. Use query parameter specifications . Thirdly, when the data is to be used in a Vega-Lite chart , all of the data returned by the query needs to be JSON serialisable. i.e. Python types such as datetime , Decimal etc will be a problem. The query should type cast everything to types that can be JSON serialised. For example: -- This will not work ... SELECT date_of_birth as dob, height_in_cm as height FROM people; -- This will work (Postgres syntax) ... SELECT date_of_birth::text as dob, height_in_cm::float as height FROM people;","title":"Query Text"},{"location":"07-data-sources-in-docma.html#query-parameters","text":"Query parameters are specified as a list of query parameter specification objects. These contain the following keys: Key Type Required Description name String Yes The parameter name. This is used for database drivers that support named and pyformat paramstyles . It is mandatory for all parameters for maintainability. value String Yes The parameter value. In many cases this will be a Jinja value injection construct. type String No A type indicator. Docma uses this to cast the value to the specified type. Only the following are supported: str / string , int / integer , float , decimal , bool / boolean . The default is string . Alternatively, cast string values within the DML. These are supplied to the query at run-time using the DBAPI 2.0 driver's query parameter mechanism to avoid SQL injection risks.","title":"Query Parameters"},{"location":"07-data-sources-in-docma.html#query-schemas","text":"In some situations, it may be important to validate that the data returned by a query meets certain conditions and to abort document production if it does not. This can be achieved by including a schema object in the query specification . The data preparation process should take proper care to ensure valid data. Query Schemas are the last line of defence against bad data appearing in documents. The schema object is a JSON Schema specification that is used to validate each row of data. Validation failures will abort the process. Note that all rows are returned as objects with keys based on the column names in the query. For example, consider the following query specification: description: Get company information. query: >- SELECT name, age_in_years, abn FROM companies; # This schema will validate each row. We don't have to # validate every attribute in a row. Just the ones we're # worried about. schema: type: object # It's always one object per row of data properties: age_in_years: type: number minimum: 0 maximum: 200 abn: type: string format: au.ABN # This is a docma provided format checker In addition to the standard format specifiers supported by JSON Schema, the format checkers provided by docma are available for string objects.","title":"Query Schemas"},{"location":"07-data-sources-in-docma.html#data-provider-types","text":"The data provider interface is readily extensible to add new data sources. See Data Providers .","title":"Data Provider Types"},{"location":"07-data-sources-in-docma.html#data-provider-type-duckdb","text":"Docma can read data from a local file containing a DuckDB database. The DuckDB data provider is a useful mechanism for handling data extracts with docma. Docma, running on a DuckDB data extract can be quite fast, even with moderately large datasets. Why DuckDB rather than, for example, SQLite? DuckDB has a much more complete SQL implementation than SQLite, and one which is much closer to Postgres. It also has a very powerful and flexible mechanism for accessing data from other sources (files in various formats, AWS S3 etc.). And it goes like the clappers. The type component of the data source specification is duckdb . The location component is the name of a local file (not a template file) containing the database. The query component is the name of a query specification file.","title":"Data Provider Type: duckdb"},{"location":"07-data-sources-in-docma.html#examples","text":"This example shows a DuckDB database being used to supply data to a chart (using Jinja tuple notation): <IMG style=\"width: 10cm;\" src=\"docma:vega?{{ ( ( 'spec', 'charts/dog-woof-power-chart.yaml' ), ( 'data', 'duckdb;/tmp/demo/dogs.db;queries/woof-power.yaml' ), ) | urlencode }}\" > This example shows a DuckDB database being used to populate an HTML table: <TABLE> <THEAD> <TR> <TH>Dog</TH> <TH class=\"Woof\">Woof</TH> </TR> </THEAD> <TBODY> {% for row in docma.data('duckdb', '/tmp/demo/dogs.db', 'queries/woof-power.yaml') %} <TR> <TD class=\"Dog\">{{ row.Dog }}</TD> <TD class=\"Woof\">{{ row.Woof }}</TD> </TR> {% endfor %} </TBODY> </TABLE>","title":"Examples"},{"location":"07-data-sources-in-docma.html#data-provider-type-file","text":"Docma can read data from static files contained within the compiled document template. The type component of the data source specification is file . The location component is the name of the file, relative to the root of the template. Handling is determined based on the file suffix. The following formats are supported: File Suffix Description csv A CSV file with a header line. The excel dialect is assumed. jsonl A file containing one JSON formatted object per line. The query component is not used.","title":"Data Provider Type: file"},{"location":"07-data-sources-in-docma.html#examples_1","text":"This example shows a CSV file being used to supply data to a chart (using Jinja tuple notation): <IMG style=\"width: 10cm; justify-self: start;\" src=\"docma:vega?{{ ( ( 'spec', 'charts/woof.yaml'), ( 'data', 'file;data/dogs.csv'), ) | urlencode }}\" > This example shows a CSV file being used to populate an HTML table: <TABLE> <THEAD> <TR> <TH>Dog</TH> <TH class=\"Woof\">Woof</TH> </TR> </THEAD> <TBODY> {% for row in docma.data('file', 'data/dogs.csv', 'queries/woof-power.yaml') %} <TR> <TD class=\"Dog\">{{ row.Dog }}</TD> <TD class=\"Woof\">{{ row.Woof }}</TD> </TR> {% endfor %} </TBODY> </TABLE> In the example above, the csv file ( data/dogs.csv ) might look something like this: Dog,Woof Bolliver,28 Rin Tin Tin,55 Fido,43 Kipper,91 Zoltan,81 Pluto,53 Scooby,24 Cerberus,87 Snoopy,52","title":"Examples"},{"location":"07-data-sources-in-docma.html#data-provider-type-lava","text":"If the lava package is installed , docma can use the lava connection subsystem to read data from a database. Lava provides support for connecting to a range of database types, including Postgres, Redshift, SQL Server, MySQL and Oracle. It also manages all of the connection details, credentials etc. The type component of the data source specification is lava . The location component is a lava connection ID for a database. The query component is the name of a query specification file. The lava realm must be specified during rendering, either by setting the LAVA_REALM environment variable, or via the --realm argument to the CLI. The query text must use a paramstyle that matches the underlying driver being used by lava. Refer to the lava user guide for more information.","title":"Data Provider Type: lava"},{"location":"07-data-sources-in-docma.html#examples_2","text":"This example shows a lava database connector (ID= redshift/prod ) being used to supply data to a chart (using Jinja tuple notation): <IMG style=\"width: 10cm;\" src=\"docma:vega?{{ ( ( 'spec', 'charts/dog-woof-power-chart.yaml' ), ( 'data', 'lava;redshift/prod;queries/woof-power.yaml' ), ) | urlencode }}\" > This example shows a lava database connector (ID= redshift/prod ) being used to populate an HTML table: <TABLE> <THEAD> <TR> <TH>Dog</TH> <TH class=\"Woof\">Woof</TH> </TR> </THEAD> <TBODY> {% for row in docma.data('lava', 'redshift/prod', 'queries/woof-power.yaml') %} <TR> <TD class=\"Dog\">{{ row.Dog }}</TD> <TD class=\"Woof\">{{ row.Woof }}</TD> </TR> {% endfor %} </TBODY> </TABLE>","title":"Examples"},{"location":"07-data-sources-in-docma.html#data-provider-type-params","text":"Docma can extract data from a list of objects in the rendering parameters. The type component of the data source specification is params . The location component is a dot separated key sequence to select a data list within the parameters. Each element of the list must be an object (not a string). The query component is not used.","title":"Data Provider Type: params"},{"location":"07-data-sources-in-docma.html#examples_3","text":"Consider the following rendering parameters: param1: value1 param2: value2 data: custard: prices: - type: lumpy price: 1.53 - type: baked price: 2.84 - type: runny price: 3.50 A data source specification of params;data.custard.prices would return the following data rows: { \"type\": \"lumpy\", \"price\": 1.53 } { \"type\": \"baked\", \"price\": 2.84 } { \"type\": \"runny\", \"price\": 3.5 } This example shows rendering parameters being used to supply data to a chart (using Jinja tuple notation): <IMG style=\"width: 10cm;\" src=\"docma:vega?{{ ( ( 'spec', 'charts/custard-prices-chart.yaml' ), ( 'data', 'params;data.custard.prices' ), ) | urlencode }}\" > This example shows rendering parameters being used to populate an HTML table: <TABLE> <THEAD> <TR> <TH>Custard Type</TH> <TH class=\"price\">Price</TH> </TR> </THEAD> <TBODY> {% for row in docma.data('params', 'data.custard.prices') %} <TR> <TD class=\"type\">{{ row.type }}</TD> <TD class=\"price\">{{ row.price }}</TD> </TR> {% endfor %} </TBODY> </TABLE>","title":"Examples"},{"location":"07-data-sources-in-docma.html#data-provider-type-postgres","text":"Docma can read data from a Postgres database. The type component of the data source specification is postgres . The location component is an alpha-numeric label for the database. This is used to determine connection details from environment variables or the contents of a .env file. If the location component is xyz , then docma will read the following values from a .env file to connect to the database. Name Description XYZ_USER Database user name XYZ_PASSWORD Password. Exactly one of XYZ_PASSWORD and XYZ_PASSWORD_PARAM must be specified. XYZ_PASSWORD_PARAM AWS SSM parameter containing the password. XYZ_HOST Host name XYZ_PORT Port number XYZ_DATABASE Database name XYZ_SSL A truthy value specifying if SSL should be enforced (default no ) Values can also be overridden by environment variables with the same names as above, prefixed with DOCMA_ . e.g. DOCMA_XYZ_USER . Take care to ensure the .env file is excluded from any GIT repo. A redacted sample is provided in the test directory. The query component is the name of a query specification file.","title":"Data Provider Type: postgres"},{"location":"07-data-sources-in-docma.html#examples_4","text":"This example shows a Postgres database being used to supply data to a chart (using Jinja tuple notation): <IMG style=\"width: 10cm;\" src=\"docma:vega?{{ ( ( 'spec', 'charts/dog-woof-power-chart.yaml' ), ( 'data', 'postgres;prod01;queries/woof-power.yaml' ), ) | urlencode }}\" > This example shows a Postgres database being used to populate an HTML table: <TABLE> <THEAD> <TR> <TH>Dog</TH> <TH class=\"Woof\">Woof</TH> </TR> </THEAD> <TBODY> {% for row in docma.data('postgres', 'prod01', 'queries/woof-power.yaml') %} <TR> <TD class=\"Dog\">{{ row.Dog }}</TD> <TD class=\"Woof\">{{ row.Woof }}</TD> </TR> {% endfor %} </TBODY> </TABLE>","title":"Examples"},{"location":"08-fonts.html","text":"Fonts This section primarily applies to PDF output documents. For HTML output documents, font handling is exactly as it is for HTML in general. Docma does not embed fonts in HTML output documents. Docma inherits the font handling capabilities of WeasyPrint , which are essentially those of native HTML / CSS. TrueType (TTF), OpenType (OTF) and Web Open Font Format (WOFF), but not WOFF2, fonts should work fine. WARNING : Fonts are Intellectual Property and may be subject to licence conditions, just like software. Take care to comply with licence terms and be aware that the font is likely to be embedded in the PDF produced by docma. Google fonts is quite a good source for royalty free fonts. Fonts installed on the base platform generally can be used directly in CSS styles. However, it is risky to rely on this beyond the most basic common font types (e.g. Sans Serif). A template that is developed and compiled on one platform may be rendered on a different platform with different fonts. It will still render, in most cases, but may not look as expected. Fonts that are not installed on the base platform can be used via @font-face CSS directives in either stand-alone style sheets or within CSS in the HTML. These specify where to find the font files and how to reference them from HTML / CSS. These fonts can be either: Placed in the docma template source directory for inclusion into the compiled template; or Imported into the document template during compilation via an import directive ; or Loaded at run-time during template rendering using standard HTML / CSS features for remote font access. Option 3 is strongly deprecated for performance reasons. Fonts Included in the Template Source A font file can be placed directly into the document template source directory. It is recommended to place fonts in the fonts sub-directory. e.g. <template-base-dir> \u2502 \u251c\u2500\u2500 ... \u251c\u2500\u2500 fonts \u2502 \u2514\u2500\u2500 my-corporate-font.ttf \u251c\u2500\u2500 ... \u2514\u2500\u2500 styles.css The font then needs to be declared in CSS. This can be in a standalone style sheet invoked via the options->stylesheets key in the template configuration file or directly within a <STYLE>...</STYLE> block in a HTML document. @font-face { font-family: 'CorpFont'; src: url(file:fonts/my-corporate-font.ttf) format('truetype'); } In docma version <= 1.9, the font-face declaration must be in the HTML document using it. In version >= 1.10, the declaration can also be in a separate style sheet (preferred). This makes the font available for use in CSS styling in the normal way. e.g. <HTML lang=\"en-us\"> <HEAD> <STYLE type=\"text/css\"> .corpfont { font-family: CorpFont, sans-serif; } </STYLE> </HEAD> <BODY> <P style=\"corpfont\"> Hello world! </P> </BODY> </HTML> Importing Fonts during Template Compilation Remote fonts can be incorporated into a document template during the compilation phase using the import directive in the template configuration file . For example, to include the Kablammo font from Google fonts, config.yaml would contain something like this: # config.yaml import: - src: https://fonts.gstatic.com/s/kablammo/v1/bWtm7fHPcgrhC-J3lcXhcQTY5Ixs6Au9YgCjjw.ttf as: fonts/kablammo.ttf options: stylesheets: - styles.css The font declaration then goes into styles.css like so: @font-face { font-family: 'Kablammo'; font-style: normal; font-weight: 400; src: url(file:fonts/kablammo.ttf) format('truetype'); } In docma version <= 1.9, the font-face declaration must be in the HTML document using it. In version >= 1.10, the declaration can also be in a separate style sheet (preferred). This makes the font available for use in CSS styling, thus: <HTML lang=\"en-us\"> <HEAD> <STYLE type=\"text/css\"> .kablammo { font-family: Kablammo, sans-serif; } </STYLE> </HEAD> <BODY> <P style=\"kablammo\"> Hello world! </P> </BODY> </HTML> Loading Fonts during Template Rendering Fonts can also be dynamically loaded at run-time during template rendering using standard HTML / CSS mechanisms. Please don't do this in a production environment. For example, the following shows two different mechanisms for incorporating the Barrio and Dokdo fonts from Google Fonts using HTML <link> and CSS @import mechanisms, respectively. <HTML lang=\"en-us\"> <HEAD> <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"> <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin> <link href=\"https://fonts.googleapis.com/css2?family=Barrio\" rel=\"stylesheet\"> <STYLE type=\"text/css\"> @import url('https://fonts.googleapis.com/css2?family=Dokdo'); .barrio { font-family: \"Barrio\", system-ui; font-weight: 400; font-style: normal; } .dokdo { font-family: \"Dokdo\", system-ui; font-weight: 400; font-style: normal; } </STYLE> </HEAD> <BODY> <P class=\"barrio\"> Hello world! </P> <P class=\"dokdo\"> Hello world! </P> </BODY> </HTML>","title":"Fonts"},{"location":"08-fonts.html#fonts","text":"This section primarily applies to PDF output documents. For HTML output documents, font handling is exactly as it is for HTML in general. Docma does not embed fonts in HTML output documents. Docma inherits the font handling capabilities of WeasyPrint , which are essentially those of native HTML / CSS. TrueType (TTF), OpenType (OTF) and Web Open Font Format (WOFF), but not WOFF2, fonts should work fine. WARNING : Fonts are Intellectual Property and may be subject to licence conditions, just like software. Take care to comply with licence terms and be aware that the font is likely to be embedded in the PDF produced by docma. Google fonts is quite a good source for royalty free fonts. Fonts installed on the base platform generally can be used directly in CSS styles. However, it is risky to rely on this beyond the most basic common font types (e.g. Sans Serif). A template that is developed and compiled on one platform may be rendered on a different platform with different fonts. It will still render, in most cases, but may not look as expected. Fonts that are not installed on the base platform can be used via @font-face CSS directives in either stand-alone style sheets or within CSS in the HTML. These specify where to find the font files and how to reference them from HTML / CSS. These fonts can be either: Placed in the docma template source directory for inclusion into the compiled template; or Imported into the document template during compilation via an import directive ; or Loaded at run-time during template rendering using standard HTML / CSS features for remote font access. Option 3 is strongly deprecated for performance reasons.","title":"Fonts"},{"location":"08-fonts.html#fonts-included-in-the-template-source","text":"A font file can be placed directly into the document template source directory. It is recommended to place fonts in the fonts sub-directory. e.g. <template-base-dir> \u2502 \u251c\u2500\u2500 ... \u251c\u2500\u2500 fonts \u2502 \u2514\u2500\u2500 my-corporate-font.ttf \u251c\u2500\u2500 ... \u2514\u2500\u2500 styles.css The font then needs to be declared in CSS. This can be in a standalone style sheet invoked via the options->stylesheets key in the template configuration file or directly within a <STYLE>...</STYLE> block in a HTML document. @font-face { font-family: 'CorpFont'; src: url(file:fonts/my-corporate-font.ttf) format('truetype'); } In docma version <= 1.9, the font-face declaration must be in the HTML document using it. In version >= 1.10, the declaration can also be in a separate style sheet (preferred). This makes the font available for use in CSS styling in the normal way. e.g. <HTML lang=\"en-us\"> <HEAD> <STYLE type=\"text/css\"> .corpfont { font-family: CorpFont, sans-serif; } </STYLE> </HEAD> <BODY> <P style=\"corpfont\"> Hello world! </P> </BODY> </HTML>","title":"Fonts Included in the Template Source"},{"location":"08-fonts.html#importing-fonts-during-template-compilation","text":"Remote fonts can be incorporated into a document template during the compilation phase using the import directive in the template configuration file . For example, to include the Kablammo font from Google fonts, config.yaml would contain something like this: # config.yaml import: - src: https://fonts.gstatic.com/s/kablammo/v1/bWtm7fHPcgrhC-J3lcXhcQTY5Ixs6Au9YgCjjw.ttf as: fonts/kablammo.ttf options: stylesheets: - styles.css The font declaration then goes into styles.css like so: @font-face { font-family: 'Kablammo'; font-style: normal; font-weight: 400; src: url(file:fonts/kablammo.ttf) format('truetype'); } In docma version <= 1.9, the font-face declaration must be in the HTML document using it. In version >= 1.10, the declaration can also be in a separate style sheet (preferred). This makes the font available for use in CSS styling, thus: <HTML lang=\"en-us\"> <HEAD> <STYLE type=\"text/css\"> .kablammo { font-family: Kablammo, sans-serif; } </STYLE> </HEAD> <BODY> <P style=\"kablammo\"> Hello world! </P> </BODY> </HTML>","title":"Importing Fonts during Template Compilation"},{"location":"08-fonts.html#loading-fonts-during-template-rendering","text":"Fonts can also be dynamically loaded at run-time during template rendering using standard HTML / CSS mechanisms. Please don't do this in a production environment. For example, the following shows two different mechanisms for incorporating the Barrio and Dokdo fonts from Google Fonts using HTML <link> and CSS @import mechanisms, respectively. <HTML lang=\"en-us\"> <HEAD> <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"> <link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin> <link href=\"https://fonts.googleapis.com/css2?family=Barrio\" rel=\"stylesheet\"> <STYLE type=\"text/css\"> @import url('https://fonts.googleapis.com/css2?family=Dokdo'); .barrio { font-family: \"Barrio\", system-ui; font-weight: 400; font-style: normal; } .dokdo { font-family: \"Dokdo\", system-ui; font-weight: 400; font-style: normal; } </STYLE> </HEAD> <BODY> <P class=\"barrio\"> Hello world! </P> <P class=\"dokdo\"> Hello world! </P> </BODY> </HTML>","title":"Loading Fonts during Template Rendering"},{"location":"09-installation-and-usage.html","text":"Installation and Usage TL;DR First install the prerequisites then ... pip install docma # Optionally, add duckdb and lava support pip install 'docma[duckdb]' pip install 'docma[lava]' # Check docma installed ok docma --help # Create our first docma template. This is a working basic template. docma new my-template # Compile it docma compile -i my-template -t my-template.zip # Render it to PDF. docma pdf -t my-template.zip -o my-doc.pdf Prerequisites General Python3.11+ is required. Mac On Mac OS, GTK is required for the HTML to PDF process. brew install gtk+ If DuckDB data sources are used, install the DuckDB CLI. brew install duckdb Linux On Linux, Pango is required for the HTML to PDF process. If DuckDB data sources are used, install the DuckDB CLI . The Python API will be installed automatically when docma is installed. To build the user guide, Pandoc is required. Follow the Pandoc installation instructions . DOS Docma might work on DOS. How would I know? Why would I care? I guess you could try WSL 2. If you do, please let us know. Installing Docma Installing with Pip Basic install: pip install docma This will install the base docma Python package and the docma CLI. This will not install support for duckdb or lava data providers. To install support for the duckdb data provider: pip install 'docma[duckdb]' To install support for the lava data provider: pip install 'docma[lava]' Installing from the Repo Clone the docma repo. The rest of the setup is handled by the Makefile. # Create venv and install the required Python packages make init # Activate the virtual environment source venv/bin/activate To run the docma CLI directly from the repo: python3 -m docma.cli.docma --help To build docma, use the Makefile. # See what we can build ... make # ... or .... make help To build an install bundle: make pkg Docker The repo includes support for building a docker container on an Amazon Linux 2023 base with docma installed. To build the image: make docker This will include support for the duckdb data provider, but not the lava data provider. The basic image doesn't add any fonts to the minimal set already available in the Amazon Linux 2023 image. To add fonts, build your own image on the docma base image. The Docma CLI The docma CLI provides everything required to compile and render document templates. # Get help docma --help It supports the following sub-commands. Command Description compile Compile a source directory into a document template. html Render a document template to PDF. html-batch Render a batch of HTML documents from a single document template. info Print information about a document template. new Create a new docma template source directory. pdf Render a document template to PDF. pdf-batch Render a batch of PDF documents from a single document template. Each sub-command has its own help: docma compile --help A typical usage sequence might be: # First create the source for the document template in its own directory docma new my-template # Add content, configuration etc. Then ... # Compile docma compile -i my-template -t my-template.zip # Render to PDF docma pdf -t my-template.zip -o my-doc.pdf --file parameters.yaml # Render to HTML docma html -t my-template.zip -o my-doc.pdf --file parameters.yaml Creating a New Document Template To create a new docma template directory: docma new <DIRECTORY> This will prompt the user to enter a small number of configuration parameters. They are all mandatory. Do not leave anything blank. The specified directory will now contain a very simple, but complete, document template source directory that can be compiled and rendered: docma compile -i <DIRECTORY> -t my-template.zip docma pdf -t my-template.zip -o my-doc.pdf Docma Python API The API is quite basic: from docma import compile_template, render_template_to_pdf template_src_dir = 'a/b/c' template_location = 'my-template.zip' # ... or a directory when experimenting pdf_location = 'my-doc.pdf' params = {...} # A Dict of parameters. compile_template(template_src_dir, template_location) pdf = render_template_to_pdf(template_location, params) # We now have a pypdf PdfWriter object. Do with it what you will. e.g. pdf.write(pdf_location) Refer to the API documentation for more information. Building the Documentation Docma comes with this user guide and auto-generated API documentation. To build the user guide, Pandoc is required. For mac OS: brew install pandoc To build the documentation: make doc The generated documentation is placed in the dist/doc directory. On mac OS: # Open the user guide open -a Safari dist/doc/docma-user-guide.site/index.html # Open the API doc open -a Safari dist/doc/api/_build/html/index.html By default, the user guide is generated in multi-page HTML, markdown and EPUB formats. To also generate Microsoft Word (docx) and single page HTML, edit this line in doc/Makefile to add docx and html : # FORMATS=md docx epub html site FORMATS=md site epub To edit the documentation, ensure that a spell check is done as part of the process using: make spell This requires the aspell tool. For mac OS: brew install aspell Running Unit Tests The unit tests require some docker based components (Postgres, web server etc.) to be up and running. These require a .env file containing credentials for test accounts etc. In the main directory, copy dot-env-sample to .env and edit it to add passwords in the indicated spots. The values don't really matter as the accounts will be created as part of each test session. Even so, do not add .env to the repo. It's bad form. To run the tests: # Start the docker components. This will take a while on first invocation as it # needs to download base images and build some stuff on them. make up # Run tests make test # Get a coverage report make coverage # Check the coverage report (on a Mac) open -a Safari dist/test/htmlcov/index.html # Stop the docker components when done make down Extending Docma Docma has a number of plugable interfaces to allow extension. The process works by placing a Python file in the appropriate directory in the code base, unless otherwise indicated. These are automatically discovered as required. Content Importers Content importers operate during the docma compile phase. They collect components from external sources and inject them into the compilation process. Imported components are referenced via a URL scheme://.... . The scheme is used to select the importer to be used. To create a new importer, add a new Python file into docma/importers . It will contain a decorated function that has a signature like so: @content_importer('http', 'https') def _(uri: str, max_size: int = 0) -> bytes: \"\"\"Get an object from the web.\"\"\" ... Content Compilers Content compilers operate during the docma compile phase. They transform a source format into HTML. The source format is determined by the filename suffix. To create a new compiler, add a new Python file into docma/compilers . It will contain a decorated function that has a signature like so: @content_compiler('xyz') def _(src_data: bytes) -> str: \"\"\"Compile xyz source files into HTML.\"\"\" return ... URL Fetchers URL fetchers operate during the docma render phase. They provide WeasyPrint with the means to resolve URLs within the HTML being converted to PDF. URL fetchers are selected based on the scheme of the URL. To create a new URL fetcher, add a new Python file into docma/fetchers . For example, to handle URLs of the form xyz://.... , the new file will have a function with a signature like so: @fetcher('xyz') def _(purl: ParseResult, context: DocmaRenderContext) -> dict[str, Any]: \"\"\" Fetch xyz:... URLs for WeasyPrint. :param purl: A parsed URL. See urllib.parse.urlparse(). :param context: Document rendering context. :return: A dict containing the URL content and mime type. \"\"\" ... return { 'string': ..., # This is named `string` but must be a bytestring. 'mime_type': ... } Content Generators Content generators operate during the docma render phase. They dynamically generate content for WeasyPrint when a URL in the following form is accessed. docma:<generator-name>?<generator-params> They are typically used for generating image content (charts, QR codes etc.) but they can be used wherever URLs return content to WeasyPrint. To create a new content generator, add a new Python file into docma/generators . Start by copying the sample swatch.py generator and modifying as required. Data Providers Data providers operate during the docma render phase. The data provider handler is selected by the type component of a data source specification . To create a new data provider, add a new Python file into docma/data_providers . Start by copying one of the existing providers and modify as needed. Format Checkers Docma has a number of custom format checkers that serve a dual role as JSON Schema string formats and custom Jinja tests. These are implemented using a simple plugin mechanism. Read the docstring at the top of docma/lib/plugin.py before launching into it. To create a new format checker, add a new Python file into docma/plugins/format_checkers . Start by copying one of the existing checkers. Checkers can be grouped together in families (e.g. the au.* suite) using nested Python packages (directories containing __init__.py ). The discovery and loading process is automatic. Each checker is basically a decorated function with a single parameter, being the string value to be checked, and must return a boolean indicating whether it conforms to the required format, or not. It is also possible to have checkers with names generated dynamically at run-time. Tricky. Don't start here on day one but check out the DateFormatResolver class in docma/jinja/resolvers.py if the fever is upon you. Resolvers are not automatically discovered. Custom Jinja Filters Docma has a number of custom Jinja filters . These are implemented using a simple plugin mechanism. Read the docstring at the top of docma/lib/plugin.py before launching into it. To create a new format checker, add a new Python file into docma/plugins/jinja_filters . Start by copying one of the existing filters. Checkers can be grouped together in families (e.g. the au.* suite) using nested Python packages (directories containing __init__.py ). The discovery and loading process is automatic. It is also possible to have filters with names generated dynamically at run-time. For example, the currency filters work this way. Tricky. Don't start here on day one but check out the CurrencyFilterResolver class in docma/jinja/resolvers.py if inspiration strikes. Resolvers are not automatically discovered. Custom Jinja Tests Docma does not currently provide any custom Jinja tests, other than custom format checkers which are kept separate because they server both Jinja and JSON Schema. Unlike custom format checkers , custom tests can be written to accept arguments additional to the value being tested. All of the scaffolding required to add custom Jinja tests is present. The mechanism is the same as used for adding custom jinja filters except that the required decorator is @jtest instead of @jfilter and they should be placed in docma/plugins/jinja_tests instead of docma/plugins/jinja_filters . The discovery and loading process is automatic. Custom Jinja Extensions Docma has a number of custom Jinja extensions . These are all contained in the file docma/jinja/extensions.py . New ones can be added to this file but if you think you need to, think again.","title":"Installation and Usage"},{"location":"09-installation-and-usage.html#installation-and-usage","text":"","title":"Installation and Usage"},{"location":"09-installation-and-usage.html#tldr","text":"First install the prerequisites then ... pip install docma # Optionally, add duckdb and lava support pip install 'docma[duckdb]' pip install 'docma[lava]' # Check docma installed ok docma --help # Create our first docma template. This is a working basic template. docma new my-template # Compile it docma compile -i my-template -t my-template.zip # Render it to PDF. docma pdf -t my-template.zip -o my-doc.pdf","title":"TL;DR"},{"location":"09-installation-and-usage.html#prerequisites","text":"","title":"Prerequisites"},{"location":"09-installation-and-usage.html#general","text":"Python3.11+ is required.","title":"General"},{"location":"09-installation-and-usage.html#mac","text":"On Mac OS, GTK is required for the HTML to PDF process. brew install gtk+ If DuckDB data sources are used, install the DuckDB CLI. brew install duckdb","title":"Mac"},{"location":"09-installation-and-usage.html#linux","text":"On Linux, Pango is required for the HTML to PDF process. If DuckDB data sources are used, install the DuckDB CLI . The Python API will be installed automatically when docma is installed. To build the user guide, Pandoc is required. Follow the Pandoc installation instructions .","title":"Linux"},{"location":"09-installation-and-usage.html#dos","text":"Docma might work on DOS. How would I know? Why would I care? I guess you could try WSL 2. If you do, please let us know.","title":"DOS"},{"location":"09-installation-and-usage.html#installing-docma","text":"","title":"Installing Docma"},{"location":"09-installation-and-usage.html#installing-with-pip","text":"Basic install: pip install docma This will install the base docma Python package and the docma CLI. This will not install support for duckdb or lava data providers. To install support for the duckdb data provider: pip install 'docma[duckdb]' To install support for the lava data provider: pip install 'docma[lava]'","title":"Installing with Pip"},{"location":"09-installation-and-usage.html#installing-from-the-repo","text":"Clone the docma repo. The rest of the setup is handled by the Makefile. # Create venv and install the required Python packages make init # Activate the virtual environment source venv/bin/activate To run the docma CLI directly from the repo: python3 -m docma.cli.docma --help To build docma, use the Makefile. # See what we can build ... make # ... or .... make help To build an install bundle: make pkg","title":"Installing from the Repo"},{"location":"09-installation-and-usage.html#docker","text":"The repo includes support for building a docker container on an Amazon Linux 2023 base with docma installed. To build the image: make docker This will include support for the duckdb data provider, but not the lava data provider. The basic image doesn't add any fonts to the minimal set already available in the Amazon Linux 2023 image. To add fonts, build your own image on the docma base image.","title":"Docker"},{"location":"09-installation-and-usage.html#the-docma-cli","text":"The docma CLI provides everything required to compile and render document templates. # Get help docma --help It supports the following sub-commands. Command Description compile Compile a source directory into a document template. html Render a document template to PDF. html-batch Render a batch of HTML documents from a single document template. info Print information about a document template. new Create a new docma template source directory. pdf Render a document template to PDF. pdf-batch Render a batch of PDF documents from a single document template. Each sub-command has its own help: docma compile --help A typical usage sequence might be: # First create the source for the document template in its own directory docma new my-template # Add content, configuration etc. Then ... # Compile docma compile -i my-template -t my-template.zip # Render to PDF docma pdf -t my-template.zip -o my-doc.pdf --file parameters.yaml # Render to HTML docma html -t my-template.zip -o my-doc.pdf --file parameters.yaml","title":"The Docma CLI"},{"location":"09-installation-and-usage.html#creating-a-new-document-template","text":"To create a new docma template directory: docma new <DIRECTORY> This will prompt the user to enter a small number of configuration parameters. They are all mandatory. Do not leave anything blank. The specified directory will now contain a very simple, but complete, document template source directory that can be compiled and rendered: docma compile -i <DIRECTORY> -t my-template.zip docma pdf -t my-template.zip -o my-doc.pdf","title":"Creating a New Document Template"},{"location":"09-installation-and-usage.html#docma-python-api","text":"The API is quite basic: from docma import compile_template, render_template_to_pdf template_src_dir = 'a/b/c' template_location = 'my-template.zip' # ... or a directory when experimenting pdf_location = 'my-doc.pdf' params = {...} # A Dict of parameters. compile_template(template_src_dir, template_location) pdf = render_template_to_pdf(template_location, params) # We now have a pypdf PdfWriter object. Do with it what you will. e.g. pdf.write(pdf_location) Refer to the API documentation for more information.","title":"Docma Python API"},{"location":"09-installation-and-usage.html#building-the-documentation","text":"Docma comes with this user guide and auto-generated API documentation. To build the user guide, Pandoc is required. For mac OS: brew install pandoc To build the documentation: make doc The generated documentation is placed in the dist/doc directory. On mac OS: # Open the user guide open -a Safari dist/doc/docma-user-guide.site/index.html # Open the API doc open -a Safari dist/doc/api/_build/html/index.html By default, the user guide is generated in multi-page HTML, markdown and EPUB formats. To also generate Microsoft Word (docx) and single page HTML, edit this line in doc/Makefile to add docx and html : # FORMATS=md docx epub html site FORMATS=md site epub To edit the documentation, ensure that a spell check is done as part of the process using: make spell This requires the aspell tool. For mac OS: brew install aspell","title":"Building the Documentation"},{"location":"09-installation-and-usage.html#running-unit-tests","text":"The unit tests require some docker based components (Postgres, web server etc.) to be up and running. These require a .env file containing credentials for test accounts etc. In the main directory, copy dot-env-sample to .env and edit it to add passwords in the indicated spots. The values don't really matter as the accounts will be created as part of each test session. Even so, do not add .env to the repo. It's bad form. To run the tests: # Start the docker components. This will take a while on first invocation as it # needs to download base images and build some stuff on them. make up # Run tests make test # Get a coverage report make coverage # Check the coverage report (on a Mac) open -a Safari dist/test/htmlcov/index.html # Stop the docker components when done make down","title":"Running Unit Tests"},{"location":"09-installation-and-usage.html#extending-docma","text":"Docma has a number of plugable interfaces to allow extension. The process works by placing a Python file in the appropriate directory in the code base, unless otherwise indicated. These are automatically discovered as required.","title":"Extending Docma"},{"location":"09-installation-and-usage.html#content-importers","text":"Content importers operate during the docma compile phase. They collect components from external sources and inject them into the compilation process. Imported components are referenced via a URL scheme://.... . The scheme is used to select the importer to be used. To create a new importer, add a new Python file into docma/importers . It will contain a decorated function that has a signature like so: @content_importer('http', 'https') def _(uri: str, max_size: int = 0) -> bytes: \"\"\"Get an object from the web.\"\"\" ...","title":"Content Importers"},{"location":"09-installation-and-usage.html#content-compilers","text":"Content compilers operate during the docma compile phase. They transform a source format into HTML. The source format is determined by the filename suffix. To create a new compiler, add a new Python file into docma/compilers . It will contain a decorated function that has a signature like so: @content_compiler('xyz') def _(src_data: bytes) -> str: \"\"\"Compile xyz source files into HTML.\"\"\" return ...","title":"Content Compilers"},{"location":"09-installation-and-usage.html#url-fetchers","text":"URL fetchers operate during the docma render phase. They provide WeasyPrint with the means to resolve URLs within the HTML being converted to PDF. URL fetchers are selected based on the scheme of the URL. To create a new URL fetcher, add a new Python file into docma/fetchers . For example, to handle URLs of the form xyz://.... , the new file will have a function with a signature like so: @fetcher('xyz') def _(purl: ParseResult, context: DocmaRenderContext) -> dict[str, Any]: \"\"\" Fetch xyz:... URLs for WeasyPrint. :param purl: A parsed URL. See urllib.parse.urlparse(). :param context: Document rendering context. :return: A dict containing the URL content and mime type. \"\"\" ... return { 'string': ..., # This is named `string` but must be a bytestring. 'mime_type': ... }","title":"URL Fetchers"},{"location":"09-installation-and-usage.html#content-generators","text":"Content generators operate during the docma render phase. They dynamically generate content for WeasyPrint when a URL in the following form is accessed. docma:<generator-name>?<generator-params> They are typically used for generating image content (charts, QR codes etc.) but they can be used wherever URLs return content to WeasyPrint. To create a new content generator, add a new Python file into docma/generators . Start by copying the sample swatch.py generator and modifying as required.","title":"Content Generators"},{"location":"09-installation-and-usage.html#data-providers","text":"Data providers operate during the docma render phase. The data provider handler is selected by the type component of a data source specification . To create a new data provider, add a new Python file into docma/data_providers . Start by copying one of the existing providers and modify as needed.","title":"Data Providers"},{"location":"09-installation-and-usage.html#format-checkers","text":"Docma has a number of custom format checkers that serve a dual role as JSON Schema string formats and custom Jinja tests. These are implemented using a simple plugin mechanism. Read the docstring at the top of docma/lib/plugin.py before launching into it. To create a new format checker, add a new Python file into docma/plugins/format_checkers . Start by copying one of the existing checkers. Checkers can be grouped together in families (e.g. the au.* suite) using nested Python packages (directories containing __init__.py ). The discovery and loading process is automatic. Each checker is basically a decorated function with a single parameter, being the string value to be checked, and must return a boolean indicating whether it conforms to the required format, or not. It is also possible to have checkers with names generated dynamically at run-time. Tricky. Don't start here on day one but check out the DateFormatResolver class in docma/jinja/resolvers.py if the fever is upon you. Resolvers are not automatically discovered.","title":"Format Checkers"},{"location":"09-installation-and-usage.html#custom-jinja-filters","text":"Docma has a number of custom Jinja filters . These are implemented using a simple plugin mechanism. Read the docstring at the top of docma/lib/plugin.py before launching into it. To create a new format checker, add a new Python file into docma/plugins/jinja_filters . Start by copying one of the existing filters. Checkers can be grouped together in families (e.g. the au.* suite) using nested Python packages (directories containing __init__.py ). The discovery and loading process is automatic. It is also possible to have filters with names generated dynamically at run-time. For example, the currency filters work this way. Tricky. Don't start here on day one but check out the CurrencyFilterResolver class in docma/jinja/resolvers.py if inspiration strikes. Resolvers are not automatically discovered.","title":"Custom Jinja Filters"},{"location":"09-installation-and-usage.html#custom-jinja-tests","text":"Docma does not currently provide any custom Jinja tests, other than custom format checkers which are kept separate because they server both Jinja and JSON Schema. Unlike custom format checkers , custom tests can be written to accept arguments additional to the value being tested. All of the scaffolding required to add custom Jinja tests is present. The mechanism is the same as used for adding custom jinja filters except that the required decorator is @jtest instead of @jfilter and they should be placed in docma/plugins/jinja_tests instead of docma/plugins/jinja_filters . The discovery and loading process is automatic.","title":"Custom Jinja Tests"},{"location":"09-installation-and-usage.html#custom-jinja-extensions","text":"Docma has a number of custom Jinja extensions . These are all contained in the file docma/jinja/extensions.py . New ones can be added to this file but if you think you need to, think again.","title":"Custom Jinja Extensions"},{"location":"10-caveats-and-known-issues.html","text":"Caveats and Known Issues Docma does not try particularly hard to be parsimonious with memory usage. Docma does pool database connections, but the approach to doing this is fairly naive and may need to be revisited for higher volumes. Watch out for HTML authoring systems that leave Jinja-like fragments behind. These will clash with docma's use of Jinja and will generally need to be removed. WeasyPrint suppresses some errors when rendering HTML and tries hard to produce something. This is unfortunate. In docma, it would have been preferable to fail if rendering fails to avoid an incomplete document. Internal document links within the rendered PDF don't work.","title":"Caveats and Known Issues"},{"location":"10-caveats-and-known-issues.html#caveats-and-known-issues","text":"Docma does not try particularly hard to be parsimonious with memory usage. Docma does pool database connections, but the approach to doing this is fairly naive and may need to be revisited for higher volumes. Watch out for HTML authoring systems that leave Jinja-like fragments behind. These will clash with docma's use of Jinja and will generally need to be removed. WeasyPrint suppresses some errors when rendering HTML and tries hard to produce something. This is unfortunate. In docma, it would have been preferable to fail if rendering fails to avoid an incomplete document. Internal document links within the rendered PDF don't work.","title":"Caveats and Known Issues"},{"location":"11-credits.html","text":"Credits Thanks to MenaG for inspiring this idea in the first place. Thanks to Alex Boul, and Art Dorokhov for contributing to docma . Docma is possible because of these amazing Python packages: WeasyPrint Jinja2 Vega-Altair PyPDF Honourable mentions: Babel Phonenumbers","title":"Credits"},{"location":"11-credits.html#credits","text":"Thanks to MenaG for inspiring this idea in the first place. Thanks to Alex Boul, and Art Dorokhov for contributing to docma . Docma is possible because of these amazing Python packages: WeasyPrint Jinja2 Vega-Altair PyPDF Honourable mentions: Babel Phonenumbers","title":"Credits"},{"location":"12-release-notes.html","text":"Release Notes Version 2 Version 2.2.0 The Jinja subsystem has been refactored substantially (backward compatible). Changes include: Region specific filters are now named with the 2 character ISO country code as a prefix. e.g. au.ABN replaces abn and au.ACN replaces acn . Using the old forms will still work but produces a deprecation warning. Adding new generic and region specific filters has been simplified. Docma templates now support locales . A locale is a string such as en_AU , fr_CA , etc and can influence the behaviour of things such as Jinja filters . The names of docma custom Jinja filters, Jinja tests and format checkers are case insensitive. The following Jinja filters have been added for use in document templates. These are all locale / region aware. Credit to the Babel and phonenumbers packages for making this possible. All of the filters come with sensible defaults. The Babel based filters in particular provide a high degree of control over formatting using the Locale Data Markup Language specification (LDML) if the defaults don't suit. phone formats international phone numbers. currency formats international currencies. This also provides support for currency specific filters such as AUD , EUR , GBP for a wide range of currencies. The older dollars filter is still supported but discouraged (not deprecated, as such). decimal and compact_decimal format numbers using locale specific conventions. percent formats percentages using locale specific conventions. date , datetime , time and timedelta format datetime elements using locale specific conventions. parse_date and parse_time parse dates and times into the appropriate Python objects using locale specific conventions. A new suite of format checkers has been introduced. These serve the dual purpose of being available as format entries for string objects in JSON Schema specifications as well as custom Jinja tests. The following changes have been made to the docma new command used to create a new document template: Some basic validation has been added to user input values. The default locale for the template must now be specified. The docma.format rendering parameter has been added to indicate the type of output document being produced, HTML or PDF . Some minor improvements in error messages for database related errors have been made. (Credit MN.) Added the make count target to count lines of code, doc, stuff. Why not? Version 2.1.0 This is the open source base release. Changes from v2.0.0 are: Updated CLI install approach. Incremental increase in test coverage. Editorial changes in the user guide. Docker build switched to buildkit. The size limit on imported documents has been increased from 5MB to 10MB.","title":"Release Notes"},{"location":"12-release-notes.html#release-notes","text":"","title":"Release Notes"},{"location":"12-release-notes.html#version-2","text":"","title":"Version 2"},{"location":"12-release-notes.html#version-220","text":"The Jinja subsystem has been refactored substantially (backward compatible). Changes include: Region specific filters are now named with the 2 character ISO country code as a prefix. e.g. au.ABN replaces abn and au.ACN replaces acn . Using the old forms will still work but produces a deprecation warning. Adding new generic and region specific filters has been simplified. Docma templates now support locales . A locale is a string such as en_AU , fr_CA , etc and can influence the behaviour of things such as Jinja filters . The names of docma custom Jinja filters, Jinja tests and format checkers are case insensitive. The following Jinja filters have been added for use in document templates. These are all locale / region aware. Credit to the Babel and phonenumbers packages for making this possible. All of the filters come with sensible defaults. The Babel based filters in particular provide a high degree of control over formatting using the Locale Data Markup Language specification (LDML) if the defaults don't suit. phone formats international phone numbers. currency formats international currencies. This also provides support for currency specific filters such as AUD , EUR , GBP for a wide range of currencies. The older dollars filter is still supported but discouraged (not deprecated, as such). decimal and compact_decimal format numbers using locale specific conventions. percent formats percentages using locale specific conventions. date , datetime , time and timedelta format datetime elements using locale specific conventions. parse_date and parse_time parse dates and times into the appropriate Python objects using locale specific conventions. A new suite of format checkers has been introduced. These serve the dual purpose of being available as format entries for string objects in JSON Schema specifications as well as custom Jinja tests. The following changes have been made to the docma new command used to create a new document template: Some basic validation has been added to user input values. The default locale for the template must now be specified. The docma.format rendering parameter has been added to indicate the type of output document being produced, HTML or PDF . Some minor improvements in error messages for database related errors have been made. (Credit MN.) Added the make count target to count lines of code, doc, stuff. Why not?","title":"Version 2.2.0"},{"location":"12-release-notes.html#version-210","text":"This is the open source base release. Changes from v2.0.0 are: Updated CLI install approach. Incremental increase in test coverage. Editorial changes in the user guide. Docker build switched to buildkit. The size limit on imported documents has been increased from 5MB to 10MB.","title":"Version 2.1.0"}]}