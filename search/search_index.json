{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Docma User Guide","text":""},{"location":"index.html#version-220","title":"Version 2.2.0","text":"<p>Docma is a PDF document generator that can assemble and compose PDF and HTML documents from document templates with dynamic content.</p> <p>Docma was developed at Origin Energy as part of the Jindabyne initiative. While not part of our core IP, it proved valuable internally, and we're sharing it in the hope it's useful to others.</p> <p>Kudos to Origin for fostering a culture that empowers its people to build complex technology solutions in-house.</p>"},{"location":"01-overview.html","title":"Overview","text":"<p>Docma was developed at Origin Energy as part of the Jindabyne initiative. While not part of our core IP, it proved valuable internally, and we're sharing it in the hope it's useful to others.</p> <p>Kudos to Origin for fostering a culture that empowers its people to build complex technology solutions in-house.</p> <p>Docma is a PDF document generator that can assemble and compose PDF and self-contained HTML documents from document templates with dynamic content.</p> <p>Features include:</p> <ul> <li>PDF document generation with source content defined in any combination of     HTML and PDF.</li> <li>HTML document generation from source content in HTML.</li> <li>Compilation of Markdown source content into HTML</li> <li>Dynamic content preparation (conditionals, loops, transformation etc.) based     on structured data parameters fed to the rendering process at run-time.</li> <li>Dynamic content injection from multiple data sources, including live     database connections.</li> <li>Composition of multiple source documents into a single PDF or HTML output.</li> <li>Conditional inclusion of component documents based on parameter based      conditions evaluated at run-time.</li> <li>Deep schema validation of structured data parameters at run-time.</li> <li>Watermarking / stamping of PDF output.</li> <li>Dynamic generation of charts via the Vega-Lite specification with multiple data     sources, including live database connections.</li> <li>Extensible interfaces for content assembly, dynamic content     generation and data access.</li> <li>Locale support for content such as numbers, currencies, phone numbers etc.</li> </ul>"},{"location":"02-document-creation.html","title":"Document Creation","text":"<p>The docma document creation process consists of these steps:</p> <ol> <li> <p>Document template creation: The template content is     contained in a directory dedicated to a single template. It contains the     static content (e.g. HTML, PDF, Markdown and image files) as well as YAML     formatted metadata files that control the rendering process, database access     etc.</p> </li> <li> <p>Template compilation: The compilation process     validates the template content, converts supported non-HTML content (e.g.     Markdown files) into HTML and generates a compiled template package     in either a directory or ZIP file.</p> </li> <li> <p>Template rendering: The rendering process     uses Jinja to inject run-time parameters into the HTML template content,     converts the component documents to PDF, if required, and composes all of     the components into a single output PDF or standalone HTML document.</p> </li> </ol> <p></p>"},{"location":"03-document-templates.html","title":"Document Templates","text":"<p>The source directory for a document template should be created using the docma CLI:</p> <pre><code>docma new &lt;DIRECTORY&gt;\n</code></pre> <p>The resulting directory is structured thus:</p> <pre><code>&lt;DIRECTORY&gt;/\n\u251c\u2500\u2500 config.yaml    ... Mandatory\n\u251c\u2500\u2500 charts/        ... Specification files for charts\n\u251c\u2500\u2500 content/       ... Document content (HTML, PDF, Markdown etc.)\n\u251c\u2500\u2500 data/          ... Data files (e.g CSV / JSONL files)\n\u251c\u2500\u2500 fonts/         ... Font files (e.g. .ttf files)\n\u251c\u2500\u2500 overlays/      ... Overlay content files (Typically HTML or PDF)\n\u251c\u2500\u2500 queries/       ... Query specifications used for charts\n\u2514\u2500\u2500 resources/     ... HTML resources (image files etc.)\n</code></pre> <p>Only the <code>config.yaml</code> file is mandated. While the other components can be present, or not, as required, and directory structure is arbitrary, it is strongly recommended to adhere to the layout shown above.</p> <p>Info</p> <p>Files and directories in the template source directory matching <code>.*</code> are not copied into the compiled template.</p>"},{"location":"03-document-templates.html#template-configuration-file","title":"Template Configuration File","text":"<p>The document template configuration file, <code>config.yaml</code>, is critical to the setup and operation of a docma template. The structure of the configuration file is validated during template compilation. It contains the following elements.</p> Key Type Required Description id string Yes Template identifier. This must be at least 3 chars long, start with an alpha, end with an alphanumeric and contain only alpha-numerics and <code>+-_=</code> characters. description string Yes Template description. owner string Yes Template owner. version string Yes Template version. Must be in the form major.minor.patch (e.g. <code>1.0.0</code>). documents list Yes A list of document references to be included in the specified order in the output document. overlays object No Document overlay specifications to enable watermarking / stamping of the output document (PDF only). See Watermarking below. imports list No A list of specifications for external files to include during compilation. See Document Imports below. parameters object No Contains optional keys <code>defaults</code> and <code>schema</code>. -&gt; defaults object No Default values for rendering parameters. -&gt; schema object No A JSON Schema for the rendering parameters. See Docma Parameter Validation. options object No Options passed to the WeasyPrint PDF generator. See WeasyPrint Options. -&gt; stylesheets list No A list of CSS style sheet files that will be fed to the PDF generator. See CSS Style Sheets below. metadata object No Values to be added to the output document metadata. See Document Metadata below. -&gt; author string No Document author. -&gt; title string No Document title. -&gt; subject string No Document subject. -&gt; keywords string | list No A string of semi-colon separated keywords or a list of keywords for the PDF. <p>Note</p> <p>Prior to docma v2.0, metadata fields were specified in the PDF convention of <code>/Author</code> instead of <code>author</code>. This is still supported for backward compatibility but the naming shown above should now be used. Docma will use the appropriate conventions for PDF and HTML when producing output.</p>"},{"location":"03-document-templates.html#document-references","title":"Document References","text":"<p>The <code>documents</code> key in the configuration file is a list of component documents that will be rendered and assembled into the final output document.</p> <p>Each element in the document list can be either a string containing the name of a content file or an object containing the following keys:</p> Key Type Required Description src string Yes Name of a content file. if string No A string that will be Jinja rendered with the run-time parameters and evaluated as a truthy value. If the value is true (the default), the document is included. Truthy true values are  <code>true</code> / <code>t</code> / <code>y</code> / <code>yes</code> and non-zero integers. Truthy false values are <code>false</code> / <code>f</code> / <code>no</code> / <code>n</code> and zero and empty strings. <p>Content files must be of one of the following types:</p> <ul> <li>HTML (<code>*.html</code> / <code>*.htm</code>)</li> <li>PDF (<code>*.pdf</code>) (for PDF output documents only)</li> </ul> <p>Content files can (and generally should) be contained within the template source directory hierarchy. The file is referenced by its path relative to the template source base directory.</p> <p>Content files can also be remote and will be loaded dynamically during the rendering process. This differs from document imports which incorporate the document into the template during template compilation. For remote content files, any of the forms supported by the importer subsystem can be used. e.g.</p> <ul> <li><code>http(s)://host/some/path/...</code></li> <li><code>s3://bucket/some/path/...</code></li> </ul> <p>Unlike imports, dynamically referenced content documents must be in HTML or PDF format. There is no compilation of other formats to HTML.</p> <p>Tip</p> <p>It is strongly recommended to include all content files in the template itself (e.g using document imports for remote files). This will be faster and more predictable at run-time as well as improving traceability of documents.</p> <p>For example:</p> <pre><code>documents:\n  - content/cover.html\n  # Our main contract document template\n  - content/contract.html\n  # Boilerplate PDF to include\n  - content/standard-terms.pdf\n  # Reference to a file in S3\n  - s3://my-content-bucket/extra-terms.pdf\n  # Now a conditional document using evaluated parameters.\n  # The \"if\" condition will evaluate to the string \"True\" or \"False\".\n  - src: content/even-more-terms.pdf\n    if: '{{ contract.term_in_years &gt;= 3 }}'\n</code></pre> <p>Some of the HTML files may have been compiled from other formats (e.g. Markdown) during the compilation phase. All references to the file during rendering must use the HTML file name. So, for example, a file <code>content/text.md</code> in the template source, will be present as <code>content/text.html</code> in the compiled template.</p> <p>Note</p> <p>The original, uncompiled files are also replicated into the template to allow later recompilation and for traceability. The uncompiled files are not used in the rendering process.</p> <p>See Document Template Content for more information.</p>"},{"location":"03-document-templates.html#overlay-documents","title":"Overlay Documents","text":"<p>Info</p> <p>PDF outputs only.</p> <p>The <code>overlays</code> key in the configuration file is a list of documents that are prepared in the same way as the primary documents. These are used when the final document requires an overlaid stamp or underlaid watermark. See Watermarking for more information.</p>"},{"location":"03-document-templates.html#document-imports","title":"Document Imports","text":"<p>The configuration file may contain an <code>imports</code> key to specify a list of external files that will be included within the compiled template package. The imported file is processed just like a local file, including compilation of supported non-HTML formats (e.g. Markdown) into HTML.</p> <p>Imports are specified as a URL, with the URL scheme determining the means of access. Imports are currently supported for:</p> <ul> <li> <p>AWS S3: <code>s3://....</code></p> </li> <li> <p>Web content: <code>http(s)://...</code></p> </li> </ul> <p>The content importers interface is extensible. New sources can be added easily.</p> <p>Each import specification is either a string or an object, like so:</p> <pre><code>imports:\n\n  # Simple string format. This S3 file will be placed in the template based on\n  # the last component of the filename (i.e `myfile.pdf`).\n  - s3://my-bucket/some/path/myfile.pdf\n\n  # Object format to allow a file to be imported and renamed in the process.\n  # This will copy the file into the template as `content/afile.pdf`.\n  - src: s3://my-bucket/some/path/myfile.pdf\n    as: content/afile.pdf\n\n  # This Markdown file will be compiled and can be referenced elsewhere in the\n  # template as \"content/mydoc.html\"\n  - src: s3://my-bucket/some/path/somedoc.md\n    as: content/mydoc.md\n\n  # Import an image\n  - src: http://a.url.com/some/image.png\n    as: resources/image.png\n\n  # Import a font:\n  - src: http://host/my-corporate-font.ttf\n    as: fonts/my-corporate-font.ttf\n</code></pre> <p>Info</p> <p>Imported docs are limited to 10MB in size.</p>"},{"location":"03-document-templates.html#weasyprint-options","title":"WeasyPrint Options","text":"<p>Info</p> <p>PDF outputs only.</p> <p>WeasyPrint is used for converting HTML to PDF for PDF document production.  It provides a number of options to control aspects of the PDF production process. These can be specified under the <code>options</code> key of the template configuration file.</p> <p>The following options are set by docma itself. They can be overridden in the template but it's best not to.</p> Option Value set by docma Notes media print optimize_images True This is required to avoid an image loading bug in WeasyPrint."},{"location":"03-document-templates.html#css-style-sheets","title":"CSS Style Sheets","text":"<p>Info</p> <p>PDF outputs only.</p> <p>The configuration file may contain an <code>options --&gt; styesheets</code> key that lists files containing style sheets that will be applied to all HTML document files when converting them to PDF. Hence, these files should only contain styles that should be applied everywhere.</p> <p>In some cases, including for HTML outputs, it will be more appropriate to have styles defined within the HTML source document to which they relate, or included from CSS files using the Jinja <code>include</code> directive.</p>"},{"location":"03-document-templates.html#sample-configuration-file","title":"Sample Configuration File","text":"<p>A sample file might look like this:</p> <pre><code>description: Contract of Sale\nowner: Cest Moi\nversion: 1.0.0\n\n# List the primary files containing document content. File names are relative to\n# the root of the template.\ndocuments:\n  - content/cover.html\n  # Our main contract document template\n  - content/contract.html\n  # Boilerplate PDF to include\n  - content/standard-terms.pdf\n  # Now a conditional document using evaluated parameters.\n  # The \"if\" condition will evaluate to the string \"True\" or \"False\".\n  - src: content/extra-terms.pdf\n    if: '{{ contract.term_in_years &gt;= 3 }}'\n\n# Bring these files into the package when building the template.\nimports:\n  - src: s3://my-bucket/common-files/standard-terms.pdf\n    as: content/standard-terms.pdf\n\n# Used in the HTML to PDF conversion\noptions:\n  stylesheets:\n    - styles.css\n\nparameters:\n  # These defaults are deep-merged into any parameters specified at run-time\n  # during rendering. The latter will take precedence.\n  defaults:\n    locale: en_AU\n    our_abn: 54321123456\n    contract:\n      term_in_years: 3\n  # JSON Schema used to validate parameters supplied at run-time.\n  schema:\n    $schema: https://json-schema.org/draft/2020-12/schema\n    title: Parameters validation schema\n    type: object\n    required:\n      - locale\n      - customer_name\n      - customer_abn\n      - contract\n      - price\n    properties:\n      locale:\n        type: string\n        format: locale\n      customer_name:\n        type: string\n        minLength: 1\n      customer_abn:\n        type: string\n        format: au.ABN\n      contract:\n        type: object\n      price:\n        type: number\n        minimum: 1.00\n\n# This gets Jinja rendered and added as metadata to the output documents.\n# PDF / HTML conventions for metadata are respected.\nmetadata:\n  title: Contract of Sale\n  subject: '{{ customer_name }}'\n</code></pre>"},{"location":"03-document-templates.html#document-template-content","title":"Document Template Content","text":"<p>The <code>documents</code> and <code>overlays</code> keys in the document template configuration file list the files that will be processed and assembled to produce the final PDF document.</p> <p>Two types of file are permitted in these lists:</p> <ol> <li> <p>HTML files (<code>*.html</code> / <code>*.htm</code>)</p> </li> <li> <p>PDF files (<code>*.pdf</code>) (PDF output only).</p> </li> </ol> <p>The HTML files may be either files directly constructed by the template author, files that have been imported via the <code>imports</code> key, or HTML that has been compiled from other formats (e.g. Markdown) during the template compilation phase.</p> <p>For compiled files, the original file suffix indicates the content type and hence the process used to compile it to HTML format.</p> <p>The content compiler interface is extensible. New file types can be added easily.</p>"},{"location":"03-document-templates.html#html-files-html-htm","title":"HTML Files (*.html, *.htm)","text":"<p>When producing standalone HTML outputs, normal HTML conventions should be followed, keeping in mind the limitations of the target rendering environment (e.g. a variety of email clients).</p> <p>When producing PDF outputs, the source HTML used in a docma template should be written explicitly for print, rather than web layout. There are a set of special HTML constructs available when the target media is print. Effective use of these is essential to producing nice output. For an excellent short tutorial on the subject, see Designing For Print With CSS</p> <p>HTML source files are copied unchanged to the compiled docma template during the compilation phase.</p> <p>HTML files can reference other resources in the compiled template (e.g. images, style sheets etc.) using URLs in the format <code>file:filename</code>. For example</p> <pre><code>&lt;IMG src=\"file:resources/logo.png\" alt=\"logo\"&gt;\n</code></pre> <p>Warning</p> <p>The <code>file:</code> scheme indicator is essential. The filename is relative to the template base directory. Do not use <code>file://</code> as that implies a network location will follow, which makes no sense for local files.</p> <p>HTML files may contain Jinja markup to manipulate content during the rendering phase.</p> <p>Tip</p> <p>Take care when re-purposing HTML content from other systems that may leave Jinja detritus behind. This may need to be manually deleted first.</p> <p>HTML files can also reference dynamic content generators that will be invoked during the rendering phase. This can be used to include content for charts, QR codes etc. Dynamic content generators are accessed by referencing a URL with the <code>docma</code> scheme.</p> <p>For example, the following will generate and insert a QR code:</p> <pre><code>&lt;IMG\n  src=\"docma:qrcode?{{\n    {\n      'text': 'Hello world!',\n      'fg': 'white',\n      'bg': '#338888'\n    } | urlencode\n  }}\"\n&gt;\n</code></pre> <p>This is the same thing, more cryptically:</p> <pre><code>&lt;IMG src=\"docma:qrcode?text=Hello+world%21&amp;fg=white&amp;bg=%23338888\"&gt;\n</code></pre> <p>See Dynamic Content Generation for more information.</p> <p>Important points to note:</p> <ul> <li> <p>The WeasyPrint package is designed to convert HTML     for print to PDF. It does an excellent job, but some constructs take a bit     of fiddling to get right. It seems to be more aligned to Safari behaviour     than, say, Chrome, if that helps when previewing template components.</p> </li> <li> <p>HTML produced by some WYSIWYG editors can be a tortured, gnarly mess.     WeasyPrint may struggle with it. In many cases, it's better to hand-write     lean, clean HTML using an IDE or an AI crutch of some kind.</p> </li> </ul>"},{"location":"03-document-templates.html#pdf-files-pdf","title":"PDF Files (*.pdf)","text":"<p>Info</p> <p>PDF output only.</p> <p>PDF files in the template are copied to the compiled template unchanged. They are simply added into the final document composition process as-is. This is useful for boilerplate content, such as contract terms and conditions.</p> <p>PDF files are not Jinja rendered during compilation. Once again, they are used as-is.</p>"},{"location":"03-document-templates.html#markdown-files-md","title":"Markdown Files (*.md)","text":"<p>All Markdown files are converted to HTML during the compilation phase. i.e. <code>myfile.md</code> in the template source becomes <code>myfile.html</code> in the compiled template.</p> <p>Warning</p> <p>The HTML variant of the name must be used everywhere in the template when referencing the file.</p> <p>Markdown files may contain Jinja markup to manipulate content during the rendering phase.</p> <p>Conversion from Markdown to HTML is done using the Python markdown package with the following extensions enabled:</p> <ul> <li>extras</li> <li>admonition.</li> </ul> <p>Important points to note:</p> <ul> <li> <p>The conversion from Markdown to HTML will not add     <code>&lt;HTML&gt;...&lt;BODY&gt;&lt;/BODY&gt;&lt;/HTML&gt;</code>     framing around the result. This is an advantage, as it means the content can     be included in other documents using Jinja <code>{% include 'myfile.html' %}</code>     directives. If a Markdown originated source file is to be used stand-alone,     a small HTML wrapper that references the content file may be needed to     provide the HTML framing, style sheet etc.</p> </li> <li> <p>The Markdown format is particularly suited to longer, textual content.     It is a lot easier to edit and maintain than HTML, but complex styling is     more difficult. The Python markdown     package has some non-standard extensions that do help with this.</p> </li> </ul>"},{"location":"03-document-templates.html#locale-in-docma-templates","title":"Locale in Docma Templates","text":"<p>Prior to version 2.2.0, docma had no particular notion of the region or locale with which a particular template, or the documents it produces, is associated. If special formatting was required, it was up to the template designer to handle that manually.</p> <p>This applied for elements such as:</p> <ul> <li>phone numbers</li> <li>currencies</li> <li>numbers and percentages</li> <li>dates and times.</li> </ul> <p>Version 2.2.0 introduces the concept of locale. A new suite of docma provided Jinja filters use locale information to handle the elements listed above in accordance with locale specific conventions instead of requiring the template designer to handle everything manually. For example:</p> <pre><code>{{ 123456 | decimal }} -- Format using locale specific separators etc.\n{{ 123456 | AUD }} -- Format however Australian $ are shown in the current locale\n</code></pre> <p>See Docma Jinja Rendering for more information.</p> <p>The locale for a template manifests as an additional Jinja rendering parameter, <code>locale</code>, which is expressed in the normal way as a combination of a language indicator and a 2 character ISO country code. e.g. <code>en_AU</code>, <code>en_CA</code>, <code>fr_CA</code>. It can be set in the same way as any other rendering parameter, including any, or all, of the following (from lowest precedence to highest):</p> <ul> <li> <p>Including it in the <code>parameters -&gt; defaults</code> in the     template configuration file.</p> </li> <li> <p>Specifying it on the command line when rendering a template to PDF or HTML     output.</p> </li> <li> <p>Setting it within a template using <code>{% set locale=\"....\" %}</code>.</p> </li> <li> <p>In some jinja filters, specifying     locale as an explicit argument to override the current effective value.</p> </li> </ul> <p>From version 2.2.0, new templates created using docma new will include a default value in the template configuration file. It's a good idea to add it to earlier templates, thus:</p> <pre><code># config.yaml\n\nparameters:\n  defaults:\n    locale: \"en_AU\"\n</code></pre> <p>Info</p> <p>If <code>locale</code> is not specified using one of the mechanisms described above, it will default to whatever random value the underlying platform assumes. Good luck with that.</p>"},{"location":"04-template-compilation.html","title":"Docma Template Compilation","text":"<p>The compilation process is a build-time activity consisting of the following steps:</p> <ol> <li> <p>Validate the template configuration file.</p> </li> <li> <p>Copy files from the template source to the template staging area,     compiling any compilable files (e.g Markdown) to HTML in the process.</p> </li> <li> <p>Import any files specified in the <code>imports</code> key of the     configuration file, compile as required and     copy them to the template staging area.</p> </li> <li> <p>Zip up the contents of the template staging area to produce the compiled     document template.</p> </li> </ol> <p>Note</p> <p>The docma CLI also supports the option of saving the compiled template, uncompressed, into a local directory. This is primarily for development and testing.</p> <p></p> <p>There is (approximately) a one-to-one correspondence between files in the source directory and the compiled template. Directory structure is preserved.</p>"},{"location":"05-template-rendering.html","title":"Docma Template Rendering","text":"<p>The document rendering phase combines a compiled docma template with run-time specified parameters and dynamically generated content to produce a final output document.</p> <p>The rendering process is slightly different for PDF and HTML outputs.</p>"},{"location":"05-template-rendering.html#rendering-for-pdf-outputs","title":"Rendering for PDF Outputs","text":"<p>The main steps in the process for PDF production are:</p> <ol> <li> <p>Marshal the rendering parameters.</p> </li> <li> <p>Validate the rendering parameters.</p> </li> <li> <p>Collect the list of documents to be incorporated into the final output PDF.</p> </li> <li> <p>Render HTML documents in the component list using     Jinja to inject the rendering parameters.</p> </li> <li> <p>Convert the HTML documents to PDF using WeasyPrint.     This process will also generate any dynamic content     from specifications embedded in the source HTML.</p> </li> <li> <p>Assemble all of the components (generated PDFs and any listed static PDFs)     into a single PDF document.</p> </li> <li> <p>Add any requested watermarking or stamping to the document.</p> </li> <li> <p>Jinja render any required metadata specified in the     template configuration file and add it to     the PDF.</p> </li> <li> <p>Optionally, compress the PDF using lossless compression. Depending on the     PDF contents, compression may, or may not, help.</p> </li> </ol>"},{"location":"05-template-rendering.html#rendering-for-html-outputs","title":"Rendering for HTML Outputs","text":"<p>The main steps in the process for HTML production are:</p> <ol> <li> <p>Marshal the rendering parameters.</p> </li> <li> <p>Validate the rendering parameters.</p> </li> <li> <p>Collect the list of documents to be incorporated into the final output HTML.</p> </li> <li> <p>Render HTML documents in the component list using     Jinja to inject the rendering parameters.</p> </li> <li> <p>Process <code>&lt;IMG&gt;</code> tags in the HTML to generate and embed any     dynamic content from specifications embedded     in the source HTML. Static images may also be embedded.</p> </li> <li> <p>Assemble all of the component HTML documents into a single HTML document.</p> </li> <li> <p>Jinja render any required metadata specified in the     template configuration file and add it to     the HTML.</p> </li> </ol>"},{"location":"05-template-rendering.html#docma-parameter-validation","title":"Docma Parameter Validation","text":"<p>Docma supports the use of JSON Schema to validate rendering parameters at run-time. Parameters are validated against a schema provided in the <code>parameters-&gt;schema</code> key in the  template configuration file prior to generating the output document. Failing validation will halt the production process.</p> <p>Tip</p> <p>Provision, and hence use, of a parameter validation schema is optional, but highly recommended to reduce the risk of generating an important document incorrectly or with nonsensical values.</p> <p>All of the normal facilities of  JSON Schema are available, except for external schema referencing with <code>$ref</code> directives. Like the JSON Schema built-in string formats, docma provided format checkers can be used in a schema specification with the <code>format</code> attribute of string objects</p> <p>The following sample schema fragment shows how these are used:</p> <pre><code>type: object\nproperties:\n  customer_email:\n    type: string\n    format: email  # This is a JSON schema built-in format checker\n  customer_abn:\n    type: string\n    format: au.ABN  # This is a docma provided format checker\n  target_consumption:\n    type: number\n    minimum: 0\n  consumption_unit:\n    type: string\n    format: energy_unit  # This is a docma provided format checker\n  start_date:\n    type: string\n    format: date.dmy  # This is a docma provided format checker\n</code></pre> <p>See also Docma Format Checkers.</p>"},{"location":"05-template-rendering.html#dynamic-content-generation","title":"Dynamic Content Generation","text":"<p>When docma converts HTML into PDF or stand-alone HTML, it needs to resolve all URLs in the source HTML in things such as <code>&lt;img src=\"...\"&gt;</code> tags. It does this via a custom URL fetcher that allows content requests to be intercepted and the resulting content generated dynamically. In this way, docma can generate dynamic content, such as charts, for inclusion in the final output document.</p> <p>Note</p> <p>There are some differences in this process depending on whether the final output is PDF of HTML. See Dynamic Content Generation Differences Between PDF and HTML Output.</p> <p>All URLs are constituted thus:</p> <pre><code>scheme://netloc/path;parameters?query#fragment\n</code></pre> <p>Docma determines which custom URL fetcher to apply based on the URL scheme (i.e. the first part before the colon). The URL fetchers handle a range of non-standard, docma specific schemes, as well as the standard <code>http</code> and <code>https</code> schemes.</p> <p>Docma currently handles the following non-standard schemes:</p> Scheme Description docma Interface to docma dynamic content generators of various types. file Interface to access files contained within the compiled document template. s3 Interface to access files from AWS S3. <p>Note</p> <p>The docma URL fetcher interface is easily expandable to handle other schemes. See URL Fetchers.</p>"},{"location":"05-template-rendering.html#dynamic-content-generation-differences-between-pdf-and-html-output","title":"Dynamic Content Generation Differences Between PDF and HTML Output","text":"<p>PDF generation from HTML is performed by WeasyPrint, which will invoke a custom URL fetcher for any URL it needs to access during the conversion process. This includes, but is not limited to, <code>&lt;IMG&gt;</code> tags.</p> <p>For standalone HTML output, the process of invoking a custom URL fetcher is done by docma itself. It is only applied to the <code>src</code> attribute of <code>&lt;IMG&gt;</code> tags under specific circumstances. When it is done, the <code>src</code> attribute is replaced in the <code>&lt;IMG&gt;</code> tag with the actual content returned by the URL fetcher. i.e. the data is embedded within the standalone HTML output.</p> <p>In practice, these differences work naturally, relative to the final viewing environment for the produced document, static PDF or dynamic HTML.</p> <p>By default, in HTML outputs, <code>&lt;IMG&gt;</code> tags have the content embedded in place of the <code>src</code> attribute in the following circumstances:</p> <ul> <li> <p>The <code>src</code> URL is not <code>http(s)://</code> (i.e. any of the docma custom     schemes described below); or</p> </li> <li> <p>The <code>src</code> URL is <code>http(s)://</code>, has no query component <code>?...</code>,      and the content size is between 100 bytes and 1MB in size.</p> </li> </ul> <p>For the <code>http(s)://</code> URLs, it is possible to override the default behaviour by adding the <code>data-docma-embed</code> attribute to the <code>&lt;IMG&gt;</code> tag.</p> <p>For images that are not embedded, it is assumed that the client (e.g. an email client or web browser) will fetch the images as required at display time.</p> <pre><code>&lt;!-- Force the image to be embedded --&gt;\n&lt;IMG src=\"http://host/img.png\" data-docma-embed=\"true\"&gt;\n\n&lt;!-- Prevent the image from being embedded --&gt;\n&lt;IMG src=\"http://host/img.png\" data-docma-embed=\"false\"&gt;\n\n&lt;!-- This will not be embedded due to size unless we force it --&gt;\n&lt;IMG src=\"http://host/multi-mega-byte-img.png\"&gt;\n\n&lt;!-- This will not be embedded due to size unless we force it --&gt;\n&lt;IMG src=\"http://host/one-pixel-img.png\"&gt;\n\n&lt;!-- This will not be embedded due to query component unless we force it --&gt;\n&lt;IMG src=\"http://host/do/something?x=20\"&gt;\n\n&lt;!-- This will always be embedded and cannot be prevented --&gt;\n&lt;IMG src=\"s3://my-bucket/corporate-logo.png\"&gt;\n</code></pre>"},{"location":"05-template-rendering.html#scheme-docma","title":"Scheme: docma","text":"<p>URLs of the following form are intercepted by docma and used to invoke a dynamic content generator.</p> <pre><code>docma:&lt;generator-name&gt;?&lt;generator-params&gt;\n</code></pre> <p>Note that for these docma URLs, there is no netloc component and hence no <code>//</code> in the URL.</p> <p>For example, this will generate a QR code:</p> <pre><code>&lt;IMG style=\"height: 40px\"\n    src=\"docma:qrcode?text=Hello%s20world&amp;fg=white&amp;bg=red\"&gt;\n</code></pre> <p>The URL should be properly URL encoded. This can be fiddly, but Jinja can help here. The example above could also have been written in dictionary format thus:</p> <pre><code>&lt;IMG style=\"height: 40px\" src=docma:qrcode?{{\n  {\n    'text': 'Hello world',\n    'fg': 'white',\n    'bg': 'red'\n  } | urlencode\n}}\"&gt;\n</code></pre> <p>It could also have been written as a sequence of tuples:</p> <pre><code>&lt;IMG style=\"height: 40px\" src=docma:qrcode?{{\n  (\n    ('text', 'Hello world'),\n    ('fg', 'white'),\n    ('bg', 'red')\n  ) | urlencode\n}}\"&gt;\n</code></pre> <p>Info</p> <p>The sequence format is required if any of the parameters needs to be used more than once.</p> <p>Available content generators are:</p> Name Description qrcode Generate a QR code. swatch Generate a colour swatch as graphic placeholder. vega Generate a chart based on the Vega-Lite declarative syntax for specifying charts / graphs. <p>Note</p> <p>The dynamic content generator interface is readily extensible to add new types of content. See Content Generators.</p>"},{"location":"05-template-rendering.html#generating-qr-codes","title":"Generating QR Codes","text":"<p>The QR code dynamic generator accepts the following parameters:</p> Parameter Type Required Description bg String No Background colour of the QR code (e.g. <code>blue</code> or <code>#0000ff</code>). Default is white. border Integer No Number of boxes thick for the border. Default is the minimum allowed value of 4. box Integer No Number of pixels for each box in the QR code. Default is 10. fg String No Foreground colour of the QR code. Default is black. text String Yes Content to be encoded in the QR code. <p>Examples:</p> <pre><code>&lt;IMG style=\"height: 40px\"\n    src=\"docma:qrcode?text=Hello%s20world&amp;fg=white&amp;bg=red\"&gt;\n</code></pre> <pre><code>&lt;IMG style=\"height: 40px\" src=docma:qrcode?{{\n  {\n    'text': 'Hello world',\n    'fg': 'white',\n    'bg': 'red'\n  } | urlencode\n}}\"&gt;\n</code></pre>"},{"location":"05-template-rendering.html#generating-charts-and-graphs","title":"Generating Charts and Graphs","text":"<p>Docma supports the Vega-Lite declarative syntax for specifying charts / graphs. Vega-Lite specifies a mapping between source data and visual representations of the data. Docma provides mechanisms for specifying and accessing various data sources and feeding this data through a Vega-Lite specification to generate charts and graphs.</p> <p>This is a large topic and more information is provided in Charts and Graphs in Docma. To whet your appetite, check out the Vega-Lite sample gallery.</p> <p>This section just summarises the parameters for the <code>vega</code> content generator for reference:</p> Parameter Type Required Description data String No A docma data source specification. This argument can be repeated if multiple data sources are required.  If not specified, the file referenced by the <code>spec</code> parameter must contain all of the required data. format String No Either <code>svg</code> (the default) or <code>png</code>. Stick to <code>svg</code> if at all possible. spec String Yes The name of the file in the compiled document template that contains the Vega-Lite specification for the chart. The contents can be either YAML or JSON. ppi Integer No (<code>png</code> format only) Pixels-per-inch resolution of the generated image. Default 72. scale Float No (<code>png</code> format only) Scale the chart by the specified factor. Default is 1.0. Generally, it's better to control display size in the HTML but increasing the scale here can improve resolution. params JSON string No A string containing a JSON encoded object containing additional rendering parameters used when rendering the chart specification and any associated query specifications. <p>Examples:</p> <pre><code>&lt;IMG style=\"width: 5cm;\"\n    src=\"docma:vega?spec=charts/my-chart.yaml&amp;data=...\"&gt;\n</code></pre> <pre><code>&lt;IMG style=\"width: 10cm;\" src=docma:vega?{{\n  (\n    ( 'spec', 'charts/my-chart.yaml' ),\n    ( 'data', 'file;data/my-data.csv' ),\n    ( 'params', { 'extra_rendering_param': 1234 } | tojson)\n  ) | urlencode\n}}\"&gt;\n</code></pre>"},{"location":"05-template-rendering.html#generating-graphic-placeholders-swatches","title":"Generating Graphic Placeholders (Swatches)","text":"<p>The swatch generator produces a simple coloured rectangle with an optional text message. It's not intended to be useful in final documents, Mondrian notwithstanding. It has two purposes:</p> <ol> <li> <p>As a simple code sample for dynamic content generators that can be copied     and modified for new requirements.</p> </li> <li> <p>As a temporary placeholder when developing the structure of a docma template     that will be replaced subsequently by a real piece of content (e.g. a chart).</p> </li> </ol> Parameter Type Required Description color String No Fill colour of the swatch. Default is a light grey. font String No Font file name for the text. Default is <code>Arial</code>. If the specified font is not available, a platform specific default is used. font_size Integer No Font size. Default is 18. height Integer Yes Swatch height in pixels. text String No Text to centre in the swatch. No effort is made to manipulate it to fit. text_color String No Colour for text. Default is black. width Integer Yes Swatch width in pixels. <p>!!! question Colour or color?     The code and docma templates stick with <code>color</code>, because, well, that battle     is lost. The user guide uses <code>colour</code> in descriptive text. Blame Webster for     messing it up, not me.</p> <p>Examples:</p> <pre><code>&lt;IMG src=\"docma:swatch?width=150&amp;height=150&amp;color=seagreen\"&gt;\n</code></pre> <pre><code>&lt;IMG src=\"docma:swatch?{{ {\n    'width': 150,\n    'height': 150,\n    'color': '#0080ff',\n    'text': 'Hello world',\n    'text_color': 'yellow',\n    'font_size': 24\n    } | urlencode }}\"\n&gt;\n</code></pre>"},{"location":"05-template-rendering.html#scheme-file","title":"Scheme: file","text":"<p>URLs in HTML files of the form <code>file:...</code> are intercepted by docma and the content is extracted from a file within the compiled document template. As the file is local to the template, there is no network location so the URL will be like so:</p> <pre><code>&lt;IMG src=\"file:resources/logo.png\" alt=\"logo\"&gt;\n</code></pre> <p>Warning</p> <p>Do not include <code>//</code> after <code>file:</code>. It will not work.</p>"},{"location":"05-template-rendering.html#scheme-s3","title":"Scheme: s3","text":"<p>URLs in HTML files of the form <code>s3://...</code> are intercepted by docma and the content is extracted from AWS S3. A typical usage would be something like:</p> <pre><code>&lt;IMG src=\"s3://my-bucket/some/path/logo.png\" alt=\"logo\"&gt;\n</code></pre> <p>Info</p> <p>Files are limited to 10MB in size.</p>"},{"location":"05-template-rendering.html#watermarking","title":"Watermarking","text":"<p>Docma supports the ability to watermark and stamp PDF documents using the concept of document overlays.</p> <p>Info</p> <p>Overlays are not supported for HTML output documents.</p> <p>An overlay is a PDF document, generated by docma that can be used as either a watermark or a stamp.</p> <p>A watermark is content merged into every page of the final PDF under the main document content.</p> <p>A stamp is content merged into every page of the final PDF over the main document content.</p> <p>Overlays are defined in the template configuration file using the following structure:</p> <pre><code>overlays:\n  my-overlay-1:\n    # We can have HTML files that will be rendered like other docs\n    - a4-portrait.html\n    # ... or static PDFs\n    - a4-landscape.pdf\n\n  # or ...\n  my-overlay-2: a4-portrait.html\n</code></pre> <p>Each overlay is a named list of documents (or a single document). When docma is requested to add a watermark (or stamp), it is provided with the name of one or more of the overlays (e.g. <code>my-overlay-1</code>).</p> <p>It will then render each of the files in each overlay list in the same way as the main document, including rendering with dynamic run-time parameters.</p> <p>Each page in the main document is then merged with the first page of the first overlay document in each list that has (approximately) the same page dimensions.</p> <p>Info</p> <p>The process will abort if a matching overlay page cannot be found for a main document page.</p> <p>The presence of the <code>overlays</code> section in the configuration file does not itself enable watermarking / stamping. This has to be explicitly requested.</p> <p>Watermarking / stamping can be requested using the <code>--watermark</code> / <code>--stamp</code> CLI options. If using the Python API, the <code>watermark</code> / <code>stamp</code> parameters to the <code>render_template()</code> function are used.</p> <p>It is possible to have both watermarking and stamping used on a single document, as well as having multiple overlays applied to a single document.</p> <p>Info</p> <p>A simple grid overlay is provided as part of the basic template created by the docma new command. This can be handy when adjusting page layout. To add the grid, the docma CLI rendering command would be <code>docma pdf --stamp grid ...</code>. Grid size and colour are adjustable in the parameter defaults in the template config file.</p>"},{"location":"05-template-rendering.html#document-metadata","title":"Document Metadata","text":"<p>Docma allows the template to control some of the metadata added to the final PDF or HTML and enforces some values of its own.</p> <p>PDF and HTML documents have slightly different conventions regarding metadata naming and formatting. Docma handles these variations.</p> <p>In HTML, the metadata fields are added into the <code>&lt;HEAD&gt;</code> of the final document in this form:</p> <pre><code>&lt;meta content=\"Fred Nurk\" name=\"author\"/&gt;\n&lt;meta content=\"A document about stuff\" name=\"title\"/&gt;\n&lt;meta content=\"DRAFT, Top-Secret\" name=\"keywords\"/&gt;\n&lt;meta content=\"2024-11-21T00:04:38.699978+00:00\" name=\"creation_date\"/&gt;\n</code></pre> <p>In PDF, the meta data fields are used to populate the standard metadata elements recognised by common PDF readers.</p> HTML Naming PDF Naming Controlled by Comments author /Author Template From the <code>metadata-&gt;author</code> key in <code>config.yaml</code> creation_date /CreationDate Docma Document production datetime creator /Creator Docma Based on template <code>id</code>, <code>version</code> and docma version keywords /Keywords Template From the <code>metadata-&gt;keywords</code> key in <code>config.yaml</code> subject /Subject Template From the <code>metadata-&gt;subject</code> key in <code>config.yaml</code> title /Title Template From the <code>metadata-&gt;title</code> key in <code>config.yaml</code>"},{"location":"05-template-rendering.html#batch-rendering","title":"Batch Rendering","text":"<p>Docma supports the ability to generate a batch of output documents from a single document template using the <code>pdf-batch</code> (PDF) and <code>html-batch</code> (HTML) sub-commands of the docma CLI.</p> <p>The document template needs to anticipate the need for batch rendering by including some Jinja controlled content that will be varied for each document produced via document specific parameters. The source for the document specific batch parameters is a docma data loader. Data returned by the data loader is merged in with the fixed rendering parameters, a row at a time, and docma produces an output document using that combination. The source data for the batch parameters is specified using a docma data source specification.</p> <p>Note</p> <p>The following describes the process for PDF document batches. The process is similar for HTML batches.</p> <p></p> <p>This is how a batch rendering is invoked:</p> <pre><code># Long form arguments\ndocma pdf-batch --template my-template.zip \\\n    --file static-params.yaml \\\n    --data-source-spec 'postgres;pglocal;queries/batch.yaml' \\\n    --output 'whatever-{{id}}-{{familyname|lower}}.pdf'\n\n# Short form arguments\ndocma pdf-batch -t my-template.zip \\\n    -f static-params.yaml \\\n    -d 'postgres;pglocal;queries/batch.yaml' \\\n    -o 'whatever-{{id}}-{{familyname|lower}}.pdf'\n</code></pre> <p>Let's examine this bit by bit.</p> <p>The docma <code>pdf-batch</code> sub-command is invoked specifying the compiled document template:</p> <pre><code>docma pdf-batch --template my-template.zip\n</code></pre> <p>Rendering parameters are specified exactly as for the single document rendering process. These parameters are the same for every document in the rendering batch:</p> <pre><code>    --file static-params.yaml \\\n</code></pre> <p>The docma data source specification tells docma how to obtain rows of data to control the batch rendering. Each row is a set of key/value pairs that will be merged into the static rendering parameters and used to render one PDF document:</p> <pre><code>    --data-source-spec 'postgres;pglocal;queries/batch.yaml' \\\n</code></pre> <p>The docma data source specification is interpreted within the context of the document template.</p> <p>As docma will be producing a series of PDF documents, it needs a mechanism to provide each document with a unique name that corresponds to the batch data entry that was used to produce it. This is done using the <code>--output</code> option with an argument that is Jinja rendered to construct the filename. In this example, it is assumed that the batch data contains <code>id</code> and <code>familyname</code> elements and that these are a unique combination to avoid filename clashes:</p> <pre><code>    --output 'whatever-{{id}}-{{familyname|lower}}.pdf'\n</code></pre> <p>Note</p> <p>There are some strict constraints on the filename rendering process for safety reasons.</p>"},{"location":"06-jinja-rendering.html","title":"Docma Jinja Rendering","text":"<p>The rendering phase uses Jinja to render HTML content with the parameters provided at run-time. Other components (e.g. query specifications) also use Jinja rendering on some of their content.</p> <p>Note</p> <p>The docma Jinja subsystem has been refactored somewhat in v2.2.0.</p> <p>All of the facilities provided by Jinja are available, including parameter injection, loops, conditional content and use of the <code>include</code> directive to incorporate other content from the document template. Include directives should use the name of the file relative to the template root. e.g.</p> <pre><code>{% include 'my-file.html' %}\n</code></pre> <p>See also Jinja Rendering Parameters Provided by Docma.</p> <p>In addition to standard Jinja facilities, docma also provides a number of extra filters and extensions.</p>"},{"location":"06-jinja-rendering.html#rendering-parameters","title":"Rendering Parameters","text":"<p>The parameters used by docma during the template rendering process is the union of the following (from highest to lowest precedence):</p> <ol> <li> <p>Parameters provided by docma.</p> </li> <li> <p>Parameters supplied by the user at run-time.</p> </li> <li> <p>Parameters specified under <code>parameters-&gt;defaults</code> in the     template configuration file</p> </li> </ol> <p>Parameters are any object that can be represented in JSON / standard YAML, which can include arbitrary combinations of objects, lists and scalar values.</p> <p>The marshalling process deep-merges the parameter trees from each source. Lists are not merged. One list will replace another if they occur at the same location.</p>"},{"location":"06-jinja-rendering.html#rendering-parameters-provided-by-docma","title":"Rendering Parameters Provided by Docma","text":"<p>In addition to user supplied parameters, docma includes the following items under the <code>docma</code> key.</p> Key Notes Description calendar The Python <code>calendar</code> module. data Function to invoke a docma data provider and return the data as a list of dictionaries. See Data Source Specifications for HTML Rendering. datetime The Python <code>datetime</code> module. format The format of the output document to be produced, <code>PDF</code> or <code>HTML</code>. This can be used, among other things, for format specific content or formatting (e.g. CSS variations). paramstyle (1) Corresponds to the DBAPI 2.0 <code>paramstyle</code> attribute of the underlying database driver when processing a  query specification. template An object containing information about the document template. --&gt; description The <code>description</code> field from the template configuration file. --&gt; doc_no (2) The document number in the list being included in the final document, starting at 1. --&gt; document (2) The path for the source document being processed. This is a pathlib <code>Path()</code> instance. --&gt; id The <code>id</code> field from the template configuration file. --&gt; overlay_id (3) The ID of the current overlay set being rendered. --&gt; overlay_path (3) The path for the current overlay file being rendered. This is a pathlib <code>Path()</code> instance. --&gt; page (2) The starting page number for the current document with respect to the final output document. This may be useful for manipulating page numbering in multipart documents. Or not. --&gt; version The <code>version</code> field from the template configuration file. version The docma version. <p>Notes</p> <ol> <li>The <code>paramstyle</code> parameter is only available for use in     query specifications.</li> <li> <p>The <code>template.doc_no</code>, <code>template.document</code> and <code>template.page</code> parameters     are only available when a document file is being rendered (i.e. not when an     overlay is being rendered). The <code>template.page</code> parameter is only available     for PDF outputs.</p> </li> <li> <p>The <code>template.overlay_id</code> and <code>template.overlay_path</code> parameters are only     available when an overlay file is being rendered.</p> </li> </ol> <p>For example, to insert today's date:</p> <pre><code>{{ docma.datetime.date.today() | date }} -- \"date\" filter formats for locale\n</code></pre> <p>To check whether we are producing HTML or PDF:</p> <pre><code>This is {{ docma.format }} output using docma version {{ docma.version }}.\n</code></pre>"},{"location":"06-jinja-rendering.html#docma-jinja-filters","title":"Docma Jinja Filters","text":"<p>Note</p> <p>Jinja filter management has changed significantly in docma 2.2. Some filters have been renamed (with backward compatible aliases) and a new, more extensible filter plugin system has been implemented.</p> <p>In addition to the standard filters provided by Jinja, docma provides a number of additions. These are divided into:</p> <ul> <li>Generic filters</li> <li>Region / country specific filters.</li> </ul> <p>Info</p> <p>Custom filter names are not case sensitive.</p>"},{"location":"06-jinja-rendering.html#generic-filters","title":"Generic Filters","text":"<p>Filters marked with * are locale aware.</p> Filter Name Description compact_decimal * Format a number in a compact format. css_id Sanitise a string to be a valid CSS identifier. currency * Format currency. date * Format a date. datetime * Format a datetime. decimal * Format a number. dollars Legacy. Format currency a value as dollars. parse_date * Parse a date string into a datetime.date instance. parse_time * Parse a date string into a datetime.time instance. percent * Format a percentage. phone * Format a phone number. require Abort with an error message an expression does not have a truthy value. sql_safe Ensure that a string value is safe to use in SQL and generate an error if not. time * Format a time value. timedelta * Format a timedelta value."},{"location":"06-jinja-rendering.html#regional-filters","title":"Regional Filters","text":"Filter Name Description abn Deprecated. Use au.abn. acn Deprecated. Use au.abn. au.abn Format an Australian Business Number (ABN). au.acn Format an Australian Company Number (ACN)."},{"location":"06-jinja-rendering.html#jinja-filter-auabn","title":"Jinja Filter: au.abn","text":"<p>Format an Australian Business Number (ABN).</p> <p>This supersedes the, now deprecated, <code>abn</code> filter.</p> <p>Filter Signature</p> <pre><code>au.abn(value: str) -&gt; str\n</code></pre> <p>Example</p> <pre><code>{{ '51824753556'  | au.abn }} --&gt; 51 824 753 556 \n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-auacn","title":"Jinja Filter: au.acn","text":"<p>Format an Australian Company Number (ACN). This supersedes the, now deprecated, <code>acn</code> filter.</p> <p>Filter Signature</p> <pre><code>au.acn(value: str) -&gt; str\n</code></pre> <p>Example</p> <pre><code>{{ '123456789' | au.acn }} --&gt; 123 456 789\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-compact_decimal","title":"Jinja Filter: compact_decimal","text":"<p>Format numeric values.</p> <p>This is a locale-aware filter that provides an interface to the Babel format_compact_decimal() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting.</p> <p>The locale is determined as described in Locale in Docma Templates. It can also be specified explicitly by adding a <code>locale</code> argument to the filter.</p> <p>Filter Signature</p> <pre><code>compact_decimal(\n    value: str | int | float,\n    *args,\n    rounding: str = 'half-up',\n    default: int | float | str | None = None,\n    **kwargs\n) -&gt; str\n</code></pre> Parameter Description value Filter input value. Numbers and strings containing numbers are accepted. *args Passed to Babel's format_compact_decimal(). rounding How to round the value. This must be one of the rounding modes in Babel's <code>decimal.ROUND_*</code>, with the <code>ROUND_</code> prefix removed. Case is ignored and hyphens become underscores. Defaults to <code>half-up</code> (Excel style rounding), instead of <code>half-even</code> (Bankers rounding) which is Python's normal default. default The default value to use for the filter if the input value is empty (i.e. None or an empty string). If the input value is empty and <code>default</code> is a string, it is used as-is as the return value of the filter. If the input value is empty, and <code>default</code> is not specified, an error is raised. Otherwise, the default is assumed to be numeric and is used as the input to the filter. Note: The <code>default</code> parameter does something different to the Jinja standard default filter. They are both useful but not interchangeable. **kwargs Passed to Babel's format_compact_decimal(). This includes the option of using the <code>locale</code> parameter to specify locale. <p>Examples</p> <p>Assuming locale is set to <code>en_AU</code>:</p> <pre><code>{{ 1234.5678 | compact_decimal }} --&gt; 1K\n{{ '1234.5678' | compact_decimal }} --&gt; 1K\n</code></pre> <p>Locale can be specified explicitly, if required:</p> <pre><code>{{ 1234.5678 | compact decimal(locale='fr_FR') }} --&gt; 1 k\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-css_id","title":"Jinja Filter: css_id","text":"<p>Sanitise a string to be a valid CSS identifier.</p> <p>!!! \"Filter Signature\"</p> <pre><code>```python\ncss_id(value: str) -&gt; str\n```\n</code></pre> <p>Example</p> <pre><code>{{ 'a/()=*&amp;bcd'' | css_id }} --&gt; abcd\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-currency","title":"Jinja Filter: currency","text":"<p>Format a currency value.</p> <p>This is a locale-aware filter that provides an interface to the Babel format_currency() API.</p> <p>It is important to understand that there are two orthogonal aspects to formatting currency values:</p> <ol> <li> <p>The currency involved, such as Australian dollars (AUD), Euros (EUR) etc.</p> </li> <li> <p>The locale in which the currency is to be presented.</p> </li> </ol> <p>For example:</p> <ul> <li>One Australian dollar would appear in Australia as <code>$1.00</code>.</li> <li>One Australian dollar would appear in the US as <code>A$1.00</code></li> <li>One Australian dollar would appear in France as <code>1,00 AU$</code></li> </ul> <p>For the docma filter, the currency (AUD in the example above) can be specified in one of two ways:</p> <ol> <li>By providing an argument to the currency filter <code>{{ 1 | currency('AUD') }}</code>;     or</li> <li>Using the currency name itself as an alias for the filter name     <code>{{ 1 | AUD }}</code>. Docma dynamically generates a filter alias for known     currencies. Case is not significant.</li> </ol> <p>The locale is determined as described in Locale in Docma Templates.  It can also be specified explicitly by adding a <code>locale</code> argument to the filter.</p> <p>Filter Signature</p> <pre><code>currency(\n    value: str | int | float,\n    currency: str,\n    *args,\n    rounding: str = 'half-up',\n    default: int | float | str | None = None,\n    **kwargs\n) -&gt; str\n</code></pre> <p>... or .... </p> <pre><code>&lt;CURRENCY_CODE&gt;(\n    value: str | int | float,\n    *args,\n    rounding: str = 'half-up',\n    default: int | float | str | None = None,\n    **kwargs\n) -&gt; str\n</code></pre> <p>Here <code>&lt;CURRENCY_CODE&gt;</code> can be <code>AUD</code>, <code>GBP</code>, <code>EUR</code> etc.</p> Parameter Description value Filter input value. Numbers and strings containing numbers are accepted. Jinja will inject this automatically. currency The currency code (e.g <code>AUD</code>, <code>EUR</code> etc.) *args Passed to Babel's format_currency(). rounding How to round the value. This must be one of the rounding modes in Babel's <code>decimal.ROUND_*</code>, with the <code>ROUND_</code> prefix removed. Case is ignored and hyphens become underscores. Defaults to <code>half-up</code> (Excel style rounding), instead of <code>half-even</code> (Bankers rounding) which is Python's normal default. default The default value to use for the filter if the input value is empty (i.e. None or an empty string but not zero). If the input value is empty and <code>default</code> is a string, it is used as-is as the return value of the filter. If the input value is empty, and <code>default</code> is not specified, an error is raised. Otherwise, the default is assumed to be numeric and is used as the input to the filter. Note: The <code>default</code> parameter does something different to the Jinja standard default filter. They are both useful but not interchangeable. **kwargs Passed to Babel's format_decimal(). This includes the option of using the <code>locale</code> parameter to specify locale. <p>Examples</p> <p>Assuming locale is set to <code>en_AU</code>:</p> <pre><code>{{ 123 | AUD }} --&gt; $123.00\n{{ 123 | currency('AUD') }} --&gt; $123.00\n{{ '123' | NZD }} --&gt; NZD123.00 (numeric strings are fine as input)\n{{ None | AUD }} --&gt; ERROR!\n{{ None | AUD(default=0) }} --&gt; $0.00\n{{ None | AUD(default='FREE!')}} --&gt; FREE!\n{{ -123 | AUD(format=\"\u00a4#,###;(\u00a4#)\", currency_digits=False)}} --&gt; ($123)\n</code></pre> <p>Locale can be specified explicitly, if required:</p> <pre><code>{{ 123 | EUR(locale='en_GB') }} --&gt; \u20ac123.00\n{{ 123 | EUR(locale='fr_FR' }} --&gt; 123,00 \u20ac\n</code></pre> <p>The legacy dollars filter can be replicated like so (use whatever dollar currency is appropriate):</p> <pre><code>{{ 1234.5 | dollars }} --&gt; {{ 1234.5 | AUD }} --&gt; $1,234.50\n{{ 1234.5 | dollars(0) }} --&gt; {{ AUD(format=\"\u00a4#,###\", currency_digits=False) }} --&gt; $1,235\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-date","title":"Jinja Filter: date","text":"<p>Format date values.</p> <p>This is a locale-aware filter that provides an interface to the Babel format_date() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting.</p> <p>The locale is determined as described in Locale in Docma Templates. It can also be specified explicitly by adding a <code>locale</code> argument to the filter.</p> <p>Filter Signature</p> <pre><code>date(value: datetime.date | datetime.datetime, *args, **kwargs) --&gt; str\n</code></pre> Parameter Description value Filter input value. This must be a <code>datetime.date</code> or <code>datetime.datetime</code> instance. *args Passed to Babel's format_date(). **kwargs Passed to Babel's format_date(). This includes the option of using the <code>locale</code> parameter to specify locale. <p>Examples</p> <p>Assuming locale is set to <code>en_AU</code>:</p> <pre><code>{% set value = docma.datetime.date(2025, 9, 17) %}\n\n{{ value | date }} --&gt; 17 Sept 2025 (medium format is the default)\n{{ value | date(format='short') }} --&gt; 17/9/25\n{{ value | date(format='long') }} --&gt; 17 September 2025\n{{ value | date(format='full') }} --&gt; Wednesday, 17 September 2025\n{{ value | date(format='dd/MM/yyyy')}} --&gt; 17/09/2025\n</code></pre> <p>Locale can be specified explicitly, if required:</p> <pre><code>{{ value | datetime(locale='en_US') }} --&gt; Sep 17, 2025\n</code></pre> <p>If date strings need to be handled, they will need to be converted to a Python datetime.date instance first. For date strings guaranteed to be in ISO 8601 format, Python's standard <code>datetime.date.fromisoformat()</code> is fine. Otherwise, the safest way to do this for dates containing only numbers (no month names) is to use the parse_date filter as this is docma locale aware, unlike the Python standard datetime.datetime.strptime().</p> <p>Examples</p> <pre><code>{{ docma.datetime.date.fromisoformat('2025-09-1') | date }} --&gt; 1 Sept 2025\n{{ '1/9/2025' | parse_date | date }} --&gt; 1 Sept 2025\n{{ '1/9/2025' | parse_date(locale='en_US') | date }} --&gt; 9 Jan 2025\n</code></pre> <p>You are in a maze of twisty little passages, all alike ...</p> <p>There is no fully reliable way to parse arbitrary dates containing month names in a generic, locale-aware away. Don't be tempted to attempt this in a docma template. If you think you need to, you are either solving the problem the wrong way or solving the wrong problem.</p>"},{"location":"06-jinja-rendering.html#jinja-filter-datetime","title":"Jinja Filter: datetime","text":"<p>Format datetime values.</p> <p>This is a locale-aware filter that provides an interface to the Babel format_datetime() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting.</p> <p>The locale is determined as described in Locale in Docma Templates.  It can also be specified explicitly by adding a <code>locale</code> argument to the filter.</p> <p>The filter signature is:</p> <p>Filter Signature</p> <pre><code>datetime(value: datetime.date | datetime.datetime | datetime.time, *args, **kwargs) -&gt; str\n</code></pre> Parameter Description value Filter input value. Typically, this would be a <code>datetime.datetime</code> instance. While <code>datetime.date</code> and <code>datetime.time</code> instances are also accepted, they are unlikely to be particularly useful. *args Passed to Babel's format_datetime(). **kwargs Passed to Babel's format_datetime(). This includes the option of using the <code>locale</code> parameter to specify locale. <p>Examples</p> <p>Assuming locale is set to <code>en_AU</code>:</p> <pre><code>{% set value = docma.datetime.datetime(2025, 9, 17, 14, 15, 16) %}\n\n{{ value | datetime }} --&gt; 17 Sept 2025, 2:15:16 pm\n</code></pre> <p>Locale can be specified explicitly, if required:</p> <pre><code>{{ value | datetime(locale='en_US') }} --&gt; Sep 17, 2025, 2:15:16 PM\n</code></pre> <p>If datetime strings need to be handled, they will need to be converted to a Python datetime.datetime instance first. For datetime strings guaranteed to be in ISO 8601 format, Python's standard <code>datetime.datetime.fromisoformat()</code> is fine.</p> <p>Example</p> <pre><code>{{ docma.datetime.datetime.fromisoformat('2025-09-17T14:15:16') | datetime }}\n</code></pre> <p>Tip</p> <p>Avoid using the Python standard <code>datetime.datetime strptime()</code> if at all possible. This will use the platform locale and cannot handle the docma locale. The results can be very unpredictable.</p>"},{"location":"06-jinja-rendering.html#jinja-filter-decimal","title":"Jinja Filter: decimal","text":"<p>Format numeric values.</p> <p>This is a locale-aware filter that provides an interface to the Babel format_decimal() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting.</p> <p>The locale is determined as described in Locale in Docma Templates.  It can also be explicitly specified by adding a <code>locale</code> argument to the filter.</p> <p>Filter Signature</p> <pre><code>decimal(\n    value: str | int | float,\n    *args,\n    rounding: str = 'half-up',\n    default: int | float | str | None = None,\n    **kwargs\n) -&gt; str\n</code></pre> Parameter Description value Filter input value. Numbers and strings containing numbers are accepted. *args Passed to Babel's format_decimal(). rounding How to round the value. This must be one of the rounding modes in Babel's <code>decimal.ROUND_*</code>, with the <code>ROUND_</code> prefix removed. Case is ignored and hyphens become underscores. Defaults to <code>half-up</code> (Excel style rounding), instead of <code>half-even</code> (Bankers rounding) which is Python's normal default. default The default value to use for the filter if the input value is empty (i.e. None or an empty string, but not zero). If the input value is empty and <code>default</code> is a string, it is used as-is as the return value of the filter. If the input value is empty, and <code>default</code> is not specified, an error is raised. Otherwise, the default is assumed to be numeric and is used as the input to the filter. Note: The <code>default</code> parameter does something different to the Jinja standard default filter. They are both useful but not interchangeable. **kwargs Passed to Babel's format_decimal(). This includes the option of using the <code>locale</code> parameter to specify locale. <p>Examples</p> <p>Assuming locale is set to <code>en_AU</code>:</p> <pre><code>{{ 1234.5678 | decimal }} --&gt; 1,234.568 (Default is to round to 3 decimal places)\n{{ '1234.5678' | decimal }} --&gt; 1,234.568 (numeric strings are fine as input)\n{{ None | decimal }} --&gt; ERROR!\n{{ None | decimal(default=0) }} --&gt; 0\n{{ None | decimal(default='nix')}} --&gt; nix\n</code></pre> <p>Locale can be specified explicitly, if required:</p> <pre><code>{{ 1234.5678 | decimal(locale='fr_FR') }} --&gt; 1 234,568\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-dollars","title":"Jinja Filter: dollars","text":"<p>Round and format a currency value as dollars.</p> <p>Banker's half-up, rounding is used (like Excel) instead of the half-even rounding that is Python's normal default.</p> <p>This filter is a legacy that is not actually deprecated (yet), but its use is discouraged. Use the currency filter in preference.</p> <p>Filter Signature</p> <pre><code>dollars(value: str | int | float, precision: int = 2, symbol: str = '$') -&gt; str\n</code></pre> Parameter Description value A number or numeric string. precision Number of decimal places to show. Defaults to 2. symbol The currency symbol to show. Defaults to <code>$</code>. <p>Examples</p> <pre><code>{{ 1234.50 | dollars }} --&gt; $1,234.50\n{{ 1234.50 | dollars(0) }} --&gt; $1,235\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-parse_date","title":"Jinja Filter: parse_date","text":"<p>Parse a date string into a datetime.date instance.</p> <p>This is a locale-aware filter that provides an interface to the Babel parse_date() API.</p> <p>Filter Signature</p> <pre><code>parse_date(value: str, *args, **kwargs) -&gt; datetime.date\n</code></pre> Parameter Description value Filter input value. The parser understands component ordering variations by locale but cannot handle month names. Numbers only. *args Passed to Babel's parse_date(). **kwargs Passed to Babel's parse_date(). This includes the option of using the <code>locale</code> parameter to specify locale. <p>Examples</p> <p>Assuming locale is set to <code>en_AU</code>:</p> <pre><code>{{ '1/9/2025' | parse_date) }} --&gt; datetime.date(2025, 9, 1)\n</code></pre> <p>Locale can be specified explicitly, if required:</p> <pre><code>{{ '1/9/2025' | parse_date(locale='en_US') }} --&gt; datetime.date(2025, 1, 9)\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-parse_time","title":"Jinja Filter: parse_time","text":"<p>Parse a date string into a datetime.time instance.</p> <p>This is a locale-aware filter that provides an interface to the Babel parse_time() API.</p> <p>Filter Signature</p> <pre><code>parse_time(value: str, *args, **kwargs) -&gt; datetime.time\n</code></pre> Parameter Description value Filter input value. *args Passed to Babel's parse_time(). **kwargs Passed to Babel's parse_time(). This includes the option of using the <code>locale</code> parameter to specify locale. <p>Examples</p> <p>Assuming locale is set to <code>en_AU</code>:</p> <pre><code>{{ '2:15 pm' | parse_time) }} --&gt; datetime.time(14, 15)\n</code></pre> <p>Locale can be specified explicitly, if required:</p> <pre><code>{{ '1/9/2025' | parse_date(locale='en_US') }} --&gt; datetime.date(2025, 1, 9)\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-percent","title":"Jinja Filter: percent","text":"<p>Format percentage values.</p> <p>This is a locale-aware filter that provides an interface to the Babel format_percent() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting.</p> <p>The locale is determined as described in Locale in Docma Templates.  It can also be specified explicitly by adding a <code>locale</code> argument to the filter.</p> <p>Filter Signature</p> <pre><code>percent(\n    value: str | int | float,\n    *args,\n    rounding: str = 'half-up',\n    default: int | float | str | None = None,\n    **kwargs\n) -&gt; str\n</code></pre> Parameter Description value Filter input value. Numbers and strings containing numbers are accepted. *args Passed to Babel's format_percent(). rounding How to round the value. This must be one of the rounding modes in Babel's <code>decimal.ROUND_*</code>, with the <code>ROUND_</code> prefix removed. Case is ignored and hyphens become underscores. Defaults to <code>half-up</code> (Excel style rounding), instead of <code>half-even</code> (Bankers rounding) which is Python's normal default. default The default value to use for the filter if the input value is empty (i.e. None or an empty string). If the input value is empty and <code>default</code> is a string, it is used as-is as the return value of the filter. If the input value is empty, and <code>default</code> is not specified, an error is raised. Otherwise, the default is assumed to be numeric and is used as the input to the filter. Note: The <code>default</code> parameter does something different to the Jinja standard default filter. They are both useful but not interchangeable. **kwargs Passed to Babel's format_percent(). This includes the option of using the <code>locale</code> parameter to specify locale. <p>Examples</p> <p>Assuming locale is set to <code>en_AU</code>:</p> <pre><code>{{ 0.1234 | percent }} --&gt; 12%\n{{ '0.1234' | percent }} --&gt; 12%\n{{ None | percent }} --&gt; ERROR!\n{{ None | percent(default=0) }} --&gt; 0%\n{{ None | percent(default='--')}} --&gt; --\n</code></pre> <p>Locale can be specified explicitly, if required:</p> <pre><code>{{ '0.123' | percent(locale='fr_FR') }} --&gt; 12 %\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-phone","title":"Jinja Filter: phone","text":"<p>Format phone numbers. If a number cannot be formatted, the unmodified input is returned.</p> <p>This is a locale-aware filter.</p> <p>The underlying process is implemented using the excellent Python phonenumbers package, which is itself a port of Google's libphonenumber library.</p> <p>Phone number formatting varies substantially internationally. Hence, the filter needs to determine the relevant region for each phone number. It can do that in one of 3 ways (highest precedence to lowest)</p> <ol> <li> <p>An international code in the source phone number.</p> </li> <li> <p>An explicit region code argument to the phone filter (expressed as a     two-character ISO country code).</p> </li> <li> <p>By assuming the phone number is associated with the effective locale setting     For example, a locale setting of <code>en_AU</code> would imply the number is part of the     Australian phone numbering plan.</p> </li> </ol> <p>Filter Signature</p> <pre><code>phone(number: str, region: str = None, *, format: str = None) -&gt; str\n</code></pre> Parameter Description number The phone number input to the filter. Phone numbers are always strings, never integers. Ever. region The region to which the phone number belongs as a 2 character ISO country code. Ignored if the phone number includes an international code. If not specified, the country code from the current effective locale is used. format See below. <p>Phone numbers can be formatted in different ways. The following values of the <code>format</code>\u00a0parameter are supported:</p> Format Description E164 E.164 is the standard International Telecommunication Union (ITU) format for worldwide telephone numbers. e.g. <code>+61491570006</code> INTERNATIONAL The full international phone number, formatted as per national conventions. e.g. <code>+61 491 570 006</code> NATIONAL The national number component of the phone number without the international code component, formatted as per national conventions. e.g. <code>0491 570 006</code> RFC3966 The URI format for phone numbers. This will typically generate one-touch call links in on-line content. e.g. <code>tel:+61-491-570-006</code> <p>If not specified, <code>NATIONAL</code> is used if the region for the phone number matches that for the current locale and <code>INTERNATIONAL</code> otherwise.</p> <p>Examples</p> <p>Assuming locale is set to <code>en_AU</code>:</p> <pre><code>{{ '0491 570 006' | phone }} --&gt; 0491 570 006 (Locale will provide \"AU\" as region)\n{{ '+61 491 570 006' | phone }} --&gt; 0491 570 006 (Region comes from the number)\n{{ '4155550132' | phone('US') }} --&gt; +1 415-555-0132\n{{ '4155550132'| phone('US', format='NATIONAL') }} --&gt; (415) 555-0132\n{{ '4155550132'| phone('US', format='RFC3966') }} --&gt; tel:+1-415-555-0132\n{{ 'bad-to-the-phone' }} --&gt; bad-to-the-phone (If all else fails, return the input)\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-require","title":"Jinja Filter: require","text":"<p>Abort with an error message if the value is not a truthy value (i.e. a non-empty string, non-zero integer etc), otherwise return the value.</p> <p>This is useful for situations where it is better to abort if an expression is expected to have a value, but doesn't, rather than make assumptions.</p> <p>Filter Signature</p> <pre><code>require(value: Any) -&gt; Any\n</code></pre> <p>Example</p> <pre><code>Dear Bob,\n\nYour flight details have changed and your flight will now depart at\n{{ flight_time | require('flight_time must be a non-empty string') }}.\n\nDon't be late.\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-sql_safe","title":"Jinja Filter: sql_safe","text":"<p>Ensure that a string value is safe to use in SQL and generate an error if not.</p> <p>This is primarily for use in query specifications to avoid SQL injection. It has a puritanical view on safety but will cover most normal requirements.</p> <p>Filter Signature</p> <pre><code>sql_safe(value: str) -&gt; str\n</code></pre> <p>Example</p> <pre><code>SELECT * from {{ table | sql_safe }} ...\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-time","title":"Jinja Filter: time","text":"<p>Format time values.</p> <p>This is a locale-aware filter that provides an interface to the Babel format_time() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting.</p> <p>The locale is determined as described in Locale in Docma Templates.  It can also be specified explicitly by adding a <code>locale</code> argument to the filter.</p> <p>Filter Signature</p> <pre><code>time(value: datetime.time | datetime.datetime, *args, **kwargs) -&gt; str\n</code></pre> Parameter Description value Filter input value. This must be a <code>datetime.time</code> or <code>datetime.datetime</code> instance. *args Passed to Babel's format_time(). **kwargs Passed to Babel's format_time(). This includes the option of using the <code>locale</code> parameter to specify locale. <p>Examples</p> <p>Assuming locale is set to <code>en_AU</code>:</p> <pre><code>{% set value = docma.datetime.time(14, 15) %}\n\n{{ value | time }} --&gt; 2:15:00 pm\n</code></pre> <p>Locale can be specified explicitly, if required:</p> <pre><code>{{ value | datetime(locale='de_DE') }} --&gt; 14:15:00\n</code></pre> <p>If time strings need to be handled, they will need to be converted to a Python datetime.time instance first. The safest way to do this is to use the parse_time filter as this is docma locale aware.</p> <pre><code>{{ '14:15' | parse_time | time }} --&gt; 2:15:00 pm\n{{ '2:15 pm' | parse_time | time }} --&gt; 2:15:00 pm\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-filter-timedelta","title":"Jinja Filter: timedelta","text":"<p>Format timedelta values.</p> <p>This is a locale-aware filter that provides an interface to the Babel format_timedelta() API. All of its parameters can be used in the filter to obtain fine-grained control over formatting.</p> <p>The locale is determined as described in Locale in Docma Templates.  It can also be specified explicitly by adding a <code>locale</code> argument to the filter.</p> <p>Filter Signature</p> <pre><code>timedelta(value: datetime.timedelta | datetime.datetime | datetime.time, *args, **kwargs) -&gt; str\n</code></pre> Parameter Description value Filter input value. This must be a <code>datetime.timedelta</code> instance. *args Passed to Babel's format_timedelta(). **kwargs Passed to Babel's format_timedelta(). This includes the option of using the <code>locale</code> parameter to specify locale. <p>Tip</p> <p>The Babel format_timedelta()\u00a0 rounding process is not particularly intuitive on first appearance but makes sense once you get the hang of it. You may need to experiment with <code>threshold</code> and <code>granularity</code> arguments to get the desired effect.</p> <p>Examples</p> <p>Assuming locale is set to <code>en_AU</code>:</p> <pre><code>{% set d1 = docma.datetime.datetime(2025, 9, 17, 14, 15, 16) %}\n{% set d2 = docma.datetime.datetime(2025, 9, 19, 14, 15, 16) %}\n\n{{ (d2 - d1) | timedelta }} --&gt; 2 days (default format is 'long')\n{{ (d2 - d1) | timedelta(format='narrow') }} --&gt; 2d\n{{ (d2 - d1) | timedelta(add_direction=True) }} --&gt; in 2 days\n</code></pre> <p>Locale can be specified explicitly, if required:</p> <pre><code>{{ (d2 - d1) | timedelta(locale='uk_UA') }} --&gt; '2 \u0434\u043d\u0456'\n</code></pre>"},{"location":"06-jinja-rendering.html#docma-jinja-extensions","title":"Docma Jinja Extensions","text":"<p>Docma provides some custom Jinja extensions. In Jinja, extensions are invoked using the following syntax:</p> <pre><code>{% tag [parameters] %}\n</code></pre> <p>In addition to the custom extensions described below, docma also provides the following standard Jinja extensions:</p> <ul> <li>debug</li> <li>loopcontrols.</li> </ul>"},{"location":"06-jinja-rendering.html#jinja-extension-abort","title":"Jinja Extension: abort","text":"<p>The abort extension forces the rendering process to abort with an exception message. It would typically be used in response to some failed correctness check where it's preferable to fail document production rather than to proceed in error.</p> <p>For example:</p> <pre><code>{% if bad_data %}\n    {% abort 'Fatal error - bad data' %}\n{% endif %}\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-extension-dump_params","title":"Jinja Extension: dump_params","text":"<p>The dump_params extension simply dumps the rendering parameters for debugging purposes. The standard Jinja debug extension does something similar (and a bit more) but much less readably.</p> <p>Typical usage would be:</p> <pre><code>&lt;PRE&gt;{% dump_params %}&lt;/PRE&gt;\n</code></pre>"},{"location":"06-jinja-rendering.html#jinja-extension-global","title":"Jinja Extension: global","text":"<p>The global extension allows values defined within the Jinja content of a HTML document to be made available when rendering other components in a document template.</p> <p>For example, the following declares the globals <code>a</code> and <code>b</code>.</p> <pre><code>{% global a=1, b='Plugh' %}\n</code></pre> <p>These can then be accessed, either in the file in which they were declared or in a different HTML document, or a query specification like so:</p> <pre><code>You are at Y{{ globals.a + 1 }}. A hollow voice says \"{{ globals.b }}.\"\n</code></pre> <p>The result will be:</p> <pre><code>Your are at Y2. A hollow voice says \"Plugh\".\n</code></pre> <p>Compare this with the standard Jinja <code>set</code> operation:</p> <pre><code>{% set a=1 %}\n</code></pre> <p>The variable <code>a</code> can only be accessed in the file in which it is defined, or a file that includes that file. It cannot be accessed in a different HTML document, or a query specification</p> <p>Warning</p> <p>It is important to understand that within the docma rendering phase, the Jinja rendering of the component HTML documents is completed before the generation and injection of dynamic content. This means that only the final value of any global parameter is available during the dynamic content generation phase.</p> <p>It is not possible to use globals to pass a loop variable from the Jinja rendering of the HTML into the dynamic content generation phase.</p>"},{"location":"06-jinja-rendering.html#docma-format-checkers","title":"Docma Format Checkers","text":"<p>Docma includes an extensible set of format checkers. These can be used in two ways:</p> <ol> <li> <p>In JSON schema specifications     as <code>format</code> specifiers for <code>string</code> data elements; and</p> </li> <li> <p>As Jinja tests in content that will be     Jinja rendered.</p> </li> </ol> <p>The docma provided format checkers are divided into:</p> <ul> <li>Generic checkers</li> <li>Region / country specific checkers.</li> </ul> <p>All docma provided format checker names are case insensitive.</p> <p>It is easy to add new format checkers, as required.</p>"},{"location":"06-jinja-rendering.html#generic-format-checkers","title":"Generic Format Checkers","text":"Test Name Description date.dmy Date formatted as day/month/year. The separators can be any of <code>/-_.</code> or missing (e.g. <code>31/12/2024</code>, <code>31.12.2024</code>, <code>31-12-2024</code>, <code>31_12_2024</code>, <code>31122024</code>). date.mdy Date formatted as month/day/year. The separators can be any of <code>/-_.</code> or missing  (e.g. <code>12/31/2024</code>, ...). date.ymd Date formatted as year/month/day. The separators can be any of <code>/-_.</code> or missing (e.g. <code>2024/12/31</code>, ...). DD/MM/YYYY JSON Schema use only. Deprecated. Use <code>date.dmy</code> instead. energy_unit An energy unit (e.g. kWh, MVArh). locale A locale specifier (e.g. <code>en_AU</code>, <code>fr_FR</code>) power_unit A power unit (e.g. kW, MVA). semantic_version A version in the form <code>major.minor.patch</code> (e.g. <code>1.3.0</code>)."},{"location":"06-jinja-rendering.html#regional-format-checkers","title":"Regional Format Checkers","text":"Checker Name Description ACN Deprecated. Use <code>au.abn</code> instead. ABN Deprecated. Use <code>au.abn</code> instead. au.ABN Australian Business Number. au.ACN Australian Company Number. au.MIRN Australian energy industry Gas Meter Installation Registration Number. au.NMI Australian energy industry National Metering Identifier. MIRN Deprecated. Use <code>au.MIRN</code> instead. NMI Deprecated. Use au.NMI instead."},{"location":"06-jinja-rendering.html#format-checkers-in-json-schema","title":"Format Checkers in JSON Schema","text":"<p>JSON Schema specifications are supported, and strongly recommended, in a number of docma components, such as as the template configuration file, and query specifications. They provide run-time type checking of important data elements and are an important safety mechanism.</p> <p>Like the JSON Schema built-in string formats, docma provided format checkers can be used in a schema specification with the <code>format</code> attribute of string objects, like so:</p> <pre><code>type: object\nproperies:\n  prop1:\n    type: string\n    # Use a built in format like \"email\" or one of docma's format checkers\n    format: ... \n</code></pre> <p>Note</p> <p>Examples are given in YAML rather than JSON for readability, and because they are specified in YAML in docma.</p> <p>For example, consider a document template for a contract that requires parameters for customer email, contract start date, and customer Australian Business Number (ABN) to be specified: The relevant portion of the template configuration file might look like this:</p> <pre><code>parameters:\n  schema:\n    # Schema for the schema!\n    $schema: https://json-schema.org/draft/2020-12/schema\n    title: Parameters validation schema\n    type: object\n    required:\n      - locale\n      - customer_email\n      - customer_abn\n      - contract_start_date\n    properties:\n      locale:\n        type: string\n        format: locale  # This is a docma provided format checker\n      customer_email:\n        type: string\n        format: email  # This is a standard JSON schema format checker\n      customer_abn:\n        type: string\n        format: au.ABN   # This is a docma provided format checker.\n      contract_start_date:\n        type: string\n        format: date.dmy  # This is a docma provided format checker\n</code></pre> <p>Docma will validate values provided at run-time against this schema.</p>"},{"location":"06-jinja-rendering.html#format-checkers-in-jinja","title":"Format Checkers in Jinja","text":"<p>In addition to the standard tests provided by Jinja, the docma format checkers can also be used as Jinja tests, like so:</p> <pre><code>{% if contract_date is not date.dmy %}\n{% abort 'Bad date' %}\n{% endif %}\n</code></pre> <p>When used as Jinja tests, none of the docma format checkers accept an arguments additional to the value being checked. </p> <p>Note</p> <p>Docma can also be extended with Jinja tests that can accept additional arguments, but these would not also be used in JSON Schema specifications and hence would not be considered to be format checkers.</p>"},{"location":"07-charts-and-graphs.html","title":"Charts and Graphs in Docma","text":"<p>Docma supports the Vega-Lite declarative syntax for specifying charts / graphs. Vega-Lite specifies a mapping between source data and visual representations of the data.</p> <p>To make all this work in docma requires three things:</p> <ol> <li> <p>A means to tell docma that a chart needs to be generated. This is done using     a special URL format within <code>&lt;IMG&gt;</code> tags in the source HTML.     See Charts in HTML Content.</p> </li> <li> <p>A means to specify the design of the chart. This is done with a     chart specification file within the document     template.</p> </li> <li> <p>A means to feed data to the chart creation process.     See Source Data for Charts.</p> </li> </ol>"},{"location":"07-charts-and-graphs.html#charts-in-html-content","title":"Charts in HTML Content","text":"<p>Docma provides a URL based mechanism to trigger creation of charts during the process of converting input HTML to a PDF or HTML output document. See Dynamic Content Generation for more details.</p> <p>It looks like this:</p> <pre><code>&lt;IMG src=\"docma:vega?spec=charts/my-chart.yaml&amp;data=...\"&gt;\n</code></pre> <p>In a nutshell, when docma sees a URL in this form, it knows to get data from the source specified by the <code>data</code> parameter and feed it into the chart generator with the Vega-Lite specification indicated by the <code>spec</code> parameter:</p> <p>Normal CSS styling can also be applied:</p> <pre><code>&lt;IMG style=\"width: 5cm;\"\n    src=\"docma:vega?spec=charts/my-chart.yaml&amp;data=...\"&gt;\n</code></pre> <p>Here is a more complete example, showing how Jinja can help build the <code>src</code> URL structure safely:</p> <pre><code>&lt;IMG style=\"width: 10cm;\" src=docma:vega?{{\n  (\n    ( 'spec', 'charts/my-chart.yaml' ),\n    ( 'data', 'file;data/my-data.csv' ),\n    ( 'params', { 'extra_rendering_param': 1234 } | tojson)\n  ) | urlencode\n}}\"&gt;\n</code></pre> <p>See also docma scheme parameters for vega charts.</p>"},{"location":"07-charts-and-graphs.html#chart-specification-files","title":"Chart Specification Files","text":"<p>The chart specification is a file in the document template containing a Vega-Lite chart definition.</p> <p>The chart specification will be Jinja rendered prior to use.</p> <p>The chart specification can be in either JSON or YAML format. Docma doesn't care which. There are pros and cons with each format. YAML is easier to write and to read but JSON is the native format of the examples in the Vega-Lite sample gallery or the Vega-Lite on-line editor. You're  going to want to use both of these resources.</p> <p>The chart specification file should still have a <code>.yaml</code> suffix, even if the contents are JSON. This all works because valid JSON is also valid YAML.</p> <p>Note</p> <p>Docma uses the Vega-Altair Python package to process Vega-Lite specifications.</p>"},{"location":"07-charts-and-graphs.html#source-data-for-charts","title":"Source Data for Charts","text":"<p>The value of the <code>data</code> parameter in a <code>docma:vega?...</code> URL is a docma data source specification that indicates where to obtain the data and where to attach it to the chart specification.</p> <p>The <code>data</code> parameter can be used multiple times if there are multiple data sources in the chart.</p> <p>If the <code>data</code> parameter is not specified, the source data is assumed to be contained within the chart specification itself. This can actually be useful when designing a chart to avoid the need to wrangle external data when experimenting.</p> <p>See Data Sources in Docma for more information.</p>"},{"location":"07-charts-and-graphs.html#tips-and-suggestions-for-designing-charts","title":"Tips and Suggestions for Designing Charts","text":"<p>The Vega-Lite website has lots of resources to help with designing charts. This section just provides a few tips and suggestions.</p> <p>Some suggestions for simplifying the development:</p> <ul> <li> <p>Where possible, start with a chart from the     Vega-Lite sample gallery and     play with it in the on-line editor to get close to what you are after.</p> </li> <li> <p>Include a small sample data set in the chart specification to allow     experimentation. The sample data can be left in the specification when     included into a docma document template. Docma will replace it at run-time.</p> </li> <li> <p>Charts reference a JSON schema:     <code>$schema: https://vega.github.io/schema/vega-lite/v5.json</code>. PyCharm will     interpret this and provide some auto completion and validation as you go.</p> </li> <li> <p>Believe it, or not, but ChatGPT is surprisingly helpful with Vega-Lite. It     can often give meaningful answers to enquiries like these:</p> <ul> <li> <p>Explain this Vega-Lite specification to me ... (paste the JSON in)</p> </li> <li> <p>I have this Vega-Lite specification. How do I remove the axes and     change the colour on the bars?</p> </li> <li> <p>Design a Vega-Lite chart that shows a heat map of ... with ... on the x     axis and ... on the y axis</p> </li> </ul> </li> <li> <p>ChatGPT can get confused with obscure concepts (like interval meter data).     You can often replace this with more generic data in the questions     (temperature data is a good substitute for interval data).</p> </li> <li> <p>Layers are quite an     important concept in Vega-Lite. Make an effort to understand them.</p> </li> </ul>"},{"location":"07-charts-and-graphs.html#samples","title":"Samples","text":"<p>With a bit of effort, Vega-Lite does a surprisingly good job of generating good looking charts with a small amount of specification.</p> <p>Here are a few examples.</p> Bar Chart <p>This is a bar chart of dog woof-power.</p> ChartChart Specification File <p></p> <p>This is the specification file (with truncated data).</p> <pre><code>$schema: 'https://vega.github.io/schema/vega-lite/v5.json'\nwidth: 300\nconfig:\n  font: Avenir\n  background: '#eeeeee'\n  padding: 10\n  view:\n    stroke: transparent\n  axisX:\n    grid: false\n    gridWidth: 0.5\n    domainDash:\n      - 4\n      - 4\n    formatType: number\n  axisY:\n    grid: false\ndata:\n  values:\n    - Dog: Bolliver\n      Woof: 28\nview:\n  fill: '#eeeeee'\nencoding:\n  'y':\n    field: Dog\n    title: Dog\n    type: ordinal\n    axis: null\nlayer:\n  - mark:\n      type: bar\n      cornerRadius: 20\n    encoding:\n      x:\n        field: Woof\n        title: null\n        type: quantitative\n      color:\n        field: Woof\n        type: quantitative\n        title: '% Woof'\n        scale:\n          domain: [ 0, 100 ]\n          range: [ '#fec72b', '#fa4617' ]\n  - mark:\n      type: text\n      align: left\n      x: 10\n      color: white\n      fontWeight: bold\n    encoding:\n      text:\n        field: Dog\n</code></pre> Heat Map <p>This heat map shows electricity interval meter data.</p> ChartChart specification file <p></p> <pre><code>$schema: 'https://vega.github.io/schema/vega-lite/v5.json'\ntitle: 'Daily Usage'\nconfig:\n  font: Avenir\n  view:\n    continuousWidth: 300\n    continuousHeight: 300\n    step: 13\n    strokeWidth: 0\n  axis:\n    domain: false\ndata:\n  name: usage_by_day\n\nmark:\n  type: rect\nencoding:\n  color:\n    aggregate: max\n    field: kwh\n    legend:\n      title: kWh\n    type: quantitative\n    scale:\n      range: [ '#fec72b', '#fa4617' ]\n  x:\n    axis:\n      format: '%e'\n      labelAngle: 0\n    field: date\n    timeUnit: date\n    title: Day\n    type: ordinal\n  y:\n    field: date\n    timeUnit: month\n    title: Month\n    type: ordinal\ndatasets:\n  # Sample data -- this gets replaced\n  usage_by_day:\n    - date: 2023-07-01\n      kwh: 1234\n</code></pre>"},{"location":"08-data-sources.html","title":"Data Sources in Docma","text":"<p>Docma can access data files and live data sources during the rendering phase. This is done by the data provider subsystem. The returned data can be used in the following ways:</p> <ul> <li> <p>Source data for charts and graphs.</p> </li> <li> <p>Injection into the Jinja rendering process for     HTML content (e.g. for     tables or other variable content).</p> </li> </ul> <p>Data providers return their data as a list of objects, one row of data per object.</p> <p>Tip</p> <p>Be careful with dataset sizes. This interface is not designed for very large amounts of data. Do as much data preparation / reduction outside of docma as possible (e.g. via database queries to generate just the essential data).</p>"},{"location":"08-data-sources.html#data-source-specifications","title":"Data Source Specifications","text":"<p>Docma uses the concept of data source specifications to control the process of obtaining the data and what to do with it. They contain the following components.</p> Component Description type The data provider type (e.g. <code>file</code> if the data comes from a file). This controls the connection / access mechanism. location Where to find the data. For a file based source it would be the path to the file. For a database provider, it would point to the connection information for the database. query The file name in the document template containing a query specification that defines a query to execute on the data provider. This is required for database-like sources. It is not used for some data provider types. target For charts, the position in the Vega-Lite specification where the data will be attached. This is a dot separated dictionary key sequence pointing into the chart specification. If not provided, this defaults to <code>data.values</code>, which is the primary data location for a Vega-Lite specification."},{"location":"08-data-sources.html#data-source-specifications-for-charts","title":"Data Source Specifications for Charts","text":"<p>The HTML to include a chart is of the form:</p> <pre><code>&lt;IMG src=\"docma:vega?spec=charts/my-chart.yaml&amp;data=...\"&gt;\n</code></pre> <p>The value of the <code>data</code> parameter is a docma data source specification expressed in string form, like so:</p> <pre><code>data=type;location[;query[;target]\n</code></pre> <p>Question</p> <p>Why jam all this together into a single URL parameter rather than have separate parameters for each component? The reason is because a Vega-Lite chart can have multiple data sources and hence multiple instances of the <code>data</code> parameter.</p> <p>It can be fiddly combining all these components in a URL in a readable way. The recommended approach is to use Jinja to assemble all the pieces and handle the gory details of URL encoding, like so:</p> <pre><code>&lt;IMG style=\"width: 10cm;\" src=docma:vega?{{\n  (\n    ( 'spec', 'charts/my-chart.yaml' ),\n    ( 'data', 'file;data/my-data.csv' ),\n    ( 'data', 'file;data/more-data.csv;;datasets.more_data' ),\n    (\n      'data', (\n        'postgres', 'pgdb01', 'queries/usage-by-day.yaml', 'datasets.usage_by_day'\n      ) | join(';'),\n    ),\n  ) | urlencode\n}}\"&gt;\n</code></pre> <p>In this example, three data sets are specified:</p> <ol> <li> <p>The first one is extracted from a local CSV file and attached to the chart     specification at the default location of <code>data.values</code> (i.e the <code>values</code>     object under the <code>data</code> object is replaced with our CSV data).</p> </li> <li> <p>The second one is extracted from a local CSV file and attached to the chart     specification as the <code>datasets.more_data</code> object in the specification. Note     that the unused <code>query</code> component must be provided as an empty string to ensure the     <code>target</code> component is correctly placed.</p> </li> <li> <p>The third one is extracted by running a query against a Postgres database     and attached to the chart specification as the <code>datasets.usage_by_day</code>     object in the specification.</p> </li> </ol>"},{"location":"08-data-sources.html#data-source-specifications-for-html-rendering","title":"Data Source Specifications for HTML Rendering","text":"<p>A data source specification can be invoked directly in Jinja content within a document that is to be rendered. </p> <p>This is done using the <code>docma.data()</code> function provided in the run-time rendering parameters. It accepts three arguments corresponding to the first three components of a data source specification:</p> <ul> <li>type </li> <li>location</li> <li>query (optional).</li> </ul> <p>The <code>docma.data()</code> function also accepts an optional <code>params</code> argument which is a dictionary of additional parameter values that will be merged into the Jinja rendering parameters when rendering the query specification.</p> <p>See also Jinja Rendering Parameters Provided by Docma.</p> <p>For example, the following document content invokes the postgres data provider to run a query on the Custard Appreciation Society membership records and present the data in a table.</p> <pre><code>&lt;TABLE&gt;\n  &lt;THEAD&gt;\n  &lt;TR&gt;\n    &lt;TH&gt;Custard Type&lt;/TH&gt;\n    &lt;TH&gt;Bid Price&lt;/TH&gt;\n  &lt;/TR&gt;\n  &lt;/THEAD&gt;\n  &lt;TBODY&gt;\n  {% for row in docma.data('postgres', 'pgdb01', 'queries/custard-price.yaml') %}\n    &lt;TR&gt;\n      &lt;TD&gt;{{ row.favouritecustard }}&lt;/TD&gt;\n      &lt;TD&gt;{{ row.price | dollars(2) }}&lt;/TD&gt;\n    &lt;/TR&gt;\n  {% endfor %}\n  &lt;/TBODY&gt;\n&lt;/TABLE&gt;\n&lt;/BODY&gt;\n&lt;/HTML&gt;\n</code></pre> <p>If a query only returns a single row, that would be referenced like so:</p> <pre><code>{{ docma.data(...)[0] }}\n</code></pre> <p>... or ...</p> <pre><code>{{ docma.data(...) | first }}\n</code></pre>"},{"location":"08-data-sources.html#query-specifications","title":"Query Specifications","text":"<p>Some data providers require a query to be specified to extract the data. In docma, this is done using a query specification.</p> <p>A query specification is a YAML formatted file in the document template. It is referenced as the third element of a data source specification. These should be placed in the <code>queries</code> directory in the template.</p> <p>Docma thus externalises all database queries into a single, visible collection rather than embedding them in random places within the template document components.</p> <p>A query specification file contains the DML of the query to be executed as well as information on how to handle query parameters. It contains the following keys:</p> Key Type Required Description description String Yes A description for human consumption. Not used by docma. options Object No Query control options. --&gt; fold_headers Boolean No Convert all headers to lowercase (prior to row validation). This is sometimes necessary as different database drivers can handle the case treatment of headers in different ways. The default is <code>false</code>. --&gt; row_limit Integer No Abort if the query returns more than the specified number of rows. This is a safety mechanism. The default is 0, meaning no limit is applied. parameters List No A list of query parameter specification objects. If empty, the query has no parameters (which would be unusual). The parameter values are Jinja rendered using the run-time rendering parameters. query String Yes The query text. This will be Jinja rendered using the run-time rendering parameters. schema Object No A JSON Schema specification for each row of data returned by the query. See Query Schemas below. <p>Here's a sample:</p> <pre><code>description: Extract Custard Appreciation Society membership records\n\nquery: &gt;-\n  SELECT * FROM \"{{ db.schema | sql_safe }}\".custard\n  WHERE favouritecustard=%s\n    AND custardbidprice &gt; %s\n    AND custardjedi=%s;\n  SORT BY surname;\n\nparameters:\n  - name: favouritecustard\n    value: '{{ db.favouritecustard }}'\n  - name: custardbidprice\n    value: '{{ db.custardbidprice }}'\n    type: decimal\n  - name: custardjedi\n    value: '{{ db.custardjedi }}'\n    type: boolean\n\noptions:\n  row_limit: 20\n  fold_headers: true\n</code></pre>"},{"location":"08-data-sources.html#query-text","title":"Query Text","text":"<p>The query itself is pretty vanilla (ha!) SQL with some notable exceptions.</p> <p>Firstly, the query text will be Jinja rendered with the docma run-time rendering parameters. This makes it easy to do things such as switching schemas without having to alter the document template. (This is close to impossible in some popular analytics platforms that shall remain nameless.)</p> <p>Tip</p> <p>It is probably best not to embed data source specification references within a query specification (i.e. recursive calls to the data provider subsystem). Don't cross the streams.</p> <p>Care is required to avoid SQL injection risks. In the example above, the schema is quoted and also filtered using the docma specific sql_safe Jinja filter. This filter will abort if the value contains something unsafe.</p> <p>Secondly, the values for query parameters are replaced with placeholders. The actual values are determined at run-time from the parameter specifications. The placeholder is database driver specific unfortunately, based on the paramstyle it uses. The <code>pg8000</code> driver used for Postgres uses <code>%s</code> style, whereas DuckDB uses <code>?</code>. It's not my fault.</p> <p>Danger</p> <p>DO NOT attempt to use Jinja to format query parameters into the SQL text itself. This is seriously unsafe. Use query parameter specifications.</p> <p>Thirdly, when the data is to be used in a Vega-Lite chart, all of the data returned by the query needs to be JSON serialisable. i.e.  Python types such as <code>datetime</code>, <code>Decimal</code> etc will be a problem. The query should type cast everything to types that can be JSON serialised. For example:</p> <pre><code>-- This will not work ...\nSELECT date_of_birth as dob, height_in_cm as height\nFROM people;\n\n-- This will work (Postgres syntax) ...\nSELECT date_of_birth::text as dob, height_in_cm::float as height\nFROM people;\n</code></pre>"},{"location":"08-data-sources.html#query-parameters","title":"Query Parameters","text":"<p>Query parameters are specified as a list of query parameter specification objects. These contain the following keys:</p> Key Type Required Description name String Yes The parameter name. This is used for database drivers that support <code>named</code> and <code>pyformat</code> paramstyles. It is mandatory for all parameters for maintainability. value String Yes The parameter value. In many cases this will be a Jinja value injection construct. type String No A type indicator. Docma uses this to cast the value to the specified type. Only the following are supported: <code>str</code> / <code>string</code>, <code>int</code> / <code>integer</code>, <code>float</code>, <code>decimal</code>, <code>bool</code> / <code>boolean</code>. The default is <code>string</code>. Alternatively, cast string values within the DML. <p>These are supplied to the query at run-time using the DBAPI 2.0 driver's query parameter mechanism to avoid SQL injection risks.</p>"},{"location":"08-data-sources.html#query-schemas","title":"Query Schemas","text":"<p>In some situations, it may be important to validate that the data returned by a query meets certain conditions and to abort document production if it does not. This can be achieved by including a <code>schema</code> object in the query  specification.</p> <p>Tip</p> <p>The data preparation process should take proper care to ensure valid data. Query Schemas are the last line of defence against bad data appearing in documents.</p> <p>The <code>schema</code> object is a JSON Schema specification that is used to validate each row of data. Validation failures will abort the process. Note that all rows are returned as objects with keys based on the column names in the query.</p> <p>For example, consider the following query specification:</p> <pre><code>description: Get company information.\n\nquery: &gt;-\n  SELECT name, age_in_years, abn\n  FROM companies;\n\n# This schema will validate each row. We don't have to\n# validate every attribute in a row. Just the ones we're\n# worried about.\nschema:\n  type: object  # It's always one object per row of data\n  properties:\n    age_in_years:\n      type: number\n      minimum: 0\n      maximum: 200\n    abn:\n      type: string\n      format: au.ABN  # This is a docma provided format checker\n</code></pre> <p>In addition to the standard format specifiers supported by JSON Schema, the format checkers provided by docma are available for <code>string</code> objects.</p>"},{"location":"08-data-sources.html#data-provider-types","title":"Data Provider Types","text":"<p>The data provider interface is readily extensible to add new data sources. See Data Providers.</p>"},{"location":"08-data-sources.html#data-provider-type-duckdb","title":"Data Provider Type: duckdb","text":"<p>Docma can read data from a local file containing a DuckDB database.</p> <p>The DuckDB data provider is a useful mechanism for handling data extracts with docma. Docma, running on a DuckDB data extract can be quite fast, even with moderately large datasets.</p> <p>Why DuckDB?</p> <p>Why DuckDB rather than, for example, SQLite? DuckDB has a much more complete SQL implementation than SQLite, and one which is much closer to Postgres. It also has a very powerful and flexible mechanism for accessing data from other sources (files in various formats, AWS S3 etc.). And it goes like the clappers.</p> <p>The <code>type</code> component of the data source specification is <code>duckdb</code>.</p> <p>The <code>location</code> component is the name of a local file (not a template file) containing the database.</p> <p>The <code>query</code> component is the name of a query specification file.</p> <p>Examples</p> ChartHTML Table <p>This example shows a DuckDB database being used to supply data to a chart  (using Jinja tuple notation):</p> <pre><code>&lt;IMG\n    style=\"width: 10cm;\"\n    src=\"docma:vega?{{ (\n        ( 'spec', 'charts/dog-woof-power-chart.yaml' ),\n        ( 'data', 'duckdb;/tmp/demo/dogs.db;queries/woof-power.yaml' ),\n    ) | urlencode }}\"\n&gt;\n</code></pre> <p>This example shows a DuckDB database being used to populate an HTML table:</p> <pre><code>    &lt;TABLE&gt;\n      &lt;THEAD&gt;\n      &lt;TR&gt;\n        &lt;TH&gt;Dog&lt;/TH&gt;\n        &lt;TH class=\"Woof\"&gt;Woof&lt;/TH&gt;\n      &lt;/TR&gt;\n      &lt;/THEAD&gt;\n      &lt;TBODY&gt;\n      {% for row in docma.data('duckdb', '/tmp/demo/dogs.db', 'queries/woof-power.yaml') %}\n      &lt;TR&gt;\n        &lt;TD class=\"Dog\"&gt;{{ row.Dog }}&lt;/TD&gt;\n        &lt;TD class=\"Woof\"&gt;{{ row.Woof }}&lt;/TD&gt;\n      &lt;/TR&gt;\n      {% endfor %}\n      &lt;/TBODY&gt;\n    &lt;/TABLE&gt;\n</code></pre>"},{"location":"08-data-sources.html#data-provider-type-file","title":"Data Provider Type: file","text":"<p>Docma can read data from static files contained within the compiled document template.</p> <p>The <code>type</code> component of the data source specification is <code>file</code>.</p> <p>The <code>location</code> component is the name of the file, relative to the root of the template. Handling is determined based on the file suffix. The following formats are supported:</p> File Suffix Description csv A CSV file with a header line. The excel dialect is assumed. jsonl A file containing one JSON formatted object per line. <p>The <code>query</code> component is not used.</p> <p>Examples</p> CSV DataChartHTML Table <p>In these examples, the csv file (<code>data/dogs.csv</code>) might look something like this:</p> <pre><code>Dog,Woof\nBolliver,28\nRin Tin Tin,55\nFido,43\nKipper,91\nZoltan,81\nPluto,53\nScooby,24\nCerberus,87\nSnoopy,52\n</code></pre> <p>This example shows a CSV file being used to supply data to a chart (using Jinja tuple notation):</p> <pre><code>&lt;IMG\n    style=\"width: 10cm; justify-self: start;\"\n    src=\"docma:vega?{{ (\n          ( 'spec', 'charts/woof.yaml'),\n          ( 'data', 'file;data/dogs.csv'),\n        ) | urlencode }}\"\n&gt;\n</code></pre> <p>This example shows a CSV file being used to populate an HTML table:</p> <pre><code>&lt;TABLE&gt;\n  &lt;THEAD&gt;\n  &lt;TR&gt;\n    &lt;TH&gt;Dog&lt;/TH&gt;\n    &lt;TH class=\"Woof\"&gt;Woof&lt;/TH&gt;\n  &lt;/TR&gt;\n  &lt;/THEAD&gt;\n  &lt;TBODY&gt;\n  {% for row in docma.data('file', 'data/dogs.csv', 'queries/woof-power.yaml') %}\n  &lt;TR&gt;\n    &lt;TD class=\"Dog\"&gt;{{ row.Dog }}&lt;/TD&gt;\n    &lt;TD class=\"Woof\"&gt;{{ row.Woof }}&lt;/TD&gt;\n  &lt;/TR&gt;\n  {% endfor %}\n  &lt;/TBODY&gt;\n&lt;/TABLE&gt;\n</code></pre>"},{"location":"08-data-sources.html#data-provider-type-lava","title":"Data Provider Type: lava","text":"<p>If the lava package is installed, docma can use the lava connection subsystem to read data from a database. Lava provides support for connecting to a range of database types, including Postgres, Redshift, SQL Server, MySQL and Oracle. It also manages all of the connection details, credentials etc.</p> <p>The <code>type</code> component of the data source specification is <code>lava</code>.</p> <p>The <code>location</code> component is a lava connection ID for a database.</p> <p>The <code>query</code> component is the name of a query specification file.</p> <p>The lava realm must be specified during rendering, either by setting the <code>LAVA_REALM</code> environment variable, or via the <code>--realm</code> argument to the CLI.</p> <p>Info</p> <p>The query text must use a paramstyle that matches the underlying driver being used by lava. Refer to the lava user guide for more information.</p> <p>Examples</p> ChartHTML Table <p>This example shows a lava database connector (ID=<code>redshift/prod</code>) being used to supply data to a chart (using Jinja tuple notation):</p> <pre><code>&lt;IMG\n    style=\"width: 10cm;\"\n    src=\"docma:vega?{{ (\n        ( 'spec', 'charts/dog-woof-power-chart.yaml' ),\n        ( 'data', 'lava;redshift/prod;queries/woof-power.yaml' ),\n    ) | urlencode }}\"\n&gt;\n</code></pre> <p>This example shows a lava database connector (ID=<code>redshift/prod</code>) being used to populate an HTML table:</p> <pre><code>&lt;TABLE&gt;\n  &lt;THEAD&gt;\n  &lt;TR&gt;\n    &lt;TH&gt;Dog&lt;/TH&gt;\n    &lt;TH class=\"Woof\"&gt;Woof&lt;/TH&gt;\n  &lt;/TR&gt;\n  &lt;/THEAD&gt;\n  &lt;TBODY&gt;\n  {% for row in docma.data('lava', 'redshift/prod', 'queries/woof-power.yaml') %}\n  &lt;TR&gt;\n    &lt;TD class=\"Dog\"&gt;{{ row.Dog }}&lt;/TD&gt;\n    &lt;TD class=\"Woof\"&gt;{{ row.Woof }}&lt;/TD&gt;\n  &lt;/TR&gt;\n  {% endfor %}\n  &lt;/TBODY&gt;\n&lt;/TABLE&gt;\n</code></pre>"},{"location":"08-data-sources.html#data-provider-type-params","title":"Data Provider Type: params","text":"<p>Docma can extract data from a list of objects in the rendering parameters.</p> <p>The <code>type</code> component of the data source specification is <code>params</code>.</p> <p>The <code>location</code>  component is a dot separated key sequence to select a data list within the parameters. Each element of the list must be an object (not a string).</p> <p>The <code>query</code> component is not used.</p> <p>Examples</p> Source DataChartHTML Table <p>Consider the following rendering parameters:</p> <pre><code>param1: value1\nparam2: value2\n\ndata:\n  custard:\n    prices:\n      - type: lumpy\n        price: 1.53\n      - type: baked\n        price: 2.84\n      - type: runny\n        price: 3.50\n</code></pre> <p>A data source specification of <code>params;data.custard.prices</code> would return the following data rows:</p> <pre><code>{ \"type\": \"lumpy\", \"price\": 1.53 }\n{ \"type\": \"baked\", \"price\": 2.84 }\n{ \"type\": \"runny\", \"price\": 3.5 }\n</code></pre> <p>This example shows rendering parameters being used to supply data to a  chart (using Jinja tuple notation):</p> <pre><code>&lt;IMG\n    style=\"width: 10cm;\"\n    src=\"docma:vega?{{ (\n        ( 'spec', 'charts/custard-prices-chart.yaml' ),\n        ( 'data', 'params;data.custard.prices' ),\n    ) | urlencode }}\"\n&gt;\n</code></pre> <p>This example shows rendering parameters being used to populate an HTML table:</p> <pre><code>&lt;TABLE&gt;\n  &lt;THEAD&gt;\n  &lt;TR&gt;\n    &lt;TH&gt;Custard Type&lt;/TH&gt;\n    &lt;TH class=\"price\"&gt;Price&lt;/TH&gt;\n  &lt;/TR&gt;\n  &lt;/THEAD&gt;\n  &lt;TBODY&gt;\n  {% for row in docma.data('params', 'data.custard.prices') %}\n  &lt;TR&gt;\n    &lt;TD class=\"type\"&gt;{{ row.type }}&lt;/TD&gt;\n    &lt;TD class=\"price\"&gt;{{ row.price }}&lt;/TD&gt;\n  &lt;/TR&gt;\n  {% endfor %}\n  &lt;/TBODY&gt;\n&lt;/TABLE&gt;\n</code></pre>"},{"location":"08-data-sources.html#data-provider-type-postgres","title":"Data Provider Type: postgres","text":"<p>Docma can read data from a Postgres database.</p> <p>The <code>type</code> component of the data source specification is <code>postgres</code>.</p> <p>The <code>location</code> component is an alpha-numeric label for the database. This is used to determine connection details from environment variables or the contents of a <code>.env</code> file.</p> <p>If the <code>location</code> component is <code>xyz</code>, then docma will read the following values from a <code>.env</code> file to connect to the database.</p> Name Description XYZ_USER Database user name XYZ_PASSWORD Password. Exactly one of <code>XYZ_PASSWORD</code> and <code>XYZ_PASSWORD_PARAM</code> must be specified. XYZ_PASSWORD_PARAM AWS SSM parameter containing the password. XYZ_HOST Host name XYZ_PORT Port number XYZ_DATABASE Database name XYZ_SSL A truthy value specifying if SSL should be enforced (default <code>no</code>) <p>Values can also be overridden by environment variables with the same names as above, prefixed with <code>DOCMA_</code>. e.g. <code>DOCMA_XYZ_USER</code>.</p> <p>Danger</p> <p>Take care to ensure the <code>.env</code> file is excluded from any GIT repo. A redacted sample is provided in the <code>test</code> directory.</p> <p>The <code>query</code> component is the name of a query specification file.</p> <p>Examples</p> ChartHTML Table <p>This example shows a Postgres database being used to supply data to a chart (using Jinja tuple notation):</p> <pre><code>&lt;IMG\n    style=\"width: 10cm;\"\n    src=\"docma:vega?{{ (\n        ( 'spec', 'charts/dog-woof-power-chart.yaml' ),\n        ( 'data', 'postgres;prod01;queries/woof-power.yaml' ),\n    ) | urlencode }}\"\n&gt;\n</code></pre> <p>This example shows a Postgres database being used to populate an HTML table:</p> <pre><code>&lt;TABLE&gt;\n  &lt;THEAD&gt;\n  &lt;TR&gt;\n    &lt;TH&gt;Dog&lt;/TH&gt;\n    &lt;TH class=\"Woof\"&gt;Woof&lt;/TH&gt;\n  &lt;/TR&gt;\n  &lt;/THEAD&gt;\n  &lt;TBODY&gt;\n  {% for row in docma.data('postgres', 'prod01', 'queries/woof-power.yaml') %}\n  &lt;TR&gt;\n    &lt;TD class=\"Dog\"&gt;{{ row.Dog }}&lt;/TD&gt;\n    &lt;TD class=\"Woof\"&gt;{{ row.Woof }}&lt;/TD&gt;\n  &lt;/TR&gt;\n  {% endfor %}\n  &lt;/TBODY&gt;\n&lt;/TABLE&gt;\n</code></pre>"},{"location":"09-fonts.html","title":"Fonts","text":"<p>Note</p> <p>This section primarily applies to PDF output documents. For HTML output documents, font handling is exactly as it is for HTML in general. Docma does not embed fonts in HTML output documents.</p> <p>Docma inherits the font handling capabilities of WeasyPrint, which are essentially those of native HTML / CSS. TrueType (TTF), OpenType (OTF) and Web Open Font Format (WOFF), but not WOFF2, fonts should work fine.</p> <p>Warning</p> <p>Fonts are Intellectual Property and may be subject to licence conditions, just like software. Take care to comply with licence terms and be aware that the font is likely to be embedded in the PDF produced by docma. Google fonts is quite a good source for royalty free fonts.</p> <p>Fonts installed on the base platform generally can be used directly in CSS styles. However, it is risky to rely on this beyond the most basic common font types (e.g. Sans Serif). A template that is developed and compiled on one platform may be rendered on a different platform with different fonts. It will still render, in most cases, but may not look as expected.</p> <p>Fonts that are not installed on the base platform can be used via <code>@font-face</code> CSS directives in either stand-alone style sheets or within CSS in the HTML. These specify where to find the font files and how to reference them from HTML / CSS.  These fonts can be either:</p> <ol> <li> <p>Placed in the docma template source directory for inclusion into the compiled     template; or</p> </li> <li> <p>Imported into the document template during compilation via an     import directive; or</p> </li> <li> <p>Loaded at run-time during template rendering using standard HTML / CSS     features for remote font access.</p> </li> </ol> <p>Tip</p> <p>Option 3 is strongly deprecated for performance reasons.</p>"},{"location":"09-fonts.html#fonts-included-in-the-template-source","title":"Fonts Included in the Template Source","text":"<p>A font file can be placed directly into the document template source directory. It is recommended to place fonts in the <code>fonts</code> sub-directory. e.g.</p> <pre><code>&lt;template-base-dir&gt;\n\u2502\n\u251c\u2500\u2500 ...\n\u251c\u2500\u2500 fonts\n\u2502   \u2514\u2500\u2500 my-corporate-font.ttf\n\u251c\u2500\u2500 ...\n\u2514\u2500\u2500 styles.css\n</code></pre> <p>The font then needs to be declared in CSS. This can be in a standalone style sheet invoked via the <code>options-&gt;stylesheets</code> key in the template configuration file or directly within a <code>&lt;STYLE&gt;...&lt;/STYLE&gt;</code> block in a HTML document.</p> <pre><code>@font-face {\n    font-family: 'CorpFont';\n    src: url(file:fonts/my-corporate-font.ttf) format('truetype');\n}\n</code></pre> <p>Info</p> <p>In docma versions &lt;= 1.9, the font-face declaration must be in the HTML document using it. In versions &gt;= 1.10, the declaration can also be in a separate style sheet (preferred).</p> <p>This makes the font available for use in CSS styling in the normal way. e.g.</p> <pre><code>&lt;HTML lang=\"en-us\"&gt;\n&lt;HEAD&gt;\n  &lt;STYLE type=\"text/css\"&gt;\n      .corpfont {\n          font-family: CorpFont, sans-serif;\n      }\n  &lt;/STYLE&gt;\n&lt;/HEAD&gt;\n&lt;BODY&gt;\n  &lt;P style=\"corpfont\"&gt;\n    Hello world!\n  &lt;/P&gt;\n&lt;/BODY&gt;\n&lt;/HTML&gt;\n</code></pre>"},{"location":"09-fonts.html#importing-fonts-during-template-compilation","title":"Importing Fonts during Template Compilation","text":"<p>Remote fonts can be incorporated into a document template during the compilation phase using the import directive in the template configuration file .</p> <p>For example, to include the Kablammo font from Google fonts, <code>config.yaml</code> would contain something like this:</p> <pre><code># config.yaml\n\nimport:\n  - src: https://fonts.gstatic.com/s/kablammo/v1/bWtm7fHPcgrhC-J3lcXhcQTY5Ixs6Au9YgCjjw.ttf\n    as: fonts/kablammo.ttf\n\noptions:\n  stylesheets:\n    - styles.css\n</code></pre> <p>The font declaration then goes into <code>styles.css</code> like so:</p> <pre><code>@font-face {\n    font-family: 'Kablammo';\n    font-style: normal;\n    font-weight: 400;\n    src: url(file:fonts/kablammo.ttf) format('truetype');\n}\n</code></pre> <p>Info</p> <p>In docma versions &lt;= 1.9, the font-face declaration must be in the HTML document using it. In versions &gt;= 1.10, the declaration can also be in a separate style sheet (preferred).</p> <p>This makes the font available for use in CSS styling, thus:</p> <pre><code>&lt;HTML lang=\"en-us\"&gt;\n&lt;HEAD&gt;\n  &lt;STYLE type=\"text/css\"&gt;\n      .kablammo {\n          font-family: Kablammo, sans-serif;\n      }\n  &lt;/STYLE&gt;\n&lt;/HEAD&gt;\n&lt;BODY&gt;\n  &lt;P style=\"kablammo\"&gt;\n    Hello world!\n  &lt;/P&gt;\n&lt;/BODY&gt;\n&lt;/HTML&gt;\n</code></pre>"},{"location":"09-fonts.html#loading-fonts-during-template-rendering","title":"Loading Fonts during Template Rendering","text":"<p>Fonts can also be dynamically loaded at run-time during template rendering using standard HTML / CSS mechanisms. </p> <p>Tip</p> <p>Please don't do this in a production environment.</p> <p>For example, the following shows two different mechanisms for incorporating the Barrio and Dokdo fonts from Google Fonts using HTML <code>&lt;link&gt;</code> and CSS <code>@import</code> mechanisms, respectively.</p> <pre><code>&lt;HTML lang=\"en-us\"&gt;\n&lt;HEAD&gt;\n\n  &lt;link rel=\"preconnect\" href=\"https://fonts.googleapis.com\"&gt;\n  &lt;link rel=\"preconnect\" href=\"https://fonts.gstatic.com\" crossorigin&gt;\n\n  &lt;link href=\"https://fonts.googleapis.com/css2?family=Barrio\" rel=\"stylesheet\"&gt;\n\n  &lt;STYLE type=\"text/css\"&gt;\n      @import url('https://fonts.googleapis.com/css2?family=Dokdo');\n\n      .barrio {\n          font-family: \"Barrio\", system-ui;\n          font-weight: 400;\n          font-style: normal;\n      }\n\n      .dokdo {\n          font-family: \"Dokdo\", system-ui;\n          font-weight: 400;\n          font-style: normal;\n      }\n\n  &lt;/STYLE&gt;\n&lt;/HEAD&gt;\n&lt;BODY&gt;\n  &lt;P class=\"barrio\"&gt;\n    Hello world!\n  &lt;/P&gt;\n\n  &lt;P class=\"dokdo\"&gt;\n    Hello world!\n  &lt;/P&gt;\n&lt;/BODY&gt;\n&lt;/HTML&gt;\n</code></pre>"},{"location":"10-installation-and-usage.html","title":"Installation and Usage","text":""},{"location":"10-installation-and-usage.html#tldr","title":"TL;DR","text":"<p>First install the prerequisites then ...</p> <pre><code>pip install docma\n\n# Optionally, add duckdb and lava support\npip install 'docma[duckdb]'\npip install 'docma[lava]'\n\n# Check docma installed ok\ndocma --help\n\n# Create our first docma template. This is a working basic template.\ndocma new my-template\n\n# Compile it\ndocma compile -i my-template -t my-template.zip\n\n# Render it to PDF.\ndocma pdf -t my-template.zip -o my-doc.pdf\n</code></pre>"},{"location":"10-installation-and-usage.html#prerequisites","title":"Prerequisites","text":"PythonmacOSLinuxDOS <p>Docma requires Python3.11.</p> <p>GTK is required for the HTML to PDF process.</p> <pre><code>brew install gtk+\n</code></pre> <p>If DuckDB data sources are used, install the DuckDB CLI.</p> <pre><code>brew install duckdb\n</code></pre> <p>Pango is required for the HTML to PDF process.</p> <p>If DuckDB data sources are used, install the DuckDB CLI. The Python API will be installed automatically when docma is installed.</p> <p>Docma might work on DOS. How would I know? Why would I care? I guess you could try WSL 2. If you do, please let us know. </p>"},{"location":"10-installation-and-usage.html#installing-docma","title":"Installing Docma","text":""},{"location":"10-installation-and-usage.html#installing-with-pip","title":"Installing with Pip","text":"<p>Basic install:</p> <pre><code>pip install docma\n</code></pre> <p>This will install the base docma Python package and the docma CLI. This will not install support for duckdb or lava data providers.</p> <p>To install support for the duckdb data provider:</p> <pre><code>pip install 'docma[duckdb]'\n</code></pre> <p>To install support for the lava data provider:</p> <pre><code>pip install 'docma[lava]'\n</code></pre>"},{"location":"10-installation-and-usage.html#installing-from-the-repo","title":"Installing from the Repo","text":"<p>Clone the docma repo.</p> <p>The rest of the setup is handled by the Makefile.</p> <pre><code># Create venv and install the required Python packages\nmake init\n# Activate the virtual environment\nsource venv/bin/activate\n</code></pre> <p>To run the docma CLI directly from the repo:</p> <pre><code>python3 -m docma.cli.docma --help\n</code></pre> <p>To build docma, use the Makefile.</p> <pre><code># See what we can build ...\nmake\n# ... or ....\nmake help\n</code></pre> <p>To build an install bundle:</p> <pre><code>make pkg\n</code></pre>"},{"location":"10-installation-and-usage.html#docker","title":"Docker","text":"<p>The repo includes support for building a docker container on an Amazon Linux 2023 base with docma installed. To build the image:</p> <pre><code>make docker\n</code></pre> <p>This will include support for the duckdb data provider, but not the lava data provider.</p> <p>Info</p> <p>The basic image doesn't add any fonts to the minimal set already available in the Amazon Linux 2023 image. To add fonts, build your own image on the docma base image.</p>"},{"location":"10-installation-and-usage.html#the-docma-cli","title":"The Docma CLI","text":"<p>The docma CLI provides everything required to compile and render document templates.</p> <pre><code># Get help\ndocma --help\n</code></pre> <p>It supports the following sub-commands.</p> Command Description compile Compile a source directory into a document template. html Render a document template to PDF. html-batch Render a batch of HTML documents from a single document template. info Print information about a document template. new Create a new docma template source directory. pdf Render a document template to PDF. pdf-batch Render a batch of PDF documents from a single document template. <p>Each sub-command has its own help:</p> <pre><code>docma compile --help\n</code></pre> <p>A typical usage sequence might be:</p> <pre><code># First create the source for the document template in its own directory\ndocma new my-template\n\n# Add content, configuration etc. Then ...\n\n# Compile\ndocma compile -i my-template -t my-template.zip\n\n# Render to PDF\ndocma pdf -t my-template.zip -o my-doc.pdf --file parameters.yaml\n\n# Render to HTML\ndocma html -t my-template.zip -o my-doc.pdf --file parameters.yaml\n</code></pre>"},{"location":"10-installation-and-usage.html#creating-a-new-document-template","title":"Creating a New Document Template","text":"<p>To create a new docma template directory:</p> <pre><code>docma new &lt;DIRECTORY&gt;\n</code></pre> <p>This will prompt the user to enter a small number of configuration parameters. They are all mandatory. Do not leave anything blank.</p> <p>The specified directory will now contain a very simple, but complete, document template source directory that can be compiled and rendered:</p> <pre><code>docma compile -i &lt;DIRECTORY&gt; -t my-template.zip\ndocma pdf -t my-template.zip -o my-doc.pdf\n</code></pre>"},{"location":"10-installation-and-usage.html#docma-python-api","title":"Docma Python API","text":"<p>The API is quite basic:</p> <pre><code>from docma import compile_template, render_template_to_pdf\n\ntemplate_src_dir = 'a/b/c'\ntemplate_location = 'my-template.zip'  # ... or a directory when experimenting\npdf_location = 'my-doc.pdf'\nparams = {...}  # A Dict of parameters.\n\ncompile_template(template_src_dir, template_location)\n\npdf = render_template_to_pdf(template_location, params)\n\n# We now have a pypdf PdfWriter object. Do with it what you will. e.g.\npdf.write(pdf_location)\n</code></pre> <p>Refer to the API documentation for more information.</p>"},{"location":"10-installation-and-usage.html#building-the-documentation","title":"Building the Documentation","text":"<p>Docma comes with this user guide and auto-generated API documentation.</p> <p>To build the documentation:</p> <pre><code>make doc\n</code></pre> <p>The generated documentation is placed in the <code>dist/doc</code> directory.</p> <p>To see the documentation locally:</p> <pre><code>make serve\n</code></pre> <p>This uses mkdocs to run a local server on <code>http://127.0.0.1:8000/</code>.</p> <p>If editing the documentation, ensure that a spell check is done as part of the process using:</p> <pre><code>make spell\n</code></pre> <p>This requires the <code>aspell</code> tool. For macOS:</p> <pre><code>brew install aspell\n</code></pre>"},{"location":"10-installation-and-usage.html#running-unit-tests","title":"Running Unit Tests","text":"<p>The unit tests require some docker based components (Postgres, web server etc.) to be up and running. These require a <code>.env</code> file containing credentials for test accounts etc. In the main directory, copy <code>dot-env-sample</code> to <code>.env</code> and edit it to add passwords in the indicated spots. The values don't really matter as the accounts will be created as part of each test session. Even so, do not add <code>.env</code> to the repo. It's bad form.</p> <p>To run the tests:</p> <pre><code># Start the docker components. This will take a while on first invocation as it\n# needs to download base images and build some stuff on them.\nmake up\n\n# Run tests \nmake test\n\n# Get a coverage report \nmake coverage\n\n# Check the coverage report (on a Mac)\nopen -a Safari dist/test/htmlcov/index.html\n\n# Stop the docker components when done\nmake down\n</code></pre>"},{"location":"10-installation-and-usage.html#extending-docma","title":"Extending Docma","text":"<p>Docma has a number of plugable interfaces to allow extension. The process works by placing a Python file in the appropriate directory in the code base, unless otherwise indicated. These are automatically discovered as required.</p>"},{"location":"10-installation-and-usage.html#content-importers","title":"Content Importers","text":"<p>Content importers operate during the docma compile phase. They collect components from external sources and inject them into the compilation process.</p> <p>Imported components are referenced via a URL <code>scheme://....</code>. The <code>scheme</code> is used to select the importer to be used.</p> <p>To create a new importer, add a new Python file into <code>docma/importers</code>. It will contain a decorated function that has a signature like so:</p> <pre><code>@content_importer('http', 'https')\ndef _(uri: str, max_size: int = 0) -&gt; bytes:\n    \"\"\"Get an object from the web.\"\"\"\n    ...\n</code></pre>"},{"location":"10-installation-and-usage.html#content-compilers","title":"Content Compilers","text":"<p>Content compilers operate during the docma compile phase. They transform a source format into HTML. The source format is determined by the filename suffix.</p> <p>To create a new compiler, add a new Python file into <code>docma/compilers</code>. It will contain a decorated function that has a signature like so:</p> <pre><code>@content_compiler('xyz')\ndef _(src_data: bytes) -&gt; str:\n    \"\"\"Compile xyz source files into HTML.\"\"\"\n\n    return ...\n</code></pre>"},{"location":"10-installation-and-usage.html#url-fetchers","title":"URL Fetchers","text":"<p>URL fetchers operate during the docma render phase.  They provide WeasyPrint with the means to resolve URLs within the HTML being converted to PDF.</p> <p>URL fetchers are selected based on the scheme of the URL.</p> <p>To create a new URL fetcher, add a new Python file into <code>docma/fetchers</code>. For example, to handle URLs of the form <code>xyz://....</code>, the new file will have a function with a signature like so:</p> <pre><code>@fetcher('xyz')\ndef _(purl: ParseResult, context: DocmaRenderContext) -&gt; dict[str, Any]:\n    \"\"\"\n    Fetch xyz:... URLs for WeasyPrint.\n\n    :param purl:    A parsed URL. See urllib.parse.urlparse().\n    :param context: Document rendering context.\n\n\n    :return:        A dict containing the URL content and mime type.\n    \"\"\"\n\n    ...\n\n    return {\n        'string': ...,  # This is named `string` but must be a bytestring.\n        'mime_type': ...\n\n    }\n</code></pre>"},{"location":"10-installation-and-usage.html#content-generators","title":"Content Generators","text":"<p>Content generators operate during the docma render phase. They dynamically generate content for WeasyPrint when a URL in the following form is accessed.</p> <pre><code>docma:&lt;generator-name&gt;?&lt;generator-params&gt;\n</code></pre> <p>They are typically used for generating image content (charts, QR codes etc.) but they can be used wherever URLs return content to WeasyPrint.</p> <p>To create a new content generator, add a new Python file into <code>docma/generators</code>. Start by copying the sample <code>swatch.py</code> generator and modifying as required.</p>"},{"location":"10-installation-and-usage.html#data-providers","title":"Data Providers","text":"<p>Data providers operate during the docma render phase.</p> <p>The data provider handler is selected by the <code>type</code> component of a data source specification.</p> <p>To create a new data provider, add a new Python file into <code>docma/data_providers</code>. Start by copying one of the existing providers and modify as needed.</p>"},{"location":"10-installation-and-usage.html#format-checkers","title":"Format Checkers","text":"<p>Docma has a number of custom format checkers that serve a dual role as JSON Schema string formats and custom Jinja tests. These are implemented using a simple plugin mechanism. Read the docstring at the top of <code>docma/lib/plugin.py</code> before launching into it.</p> <p>To create a new format checker, add a new Python file into <code>docma/plugins/format_checkers</code>.  Start by copying one of the existing checkers.</p> <p>Checkers can be grouped together in families (e.g. the <code>au.*</code> suite) using nested Python packages (directories containing <code>__init__.py</code>). The discovery and loading process is automatic.</p> <p>Each checker is basically a decorated function with a single parameter, being the string value to be checked, and must return a boolean indicating whether it conforms to the required format, or not.</p> <p>It is also possible to have checkers with names generated dynamically at run-time. Tricky. Don't start here on day one but check out the <code>DateFormatResolver</code> class in <code>docma/jinja/resolvers.py</code> if the fever is upon you.</p> <p>Info</p> <p>Resolvers are not automatically discovered.</p>"},{"location":"10-installation-and-usage.html#custom-jinja-filters","title":"Custom Jinja Filters","text":"<p>Docma has a number of custom Jinja filters. These are implemented using a simple plugin mechanism. Read the docstring at the top of <code>docma/lib/plugin.py</code>  before launching into it.</p> <p>To create a new format checker, add a new Python file into <code>docma/plugins/jinja_filters</code>.  Start by copying one of the existing filters.</p> <p>Checkers can be grouped together in families (e.g. the <code>au.*</code> suite) using nested Python packages (directories containing <code>__init__.py</code>). The discovery and loading process is automatic.</p> <p>It is also possible to have filters with names generated dynamically at run-time. For example, the currency filters work this way. Tricky. Don't start here on day one but check out the <code>CurrencyFilterResolver</code> class in <code>docma/jinja/resolvers.py</code> if inspiration strikes.</p> <p>Info</p> <p>Resolvers are not automatically discovered.</p>"},{"location":"10-installation-and-usage.html#custom-jinja-tests","title":"Custom Jinja Tests","text":"<p>Docma does not currently provide any custom Jinja tests, other than custom format checkers which are kept separate because they server both Jinja and JSON Schema.</p> <p>Unlike custom format checkers, custom tests can be written to accept arguments additional to the value being tested.</p> <p>All of the scaffolding required to add custom Jinja tests is present. The mechanism is the same as used for adding custom jinja filters except that the required decorator is <code>@jtest</code> instead of <code>@jfilter</code> and they should be placed in <code>docma/plugins/jinja_tests</code> instead of <code>docma/plugins/jinja_filters</code>. The discovery and loading process is automatic.</p>"},{"location":"10-installation-and-usage.html#custom-jinja-extensions","title":"Custom Jinja Extensions","text":"<p>Docma has a number of custom Jinja extensions. These are all contained in the file <code>docma/jinja/extensions.py</code>. New ones can be added to this file but if you think you need to, think again.</p>"},{"location":"12-caveats-and-issues.html","title":"Caveats and Known Issues","text":"<ul> <li> <p>Docma does not try particularly hard to be parsimonious with memory usage.</p> </li> <li> <p>Docma does pool database connections, but the approach to doing this is     fairly naive and may need to be revisited for higher volumes.</p> </li> <li> <p>Watch out for HTML authoring systems that leave Jinja-like fragments behind.     These will clash with docma's use of Jinja and will generally need to be     removed.</p> </li> <li> <p>WeasyPrint suppresses some errors when rendering HTML and tries hard to     produce something. This is unfortunate. In docma, it would have been     preferable to fail if rendering fails to avoid an incomplete document.</p> </li> <li> <p>Internal document links within the rendered PDF don't work.</p> </li> </ul>"},{"location":"13-credits.html","title":"Credits","text":"<p>Thanks to MenaG for inspiring this idea in the first place and for having faith that it was worth the bother.</p> <p>Thanks to Alex Boul, and Art Dorokhov for contributing to docma.</p> <p>Docma is possible because of these amazing Python packages:</p> <ul> <li> <p>WeasyPrint</p> </li> <li> <p>Jinja2</p> </li> <li> <p>Vega-Altair</p> </li> <li> <p>PyPDF</p> </li> </ul> <p>Honourable mentions:</p> <ul> <li> <p>Babel</p> </li> <li> <p>Phonenumbers</p> </li> </ul>"},{"location":"14-release-notes.html","title":"Release Notes","text":""},{"location":"14-release-notes.html#version-2","title":"Version 2","text":""},{"location":"14-release-notes.html#version-220","title":"Version 2.2.0","text":"<ul> <li> <p>The Jinja subsystem has been refactored substantially (backward compatible).     Changes include:</p> <ul> <li> <p>Region specific filters are now named with the 2 character ISO country     code as a prefix. e.g. au.ABN replaces <code>abn</code> and     au.ACN replaces <code>acn</code>.  Using the old forms will     still work but produces a deprecation warning.</p> </li> <li> <p>Adding new generic and region specific filters has been simplified.</p> </li> <li> <p>Docma templates now support locales. A     locale is a string such as <code>en_AU</code>, <code>fr_CA</code>, etc and can     influence the behaviour of things such as     Jinja filters.</p> </li> <li> <p>The names of docma custom Jinja filters, Jinja tests and     format checkers are case insensitive.</p> </li> </ul> </li> <li> <p>The following Jinja filters have been added for use in document templates.     These are all locale / region aware. Credit to the     Babel and     phonenumbers packages for making     this possible. All of the filters come with sensible defaults. The Babel based     filters in particular provide a high degree of control over formatting using     the Locale Data Markup Language     specification     (LDML) if the defaults don't suit.</p> <ul> <li> <p>phone  formats international phone numbers.</p> </li> <li> <p>currency formats international currencies.     This also provides support for currency specific filters such as <code>AUD</code> ,     <code>EUR</code>, <code>GBP</code> for a wide range of currencies. The older <code>dollars</code> filter     is still supported but discouraged (not deprecated, as such).</p> </li> <li> <p>decimal and     compact_decimal format numbers using     locale specific conventions.</p> </li> <li> <p>percent formats percentages using locale     specific conventions.</p> </li> <li> <p>date, datetime,     time and timedelta     format datetime elements using locale specific conventions.</p> </li> <li> <p>parse_date and     parse_time parse dates and times into the     appropriate Python objects using locale specific conventions.</p> </li> </ul> </li> <li> <p>A new suite of format checkers has     been introduced. These serve the dual purpose of being available as <code>format</code>     entries for string objects in JSON Schema specifications as well as custom     Jinja tests.</p> </li> <li> <p>The following changes have been made to the <code>docma new</code> command used to     create a new document template:</p> <ul> <li> <p>Some basic validation has been added to user input values.</p> </li> <li> <p>The default <code>locale</code> for the template must now be specified.</p> </li> </ul> </li> <li> <p>The docma.format rendering     parameter has been added to indicate the type of output document being     produced, <code>HTML</code> or <code>PDF</code>.</p> </li> <li> <p>Some minor improvements in error messages for database related errors have     been made. (Credit MN.)</p> </li> <li> <p>Added the <code>make count</code> target to count lines of code, doc, stuff. Why not?</p> </li> <li> <p>Converted user guide to mkdocs material.</p> </li> </ul>"},{"location":"14-release-notes.html#version-210","title":"Version 2.1.0","text":"<p>This is the open source base release.</p> <p>Changes from v2.0.0 are:</p> <ul> <li> <p>Updated CLI install approach.</p> </li> <li> <p>Incremental increase in test coverage.</p> </li> <li> <p>Editorial changes in the user guide.</p> </li> <li> <p>Docker build switched to buildkit.</p> </li> <li> <p>The size limit on imported documents has been increased from 5MB to 10MB.</p> </li> </ul>"}]}